Index: builddefines.h
===================================================================
--- builddefines.h	(revision 1300)
+++ builddefines.h	(working copy)
@@ -48,5 +48,6 @@
 // but for now, just tell the compiler to shut up so I can see the real errors.
 #define _CRT_SECURE_NO_WARNINGS
 #define _CRT_NON_CONFORMING_SWPRINTFS
+#define _CRT_SECURE_NO_DEPRECATE
 
 #endif
\ No newline at end of file
Index: Editor/EditorItems.cpp
===================================================================
--- Editor/EditorItems.cpp	(revision 1299)
+++ Editor/EditorItems.cpp	(working copy)
@@ -188,6 +188,7 @@
 				case IC_MEDKIT:
 				case IC_KIT:
 				case IC_FACE:
+				case IC_LBEGEAR:
 				case IC_MISC:
 				case IC_MONEY:
 					if( eInfo.sNumEquipment1 < 30 )
@@ -440,6 +441,7 @@
 				case IC_MEDKIT:
 				case IC_KIT:
 				case IC_FACE:
+				case IC_LBEGEAR:
 				case IC_MISC:
 				case IC_MONEY:
 					if( usCounter == ACTION_ITEM || usCounter == SWITCH )
Index: Editor/EditorMercs.cpp
===================================================================
--- Editor/EditorMercs.cpp	(revision 1299)
+++ Editor/EditorMercs.cpp	(working copy)
@@ -2973,7 +2973,9 @@
 	{
 		if( gpSelected->pDetailedPlacement->ubProfile != NO_PROFILE )
 		{
-			memcpy( &gpSelected->pDetailedPlacement->Inv, &gpSelected->pSoldier->inv, sizeof( OBJECTTYPE ) * NUM_INV_SLOTS );
+			//CHRISL: Use Inventory constructor?
+			gpSelected->pDetailedPlacement->Inv.operator =(gpSelected->pSoldier->inv);
+			//memcpy( gpSelected->pDetailedPlacement->Inv, gpSelected->pSoldier->inv, sizeof( OBJECTTYPE ) * NUM_INV_SLOTS );
 		}
 		for( x = 0; x < 9; x++ )
 		{
@@ -3668,8 +3670,7 @@
 		if( gTempBasicPlacement.fDetailedPlacement )
 		{
                         // WDS - Clean up inventory handling
-			// WANNE: Removed the following line, didn't compile
-			//gTempDetailedPlacement = *gSaveBufferDetailedPlacement;
+			gTempDetailedPlacement = gSaveBufferDetailedPlacement;
 		}
 		else
 		{
@@ -3752,3 +3753,4 @@
  
 
 
+
Index: Editor/Item Statistics.cpp
===================================================================
--- Editor/Item Statistics.cpp	(revision 1299)
+++ Editor/Item Statistics.cpp	(working copy)
@@ -415,6 +415,7 @@
 		case IC_MEDKIT:
 		case IC_KIT:
 		case IC_MISC:
+		case IC_LBEGEAR:
 		case IC_FACE:
 		case IC_BLADE:
 		case IC_LAUNCHER:
Index: GameInitOptionsScreen.cpp
===================================================================
--- GameInitOptionsScreen.cpp	(revision 1300)
+++ GameInitOptionsScreen.cpp	(working copy)
@@ -79,6 +79,11 @@
 #define		GIO_IRON_MAN_SETTING_Y					iScreenHeightOffset + 355
 #define		GIO_IRON_MAN_SETTING_WIDTH				GIO_DIF_SETTINGS_WIDTH
 
+// CHRISL:
+#define		GIO_INV_SETTING_X						iScreenWidthOffset + 340
+#define		GIO_INV_SETTING_Y						GIO_IRON_MAN_SETTING_Y
+#define		GIO_INV_SETTING_WIDTH					GIO_DIF_SETTINGS_WIDTH
+
 //Difficulty settings
 enum
 {
@@ -120,6 +125,15 @@
 	NUM_BR_OPTIONS,
 };
 
+// CHRISL: New inventory options
+enum
+{
+	GIO_INV_OLD,
+	GIO_INV_NEW,
+
+	NUM_INV_OPTIONS,
+};
+
 // JA2Gold: no more timed turns setting
 
 /*
@@ -219,6 +233,9 @@
 UINT32	guiBROptionToggles[ NUM_BR_OPTIONS ];
 void BtnBROptionTogglesCallback(GUI_BUTTON *btn,INT32 reason);
 
+// CHRISL: checkbox to toggle INV selection
+UINT32	guiINVOptionToggles[ NUM_INV_OPTIONS ];
+void BtnINVOptionTogglesCallback(GUI_BUTTON *btn,INT32 reason);
 
 ////////////////////////////////////////////
 //
@@ -455,6 +472,27 @@
 			break;
 	}
 
+	// CHRISL: New inventory options
+	usPosY = GIO_INV_SETTING_Y - GIO_OFFSET_TO_TOGGLE_BOX_Y;
+	for( cnt=0; cnt<NUM_INV_OPTIONS; cnt++)
+	{
+		guiINVOptionToggles[ cnt ] = CreateCheckBoxButton(	GIO_INV_SETTING_X+GIO_OFFSET_TO_TOGGLE_BOX, usPosY, 
+																		"INTERFACE\\OptionsCheck.sti", MSYS_PRIORITY_HIGH+10, 
+																		BtnINVOptionTogglesCallback );
+		MSYS_SetBtnUserData( guiINVOptionToggles[ cnt ], 0, cnt );
+
+		usPosY += GIO_GAP_BN_SETTINGS-5;
+	}
+	switch( gGameOptions.ubInventorySystem )
+	{
+		case INVENTORY_OLD:
+			ButtonList[ guiINVOptionToggles[ GIO_INV_OLD ] ]->uiFlags |= BUTTON_CLICKED_ON;
+			break;
+		case INVENTORY_NEW:
+			ButtonList[ guiINVOptionToggles[ GIO_INV_NEW ] ]->uiFlags |= BUTTON_CLICKED_ON;
+			break;
+	}
+
 	// JA2Gold: iron man buttons
 	usPosY = GIO_IRON_MAN_SETTING_Y - GIO_OFFSET_TO_TOGGLE_BOX_Y;
 	for( cnt=0; cnt<NUM_SAVE_OPTIONS; cnt++)
@@ -570,6 +608,10 @@
 	for( cnt=0; cnt<NUM_BR_OPTIONS; cnt++)
 		RemoveButton( guiBROptionToggles[ cnt ] );
 
+// CHRISL
+	for( cnt=0; cnt<NUM_INV_OPTIONS; cnt++)
+		RemoveButton( guiINVOptionToggles[ cnt ] );
+
 	// JA2Gold: remove iron man buttons
 	for( cnt=0; cnt<NUM_SAVE_OPTIONS; cnt++)
 		RemoveButton( guiGameSaveToggles[ cnt ] );
@@ -727,6 +769,15 @@
 
 	DisplayWrappedString( (UINT16)(GIO_BR_SETTING_X+GIO_OFFSET_TO_TEXT), usPosY, GIO_DIF_SETTINGS_WIDTH, 2, GIO_TOGGLE_TEXT_FONT, GIO_TOGGLE_TEXT_COLOR, gzGIOScreenText[ GIO_BR_AWESOME_TEXT ], FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );
 
+// CHRISL
+	DisplayWrappedString( GIO_INV_SETTING_X, (UINT16)(GIO_INV_SETTING_Y-GIO_GAP_BN_SETTINGS), GIO_DIF_SETTINGS_WIDTH + 20, 2, GIO_TOGGLE_TEXT_FONT, GIO_TOGGLE_TEXT_COLOR, gzGIOScreenText[ GIO_INV_TEXT ], FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );
+	usPosY = GIO_INV_SETTING_Y+2;
+
+	DisplayWrappedString( (UINT16)(GIO_INV_SETTING_X+GIO_OFFSET_TO_TEXT), usPosY, GIO_DIF_SETTINGS_WIDTH, 2, GIO_TOGGLE_TEXT_FONT, GIO_TOGGLE_TEXT_COLOR, gzGIOScreenText[ GIO_INV_OLD_TEXT ], FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );
+	usPosY += GIO_GAP_BN_SETTINGS-5;
+
+	DisplayWrappedString( (UINT16)(GIO_INV_SETTING_X+GIO_OFFSET_TO_TEXT), usPosY, GIO_DIF_SETTINGS_WIDTH, 2, GIO_TOGGLE_TEXT_FONT, GIO_TOGGLE_TEXT_COLOR, gzGIOScreenText[ GIO_INV_NEW_TEXT ], FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );
+
 // JA2Gold: Display the iron man Settings Title Text
 
 	DisplayWrappedString( GIO_IRON_MAN_SETTING_X, (UINT16)(GIO_IRON_MAN_SETTING_Y-GIO_GAP_BN_SETTINGS), GIO_DIF_SETTINGS_WIDTH, 2, GIO_TOGGLE_TEXT_FONT, GIO_TOGGLE_TEXT_COLOR, gzGIOScreenText[ GIO_GAME_SAVE_STYLE_TEXT ], FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );
@@ -861,6 +912,45 @@
 	}
 }
 
+// CHRISL:
+void BtnINVOptionTogglesCallback(GUI_BUTTON *btn,INT32 reason)
+{
+	if( reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
+	{
+		UINT8	ubButton = (UINT8)MSYS_GetBtnUserData( btn, 0 );
+
+		if( btn->uiFlags & BUTTON_CLICKED_ON )
+		{
+			UINT8	cnt;
+
+			for( cnt=0; cnt<NUM_INV_OPTIONS; cnt++)
+			{
+				ButtonList[ guiINVOptionToggles[ cnt ] ]->uiFlags &= ~BUTTON_CLICKED_ON;
+			}
+
+			//enable the current button
+			btn->uiFlags |= BUTTON_CLICKED_ON;
+		}
+		else
+		{
+			UINT8	cnt;
+			BOOLEAN fAnyChecked=FALSE;
+
+			//if none of the other boxes are checked, do not uncheck this box
+			for( cnt=0; cnt<NUM_INV_OPTIONS; cnt++)
+			{
+				if( ButtonList[ guiINVOptionToggles[ cnt ] ]->uiFlags & BUTTON_CLICKED_ON )
+				{
+					fAnyChecked = TRUE;
+				}
+			}
+			//if none are checked, re check this one
+			if( !fAnyChecked )
+				btn->uiFlags |= BUTTON_CLICKED_ON;
+		}
+	}
+}
+
 void BtnGameStyleTogglesCallback( GUI_BUTTON *btn, INT32 reason )
 {
 	if( reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
@@ -1093,6 +1183,21 @@
 	return( 0 );
 }
 
+// CHRISL:
+UINT8	GetCurrentINVOptionButtonSetting()
+{
+	UINT8	cnt;
+
+	for( cnt=0; cnt<NUM_INV_OPTIONS; cnt++)
+	{
+		if( ButtonList[ guiINVOptionToggles[ cnt ] ]->uiFlags & BUTTON_CLICKED_ON )
+		{
+			return( cnt );
+		}
+	}
+	return( 0 );
+}
+
 UINT8	GetCurrentGameStyleButtonSetting()
 {
 	UINT8	cnt;
@@ -1215,6 +1320,15 @@
 		RestoreExternBackgroundRect( GIO_BR_SETTING_X+GIO_OFFSET_TO_TOGGLE_BOX, usPosY, 34, 29 ); 
 		usPosY += GIO_GAP_BN_SETTINGS-5;
 	}
+
+// CHRISL
+
+	usPosY = GIO_INV_SETTING_Y-GIO_OFFSET_TO_TOGGLE_BOX_Y;
+	for( cnt=0; cnt<NUM_INV_OPTIONS; cnt++)
+	{
+		RestoreExternBackgroundRect( GIO_INV_SETTING_X+GIO_OFFSET_TO_TOGGLE_BOX, usPosY, 34, 29 ); 
+		usPosY += GIO_GAP_BN_SETTINGS-5;
+	}
 }
 
 
@@ -1246,6 +1360,16 @@
 			break;
 	}
 
+	// CHRISL:
+	switch ( GetCurrentINVOptionButtonSetting() )
+	{
+		case GIO_INV_OLD:
+			gGameOptions.ubInventorySystem = INVENTORY_OLD;
+			break;
+		case GIO_INV_NEW:
+			gGameOptions.ubInventorySystem = INVENTORY_NEW;
+			break;
+	}
 	//	gubGIOExitScreen = INIT_SCREEN;
 	gubGIOExitScreen = INTRO_SCREEN;
 
Index: GameSettings.cpp
===================================================================
--- GameSettings.cpp	(revision 1300)
+++ GameSettings.cpp	(working copy)
@@ -296,6 +296,7 @@
 	gGameOptions.fAirStrikes		= FALSE;
 	gGameOptions.ubGameStyle		= STYLE_SCIFI;
 	gGameOptions.ubDifficultyLevel	= DIF_LEVEL_MEDIUM;
+	gGameOptions.ubInventorySystem	= INVENTORY_OLD;
 	//gGameOptions.fTurnTimeLimit	= FALSE;
 	
 	gGameOptions.fIronManMode		= FALSE;
Index: GameSettings.h
===================================================================
--- GameSettings.h	(revision 1300)
+++ GameSettings.h	(working copy)
@@ -95,6 +95,13 @@
 
 
 
+// CHRISL: New Enums to track inventory system
+enum
+{
+	INVENTORY_OLD = 0,
+	INVENTORY_NEW = 1
+};
+
 //Enums for the difficulty levels
 enum
 {
@@ -131,7 +138,8 @@
 	BOOLEAN	fTurnTimeLimit;
 	BOOLEAN	fIronManMode;
 	UINT8	ubBobbyRay;
-	UINT8	ubFiller[7];
+	UINT8	ubInventorySystem;
+	UINT8	ubFiller[6];
 
 } GAME_OPTIONS;
 
@@ -411,6 +419,9 @@
 	BOOLEAN fEnableSoldierTooltipBigSlot2;
 	BOOLEAN fEnableSoldierTooltipBigSlot3;
 	BOOLEAN fEnableSoldierTooltipBigSlot4;
+	BOOLEAN fEnableSoldierTooltipBigSlot5;
+	BOOLEAN fEnableSoldierTooltipBigSlot6;
+	BOOLEAN fEnableSoldierTooltipBigSlot7;
 	// ShadoWarrior: Tooltip changes (end)
 
 	//Kaiden MERC Deaths Externalized:
Index: GameVersion.cpp
===================================================================
--- GameVersion.cpp	(revision 1300)
+++ GameVersion.cpp	(working copy)
@@ -36,6 +36,7 @@
 //		Keeps track of the saved game version.  Increment the saved game version whenever 
 //	you will invalidate the saved game file
 
-#define			SAVE_GAME_VERSION					101	//100 // 99
+#define			SAVE_GAME_VERSION					102 //101	//100 // 99
 
 const	UINT32	guiSavedGameVersion = SAVE_GAME_VERSION;
+const UINT32 SAVE_GAMES_HAVE_NEW_INVENTORY_VECTORS = 102;
Index: GameVersion.h
===================================================================
--- GameVersion.h	(revision 1300)
+++ GameVersion.h	(working copy)
@@ -25,7 +25,7 @@
 //
 
 const extern	UINT32	guiSavedGameVersion;
-
+const extern	UINT32	SAVE_GAMES_HAVE_NEW_INVENTORY_VECTORS;
 #ifdef __cplusplus
 }
 #endif
Index: Init.cpp
===================================================================
--- Init.cpp	(revision 1300)
+++ Init.cpp	(working copy)
@@ -265,7 +265,31 @@
 	if(!ReadInArmourStats(fileName))
 		return FALSE;
 
+	// CHRISL:
 	strcpy(fileName, directoryName);
+	strcat(fileName, LOADBEARINGEQUIPMENTFILENAME);
+	if(!ReadInlbeStats(fileName))
+		return FALSE;
+//	if(!WritelbeEquipmentStats())
+//		return FALSE;
+
+	// CHRISL:
+	strcpy(fileName, directoryName);
+	strcat(fileName, LBEPOCKETFILENAME);
+	if(!ReadInLBEPocketStats(fileName))
+		return FALSE;
+//	if(!WriteLBEPocketEquipmentStats())
+//		return FALSE;
+
+	// CHRISL:
+	strcpy(fileName, directoryName);
+	strcat(fileName, MERCSTARTINGGEARFILENAME);
+	if(!ReadInMercStartingGearStats(fileName))
+		return FALSE;
+//	if(!WriteMercStartingGearStats())
+//		return FALSE;
+
+	strcpy(fileName, directoryName);
 	strcat(fileName, WEAPONSFILENAME);
 	if(!ReadInWeaponStats(fileName))
 		return FALSE;
Index: Language Defines.h
===================================================================
--- Language Defines.h	(revision 1300)
+++ Language Defines.h	(working copy)
@@ -33,7 +33,7 @@
  * Regardless of if we did it Workspace wide or by uncommenting above,
  * HERE we must see, what language was selected. If one, we
  */
-#if defined(ENGLISH)
+/*#if defined(ENGLISH)
 #  pragma message(" (Language set to ENGLISH, You'll need english CDs)")
 #elif defined(GERMAN)
 #  pragma message(" (Language set to GERMAN, You'll need Topware/german CDs)")
@@ -46,11 +46,11 @@
 #else
 #  error "At least You have to specify a Language somewhere. See comments above."
 #endif
+*/
 
 
 
 
-
 #define BLOOD_N_GORE_ENABLED
 
 //if the language represents words as single chars
@@ -58,4 +58,4 @@
 	#define	SINGLE_CHAR_WORDS
 #endif
 
-#endif
\ No newline at end of file
+#endif
Index: Laptop/BobbyRGuns.cpp
===================================================================
--- Laptop/BobbyRGuns.cpp	(revision 1299)
+++ Laptop/BobbyRGuns.cpp	(working copy)
@@ -147,7 +147,7 @@
 #define		NUMBER_GUNS_FILTER_BUTTONS			9
 #define		NUMBER_AMMO_FILTER_BUTTONS			8
 #define		NUMBER_ARMOUR_FILTER_BUTTONS		4
-#define		NUMBER_MISC_FILTER_BUTTONS			9
+#define		NUMBER_MISC_FILTER_BUTTONS			10
 #define		NUMBER_USED_FILTER_BUTTONS			3
 
 #define		BOBBYR_GUNS_FILTER_BUTTON_GAP			BOBBYR_CATALOGUE_BUTTON_GAP - 1
@@ -213,6 +213,7 @@
 							BOBBYR_FILTER_MISC_MEDKIT,
 							BOBBYR_FILTER_MISC_KIT,
 							BOBBYR_FILTER_MISC_FACE,
+							BOBBYR_FILTER_MISC_LBEGEAR,
 							BOBBYR_FILTER_MISC_MISC};
 
 
@@ -295,6 +296,8 @@
 UINT16 DisplayRange(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight);
 UINT16 DisplayMagazine(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight);
 void DisplayItemNameAndInfo(UINT16 usPosY, UINT16 usIndex, UINT16 usBobbyIndex, BOOLEAN fUsed);
+// CHRISL: New display function for LBE Gear
+UINT16 DisplayLBEInfo(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight);
 UINT16 DisplayWeight(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight);
 UINT16 DisplayCaliber(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight);
 void CreateMouseRegionForBigImage(UINT16 usPosY, UINT8 ubCount, INT16 *pItemNumbers );
@@ -652,9 +655,10 @@
 BOOLEAN InitBobbyRMiscFilterBar()
 {
 	UINT8	i;
-	UINT16	usPosX;
+	UINT16	usPosX = 0, usPosY = 0;
 	UINT8	bCurMode;
-	UINT16	usYOffset = 0;
+	UINT16	usYOffset = 25, sItemWidth = 8;
+	UINT16	usXOffset = BOBBYR_MISC_FILTER_BUTTON_GAP;
 
 	bCurMode = 0;
 	usPosX = FILTER_BUTTONS_MISC_START_X;
@@ -664,26 +668,28 @@
 	// Loop through the filter buttons
 	for(i=0; i<NUMBER_MISC_FILTER_BUTTONS; i++)
 	{
+		//CHRISL: Don't display the LBEGEAR button if we're using the old inventory system
+		if(!gGameOptions.ubInventorySystem && ubFilterMiscButtonValues[bCurMode] == BOBBYR_FILTER_MISC_LBEGEAR)
+			continue;
 		// Next row
-		if (i > 7)
-		{
-			usPosX = FILTER_BUTTONS_MISC_START_X;
-			usYOffset = 25;
-		}
+//		if (i >= sItemWidth)
+//			usYOffset = 25;
 
 		// Filter buttons
+		usPosX = FILTER_BUTTONS_MISC_START_X + ( (i % sItemWidth) * usXOffset);
+		usPosY = FILTER_BUTTONS_Y + ( (i / sItemWidth) * usYOffset);
 		guiBobbyRFilterMisc[i] = CreateIconAndTextButton( guiBobbyRFilterImage, BobbyRFilter[BOBBYR_FILTER_MISC_BLADE+i], BOBBYR_GUNS_BUTTON_FONT, 
 													BOBBYR_GUNS_TEXT_COLOR_ON, BOBBYR_GUNS_SHADOW_COLOR, 
 													BOBBYR_GUNS_TEXT_COLOR_OFF, BOBBYR_GUNS_SHADOW_COLOR, 
 													TEXT_CJUSTIFIED, 
-													usPosX, FILTER_BUTTONS_Y + usYOffset, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH,
+													usPosX, usPosY, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH,
 													DEFAULT_MOVE_CALLBACK, BtnBobbyRFilterMiscCallback);
 
 		SetButtonCursor(guiBobbyRFilterMisc[i], CURSOR_LAPTOP_SCREEN);
 
 		MSYS_SetBtnUserData( guiBobbyRFilterMisc[i], 0, ubFilterMiscButtonValues[bCurMode]);
 
-		usPosX += BOBBYR_MISC_FILTER_BUTTON_GAP;
+		//usPosX += BOBBYR_MISC_FILTER_BUTTON_GAP;
 		bCurMode++;
 	}
 	
@@ -1223,6 +1229,9 @@
 			case BOBBYR_FILTER_MISC_FACE:
 				guiCurrentMiscFilterMode = IC_FACE;
 				break;
+			case BOBBYR_FILTER_MISC_LBEGEAR:
+				guiCurrentMiscFilterMode = IC_LBEGEAR;
+				break;
 			case BOBBYR_FILTER_MISC_MISC:
 				guiCurrentMiscFilterMode = IC_MISC;
 				break;
@@ -1551,6 +1560,7 @@
 			case IC_MEDKIT:
 			case IC_KIT:
 			case IC_FACE:
+			case IC_LBEGEAR:
 				// USED
 				if (uiItemClass == BOBBYR_USED_ITEMS)
 				{
@@ -1561,6 +1571,7 @@
 							Item[usItemIndex].usItemClass == IC_MISC ||
 							Item[usItemIndex].usItemClass == IC_MEDKIT ||
 							Item[usItemIndex].usItemClass == IC_KIT ||
+							Item[usItemIndex].usItemClass == IC_LBEGEAR ||
 							Item[usItemIndex].usItemClass == IC_FACE)
 						{
 							bAddItem = TRUE;
@@ -1778,6 +1789,12 @@
 	UINT16 usFontHeight;
 	usFontHeight = GetFontHeight(BOBBYR_ITEM_DESC_TEXT_FONT);
 
+	//CHRISL: Display extra information for LBE Items when using new inventory system
+	if(gGameOptions.ubInventorySystem && Item[usIndex].usItemClass == IC_LBEGEAR)
+	{
+		usHeight = DisplayLBEInfo(usTextPosY, usIndex, usFontHeight);
+	}
+
 	//Display Items Name
 //	DisplayItemNameAndInfo(usTextPosY, usIndex, fUsed);
 
@@ -1942,7 +1959,56 @@
 	return(usPosY);
 }
 
+// CHRISL: New display function for LBE Gear
+UINT16 DisplayLBEInfo(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight)
+{
+	CHAR16				sTemp[20];
+	CHAR16				pName[80];
+	int					lnCnt=0, count, size;
+	UINT16				lbeIndex;
+	UINT8				pIndex=0;
+	vector<int>			pocketNum;
 
+	size = LBEPocketType.size();
+	pocketNum.reserve(size);
+	lbeIndex = Item[usIndex].ubClassIndex;
+	// Determine number of each pocket definition
+	for(count = 0; count<size; count++)
+	{
+		pocketNum.push_back(0);
+	}
+	// Populate "Number" for each type of pocket this LBE item has
+	for(count = 0; count<12; count++)
+	{
+		pIndex = LoadBearingEquipment[lbeIndex].lbePocketIndex[count];
+		pocketNum[pIndex]++;
+	}
+	// Go through and display the pocket type and number
+	for(count = 1; count<size; count++)
+	{
+		if(pocketNum[count]>0)
+		{
+			if(lnCnt>4)
+			{
+				swprintf(sTemp, L"More..." );
+				DrawTextToScreen(sTemp, BOBBYR_ITEM_WEIGHT_TEXT_X, (UINT16)usPosY, BOBBYR_ITEM_WEIGHT_NUM_WIDTH, BOBBYR_ITEM_DESC_TEXT_FONT, BOBBYR_ITEM_DESC_TEXT_COLOR, FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED);
+				usPosY += usFontHeight + 2;
+				break;
+			}
+			else
+			{
+				mbstowcs(pName,LBEPocketType[count].pName,80);
+				pName[14] = '\0';
+				swprintf(sTemp, L"%s(x%d)", pName, pocketNum[count] );
+				DrawTextToScreen(sTemp, BOBBYR_ITEM_WEIGHT_TEXT_X, (UINT16)usPosY, BOBBYR_ITEM_WEIGHT_NUM_WIDTH, BOBBYR_ITEM_DESC_TEXT_FONT, BOBBYR_ITEM_DESC_TEXT_COLOR, FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED);
+				usPosY += usFontHeight + 2;
+				lnCnt++;
+			}
+		}
+	}
+	return(usPosY);
+}
+
 UINT16 DisplayWeight(UINT16 usPosY, UINT16 usIndex, UINT16 usFontHeight)
 {
 	CHAR16	sTemp[20];
@@ -2926,7 +2992,9 @@
 	EnableButton(guiBobbyRFilterMisc[5]);
 	EnableButton(guiBobbyRFilterMisc[6]);
 	EnableButton(guiBobbyRFilterMisc[7]);
-	EnableButton(guiBobbyRFilterMisc[8]);
+	if(guiBobbyRFilterMisc[8])
+		EnableButton(guiBobbyRFilterMisc[8]);
+	EnableButton(guiBobbyRFilterMisc[9]);
 
 	switch (guiCurrentMiscFilterMode)
 	{
@@ -2954,9 +3022,12 @@
 		case IC_FACE:
 			DisableButton(guiBobbyRFilterMisc[7]);
 			break;
-		case IC_MISC:
+		case IC_LBEGEAR:
 			DisableButton(guiBobbyRFilterMisc[8]);
 			break;
+		case IC_MISC:
+			DisableButton(guiBobbyRFilterMisc[9]);
+			break;
 	}
 
 	//if (iNewButton != iOldButton)
@@ -3096,6 +3167,7 @@
 							Item[usItemIndex].usItemClass == IC_MISC ||
 							Item[usItemIndex].usItemClass == IC_MEDKIT ||
 							Item[usItemIndex].usItemClass == IC_KIT ||
+							Item[usItemIndex].usItemClass == IC_LBEGEAR ||
 							Item[usItemIndex].usItemClass == IC_FACE)
 						{
 							bCntItem = TRUE;
Index: Laptop/IMP Confirm.cpp
===================================================================
--- Laptop/IMP Confirm.cpp	(revision 1299)
+++ Laptop/IMP Confirm.cpp	(working copy)
@@ -33,10 +33,22 @@
 	#include "strategic.h"
 	#include "weapons.h"
 	#include "Random.h"
+	#include "GameSettings.h"
+	#include "GameVersion.h"
 #endif
 
 #define IMP_FILENAME_SUFFIX ".dat"
 
+//CHRISL: structure needed to store temporary inventory information during IMP creation
+typedef struct
+{
+	UINT16		inv;
+	UINT8		iSize;
+	UINT32		iClass;
+	UINT8		iStatus;
+	UINT8		iNumber;
+}	INVNODE;
+
 IMP_ITEM_CHOICE_TYPE gIMPItemChoices[MAX_IMP_ITEM_TYPES];
 	
 void GiveIMPRandomItems( MERCPROFILESTRUCT *pProfile, UINT8 typeIndex );
@@ -131,6 +143,12 @@
 void MakeProfileInvItemAnySlot(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubStatus, UINT8 ubHowMany);
 void MakeProfileInvItemThisSlot(MERCPROFILESTRUCT *pProfile, UINT32 uiPos, UINT16 usItem, UINT8 ubStatus, UINT8 ubHowMany);
 INT32 FirstFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubHowMany);
+// CHRISL:
+void RedistributeStartingItems(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 sPocket);
+void DistributeInitialGear(MERCPROFILESTRUCT *pProfile);
+INT32 FirstFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, INVNODE *tInv);
+INT32 AnyFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, INVNODE *tInv);
+INT32 SpecificFreePocket(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubHowMany, UINT32 usClass);
 
 // callbacks
 void BtnIMPConfirmNo( GUI_BUTTON *btn,INT32 reason );
@@ -406,7 +424,108 @@
 
 #define PROFILE_HAS_SKILL_TRAIT( p, t ) ((p->bSkillTrait == t) || (p->bSkillTrait2 == t))
 
+//CHRISL: New function to handle proper distribution of starting gear
+void DistributeInitialGear(MERCPROFILESTRUCT *pProfile)
+{
+	INVNODE			tInv[NUM_INV_SLOTS];
+	int				i, j, number;
+	UINT8			count = 0, length;
+	vector<int>		iOrder;
+	INT32			iSlot;
+	BOOLEAN			iSet = FALSE;
 
+	// First move profile information to temporary storage
+	for(i=0; i<NUM_INV_SLOTS; i++)
+	{
+		if(pProfile->inv[i] != NOTHING)
+		{
+			tInv[count].inv = pProfile->inv[i];
+			tInv[count].iSize = Item[pProfile->inv[i]].ItemSize;
+			tInv[count].iClass = Item[pProfile->inv[i]].usItemClass;
+			tInv[count].iStatus = (pProfile->bInvStatus[i] > 0) ? pProfile->bInvStatus[i] : 100;
+			tInv[count].iNumber = (pProfile->bInvNumber[i] == 0) ? 1 :pProfile->bInvNumber[i];
+			pProfile->inv[i] = 0;
+			pProfile->bInvStatus[i] = 0;
+			pProfile->bInvNumber[i] = 0;
+			count++;
+		}
+	}
+
+	length = count;
+	count = 0;
+	// Next sort list by size
+	for(j=34; j>=0; j--)
+	{
+		for(i=0; i<length; i++)
+		{
+			if(tInv[i].iSize == j)
+			{
+				int *filler = new int;
+				iOrder.push_back(*filler);
+				iOrder[count] = i;
+				count++;
+			}
+		}
+	}
+
+	// Last, go through the temp data and put items into appropriate pockets
+	// Start by putting items into specific pockets
+	for(i=0; i<count; i++)
+	{
+		iSlot = SpecificFreePocket(pProfile, tInv[iOrder[i]].inv, tInv[iOrder[i]].iNumber, tInv[iOrder[i]].iClass);
+		if(iSlot != -1)
+		{
+			MakeProfileInvItemThisSlot(pProfile, iSlot, tInv[iOrder[i]].inv, tInv[iOrder[i]].iStatus, tInv[iOrder[i]].iNumber);
+			iOrder[i]=-1;
+		}
+	}
+	// Next, put anything that isn't an attachment into a pocket
+	for(i=0; i<count; i++)
+	{
+		if(iOrder[i]!=-1)
+		{
+			// skip if this item is an attachment
+			if(Item[tInv[iOrder[i]].inv].attachment)
+				continue;
+			iSet = FALSE;
+			number = tInv[iOrder[i]].iNumber;
+			tInv[iOrder[i]].iNumber = 1;
+			for(int j=0; j<number; j++)
+			{
+				iSlot = FirstFreeBigEnoughPocket (pProfile, &tInv[iOrder[i]]);
+				if(iSlot != -1)
+				{
+					MakeProfileInvItemThisSlot(pProfile, iSlot, tInv[iOrder[i]].inv, tInv[iOrder[i]].iStatus, tInv[iOrder[i]].iNumber);
+					iSet = TRUE;
+				}
+			}
+			if(iSet)
+				iOrder[i]=-1;
+		}
+	}
+	// finish by putting anything that's left into any pocket, including inactive pockets
+	for(i=0; i<count; i++)
+	{
+		if(iOrder[i]!=-1)
+		{
+			iSet = FALSE;
+			number = tInv[iOrder[i]].iNumber;
+			tInv[iOrder[i]].iNumber = 1;
+			for(int j=0; j<number; j++)
+			{
+				iSlot = AnyFreeBigEnoughPocket (pProfile, &tInv[iOrder[i]]);
+				if(iSlot != -1)
+				{
+					MakeProfileInvItemThisSlot(pProfile, iSlot, tInv[iOrder[i]].inv, tInv[iOrder[i]].iStatus, tInv[iOrder[i]].iNumber);
+					iSet = TRUE;
+				}
+			}
+			if(iSet)
+				iOrder[i] = -1;
+		}
+	}
+}
+
 void GiveItemsToPC( UINT8 ubProfileId )
 {
 	MERCPROFILESTRUCT *pProfile;
@@ -591,14 +710,30 @@
 	{
 		GiveIMPRandomItems(pProfile,IMP_THIEF);
 	}
+
+	// CHRISL: Now that all items have been issued, distribute them into appropriate pockets, starting with the largest items
+	DistributeInitialGear(pProfile);
 }
 
 
 void MakeProfileInvItemAnySlot(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubStatus, UINT8 ubHowMany)
 {
-	INT32 iSlot;
+	INT32 iSlot=-1;
 
-	iSlot = FirstFreeBigEnoughPocket(pProfile, usItem, ubHowMany);
+	if(!gGameOptions.ubInventorySystem)
+		iSlot = FirstFreeBigEnoughPocket(pProfile, usItem, ubHowMany);
+	else
+	{
+		// CHRISL: Alter the placement of initial equipment to come last.  At this stage, just add items, one pocket at a time
+		for(int i=0; i<NUM_INV_SLOTS; i++)
+		{
+			if(pProfile->inv[i] == NOTHING)
+			{
+				iSlot = i;
+				break;
+			}
+		}
+	}
 
 	if (iSlot == -1)
 	{
@@ -619,6 +754,258 @@
 }
 
 
+// CHRISL: New function to move initial gear into LBE pockets when LBE items are given during creation
+void RedistributeStartingItems(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 sPocket)
+{
+	UINT16	lbeIndex;
+	UINT8	lbeClass, iSize;
+	UINT16	inv[NUM_INV_SLOTS], istatus[NUM_INV_SLOTS], inumber[NUM_INV_SLOTS];
+
+	lbeIndex = Item[usItem].ubClassIndex;
+	lbeClass = LoadBearingEquipment[lbeIndex].lbeClass;
+
+	// Move non-worn items into temporary storage
+	for(int i=0; i<NUM_INV_SLOTS; i++)
+	{
+		if(i>=BODYPOSFINAL)
+		{
+			inv[i] = pProfile->inv[i];
+			istatus[i] = pProfile->bInvStatus[i];
+			inumber[i] = pProfile->bInvNumber[i];
+			pProfile->inv[i] = 0;
+			pProfile->bInvStatus[i] = 0;
+			pProfile->bInvNumber[i] = 0;
+		}
+		else
+		{
+			switch (i)
+			{
+				case HANDPOS:
+				case SECONDHANDPOS:
+					inv[i] = pProfile->inv[i];
+					istatus[i] = pProfile->bInvStatus[i];
+					inumber[i] = pProfile->bInvNumber[i];
+					pProfile->inv[i] = 0;
+					pProfile->bInvStatus[i] = 0;
+					pProfile->bInvNumber[i] = 0;
+					break;
+				default:
+					inv[i] = 0;
+					istatus[i] = 0;
+					inumber[i] = 0;
+					break;
+			}
+		}
+	}
+
+	// Redistribute stored items with the assumption of the new LBE item
+	for(int i=0; i<NUM_INV_SLOTS; i++)
+	{
+		if(inv[i] != NONE)
+		{
+			iSize = Item[inv[i]].ItemSize;
+			for(int j=0; j<NUM_INV_SLOTS; j++)
+			{
+				if(icLBE[j] == sPocket && pProfile->inv[j] == NONE && LBEPocketType[LoadBearingEquipment[lbeIndex].lbePocketIndex[icPocket[j]]].ItemCapacityPerSize[iSize] != NONE)
+				{
+					pProfile->inv[j] = inv[i];
+					pProfile->bInvStatus[j] = istatus[i];
+					pProfile->bInvNumber[j] = inumber[i];
+					inv[i] = istatus[i] = inumber[i] = 0;
+					break;
+				}
+			}
+			pProfile->inv[i] = inv[i];
+			pProfile->bInvStatus[i] = istatus[i];
+			pProfile->bInvNumber[i] = inumber[i];
+			inv[i] = istatus[i] = inumber[i] = 0;
+		}
+	}
+}
+
+// CHRISL: New function to work with LBE pockets
+INT32 SpecificFreePocket(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubHowMany, UINT32 usClass)
+{
+	UINT8	lbePocket;
+
+	if (ubHowMany == 1)
+	{
+		switch (usClass)
+		{
+			case IC_LBEGEAR:
+				if(pProfile->inv[VESTPOCKPOS]==NONE && LoadBearingEquipment[Item[usItem].ubClassIndex].lbeClass==VEST_PACK)
+					return VESTPOCKPOS;
+				if(pProfile->inv[LTHIGHPOCKPOS]==NONE && LoadBearingEquipment[Item[usItem].ubClassIndex].lbeClass==THIGH_PACK)
+					return LTHIGHPOCKPOS;
+				if(pProfile->inv[RTHIGHPOCKPOS]==NONE && LoadBearingEquipment[Item[usItem].ubClassIndex].lbeClass==THIGH_PACK)
+					return RTHIGHPOCKPOS;
+				if(LoadBearingEquipment[Item[usItem].ubClassIndex].lbeClass==COMBAT_PACK)
+				{
+					if(pProfile->inv[CPACKPOCKPOS]==NONE)
+					{
+						if(LoadBearingEquipment[Item[usItem].ubClassIndex].lbeCombo!=0)
+						{
+							if((pProfile->inv[BPACKPOCKPOS]!=NONE && LoadBearingEquipment[Item[pProfile->inv[BPACKPOCKPOS]].ubClassIndex].lbeCombo==LoadBearingEquipment[Item[usItem].ubClassIndex].lbeCombo) || pProfile->inv[BPACKPOCKPOS]==NONE)
+								return CPACKPOCKPOS;
+						}
+						else if(pProfile->inv[BPACKPOCKPOS]==NONE)
+							return CPACKPOCKPOS;
+					}
+				}
+				if(LoadBearingEquipment[Item[usItem].ubClassIndex].lbeClass==BACKPACK)
+				{
+					if(pProfile->inv[BPACKPOCKPOS]==NONE)
+					{
+						if(LoadBearingEquipment[Item[usItem].ubClassIndex].lbeCombo!=0)
+						{
+							if((pProfile->inv[CPACKPOCKPOS]!=NONE && LoadBearingEquipment[Item[pProfile->inv[CPACKPOCKPOS]].ubClassIndex].lbeCombo==LoadBearingEquipment[Item[usItem].ubClassIndex].lbeCombo) || pProfile->inv[CPACKPOCKPOS]==NONE)
+								return BPACKPOCKPOS;
+						}
+						else if(pProfile->inv[CPACKPOCKPOS]==NONE)
+							return BPACKPOCKPOS;
+					}
+				}
+				break;
+			case IC_ARMOUR:
+				if ( pProfile->inv[HELMETPOS] == NONE && Armour[Item[usItem].ubClassIndex].ubArmourClass == ARMOURCLASS_HELMET )
+					return HELMETPOS;
+				if ( pProfile->inv[VESTPOS] == NONE && Armour[Item[usItem].ubClassIndex].ubArmourClass == ARMOURCLASS_VEST )
+					return VESTPOS;
+				if ( pProfile->inv[LEGPOS] == NONE && Armour[Item[usItem].ubClassIndex].ubArmourClass == ARMOURCLASS_LEGGINGS && !(Item[usItem].attachment))
+					return LEGPOS;
+				break;
+			case IC_BLADE:
+				if ( pProfile->inv[KNIFEPOCKPOS] == NONE)
+					return KNIFEPOCKPOS;
+				break;
+			case IC_BOMB:
+				for(int i=BODYPOSFINAL; i<NUM_INV_SLOTS; i++)
+				{
+					if(LoadBearingEquipment[Item[pProfile->inv[icLBE[i]]].ubClassIndex].lbePocketIndex[icPocket[i]]==7)	// TNT Pocket
+						if(pProfile->inv[i] == NONE)
+							return i;
+				}
+				break;
+			case IC_GRENADE:
+				for(int i=BODYPOSFINAL; i<NUM_INV_SLOTS; i++)
+				{
+					if(pProfile->inv[i]==NONE && Item[usItem].ItemSize==16 && LoadBearingEquipment[Item[pProfile->inv[icLBE[i]]].ubClassIndex].lbePocketIndex[icPocket[i]]==12)	// Rifle Grenade
+						return i;
+					else if(pProfile->inv[i]==NONE && LoadBearingEquipment[Item[pProfile->inv[icLBE[i]]].ubClassIndex].lbePocketIndex[icPocket[i]]==13)	// Grenade
+						return i;
+				}
+				break;
+			case IC_GUN:
+				if ( pProfile->inv[HANDPOS] == NONE )
+					return HANDPOS;
+				if ( pProfile->inv[SECONDHANDPOS] == NONE && !(Item[pProfile->inv[HANDPOS]].twohanded))
+					return SECONDHANDPOS;
+				if(gGameOptions.ubInventorySystem)
+					if ( pProfile->inv[GUNSLINGPOCKPOS] == NONE && pProfile->inv[BPACKPOCKPOS] == NONE && LBEPocketType[1].ItemCapacityPerSize[Item[usItem].ItemSize]!=0)
+						return GUNSLINGPOCKPOS;
+				for(int i=BODYPOSFINAL; i<NUM_INV_SLOTS; i++)
+				{
+					lbePocket = LoadBearingEquipment[Item[pProfile->inv[icLBE[i]]].ubClassIndex].lbePocketIndex[icPocket[i]];
+					if(pProfile->inv[i]==NONE && (lbePocket==6 || lbePocket==10) && LBEPocketType[lbePocket].ItemCapacityPerSize[Item[usItem].ItemSize]!=0)
+						return i;
+				}
+				break;
+			case IC_FACE:
+				if ( pProfile->inv[HEAD1POS] == NONE && CompatibleFaceItem(usItem,pProfile->inv[HEAD2POS]) )
+					return HEAD1POS;
+				if ( pProfile->inv[HEAD2POS] == NONE && CompatibleFaceItem(usItem,pProfile->inv[HEAD1POS]) )
+					return HEAD2POS;
+				break;
+			default:
+				break;
+		}
+	}
+	return(-1);
+}
+
+//INT32 FirstFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubHowMany, UINT32 usClass)
+INT32 FirstFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, INVNODE *tInv)
+{
+	UINT32	uiPos, iClass;
+	UINT16	iSize, pDefault, lbeCap, usItem, pRestrict;
+	UINT8	startPos, endPos;
+
+	usItem = tInv->inv;
+	iSize = Item[usItem].ItemSize;
+	iClass = Item[usItem].usItemClass;
+	for(int i=0; i<3; i++)
+	{
+		if(i==0){
+			startPos = MEDPOCKFINAL;
+			endPos = NUM_INV_SLOTS;
+		}
+		else if (i==1){
+			startPos = BIGPOCKFINAL;
+			endPos = MEDPOCKFINAL;
+		}
+		else{
+			startPos = BODYPOSFINAL;
+			endPos = BIGPOCKFINAL;
+		}
+		for(uiPos = startPos; uiPos<endPos; uiPos++)
+		{
+			if(icLBE[uiPos] == ITEM_NOT_FOUND)
+				continue;
+			pDefault = (pProfile->inv[icLBE[uiPos]] == NONE) ? icClass[uiPos] : Item[pProfile->inv[icLBE[uiPos]]].ubClassIndex;
+			lbeCap = LBEPocketType[LoadBearingEquipment[pDefault].lbePocketIndex[icPocket[uiPos]]].ItemCapacityPerSize[iSize];
+			pRestrict = LBEPocketType[LoadBearingEquipment[pDefault].lbePocketIndex[icPocket[uiPos]]].pRestriction;
+			if(lbeCap>0 && (pRestrict == 0 || pRestrict == iClass))
+			{
+				if(pProfile->inv[uiPos] == NONE)
+					return(uiPos);
+				else if(pProfile->inv[uiPos] == usItem && lbeCap >= (tInv->iNumber+1))
+				{
+					tInv->iNumber++;
+					return(uiPos);
+				}
+			}
+		}
+	}
+	return(-1);
+}
+
+// CHRISL: This function will place objects anywhere it can.  It tries to use active pockets but will use any pocket as a last resort
+INT32 AnyFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, INVNODE *tInv)
+{
+	INT32		iSlot;
+	UINT32		uiPos;
+	UINT16		iSize, lbeCap, usItem;
+
+	iSlot = FirstFreeBigEnoughPocket (pProfile, tInv);
+	if(iSlot != -1)
+		return(iSlot);
+	else
+	{
+		usItem = tInv->inv;
+		for(uiPos = BODYPOSFINAL; uiPos < NUM_INV_SLOTS; uiPos ++)
+		{
+			iSize = Item[usItem].ubPerPocket;
+			lbeCap = iSize * 2;
+			if(uiPos >= MEDPOCKFINAL && iSize > 0)
+				return(-1);
+			else
+			{
+				if(pProfile->inv[uiPos] == NONE)
+					return(uiPos);
+				else if(pProfile->inv[uiPos] == usItem)
+				{
+					if((uiPos < BIGPOCKFINAL && iSize >= (tInv->iNumber+1)) || (uiPos >= BIGPOCKFINAL && lbeCap >= (tInv->iNumber+1)))
+					{
+					tInv->iNumber++;
+					return(uiPos);
+					}
+				}
+			}
+		}
+	}
+	return(-1);
+}
+
 INT32 FirstFreeBigEnoughPocket(MERCPROFILESTRUCT *pProfile, UINT16 usItem, UINT8 ubHowMany)
 {
 	UINT32 uiPos;
@@ -723,11 +1110,15 @@
 	// write out the profile itself
         // WDS - Clean up inventory handling
 	gMercProfiles[ iProfileId ].CopyNewInventoryToOld();
-	if (!FileWrite(hFile, &gMercProfiles[ iProfileId ], SIZEOF_MERCPROFILESTRUCT_POD, &uiBytesWritten))
-	{
-		if (hFile)
-			FileClose(hFile);
-		return;
+	if (FileWrite(hFile, &gMercProfiles[ iProfileId ], SIZEOF_MERCPROFILESTRUCT_POD, &uiBytesWritten)) {
+
+		// Write all the vectors from the soldier into the file
+		if (SaveVector (hFile, gMercProfiles[ iProfileId ].inv)) {
+			if (SaveVector (hFile, gMercProfiles[ iProfileId ].bInvStatus)) {
+				if (SaveVector (hFile, gMercProfiles[ iProfileId ].bInvNumber)) {
+				}
+			}
+		}
 	}
 
 	// close file
@@ -803,6 +1194,12 @@
 		}
 		gMercProfiles[ iProfileId ].CopyOldInventoryToNew();
 
+		if (guiSavedGameVersion >= SAVE_GAMES_HAVE_NEW_INVENTORY_VECTORS) {
+			if (!LoadVector (hFile, gMercProfiles[ iProfileId ].inv)) { return FALSE; }
+			if (!LoadVector (hFile, gMercProfiles[ iProfileId ].bInvStatus)) { return FALSE; }
+			if (!LoadVector (hFile, gMercProfiles[ iProfileId ].bInvNumber)) { return FALSE; }
+		}
+
 		// close file
 		FileClose(hFile);
 		
@@ -956,3 +1353,4 @@
 
 }
 
+
Index: SaveLoadGame.cpp
===================================================================
--- SaveLoadGame.cpp	(revision 1300)
+++ SaveLoadGame.cpp	(working copy)
@@ -419,6 +419,10 @@
 BOOLEAN		SaveSoldierStructure( HWFILE hFile );
 BOOLEAN		LoadSoldierStructure( HWFILE hFile );
 
+// CHRISL: New functions to save and load LBENODE data
+BOOLEAN SaveLBENODEToSaveGameFile( HWFILE hFile );
+BOOLEAN LoadLBENODEToSaveGameFile( HWFILE hFile );
+
 //BOOLEAN		SavePtrInfo( PTR *pData, UINT32 uiSizeOfObject, HWFILE hFile );
 //BOOLEAN		LoadPtrInfo( PTR *pData, UINT32 uiSizeOfObject, HWFILE hFile );
 
@@ -775,6 +779,9 @@
 
 	SaveGameHeader.uiRandom = Random( RAND_MAX );
 
+	// CHRISL: We need to know what inventory system we're using early on
+	SaveGameHeader.ubInventorySystem = gGameOptions.ubInventorySystem;
+
 	//
 	// Save the Save Game header file
 	//
@@ -1343,6 +1350,15 @@
 	SaveGameFilePosition( FileGetPos( hFile ), "New way of saving Bobby R mailorders" );
 	#endif
 
+	//CHRISL: Save LBENODE information
+	if( !SaveLBENODEToSaveGameFile( hFile ) )
+	{
+		goto FAILED_TO_SAVE;
+	}
+	#ifdef JA2BETAVERSION
+	SaveGameFilePosition( FileGetPos( hFile ), "LBENODE Data" );
+	#endif
+
 	
 	//sss
 
@@ -1557,6 +1573,25 @@
 
 	guiJA2EncryptionSet = CalcJA2EncryptionSet( &SaveGameHeader );
 
+	// CHRISL: We need to know what inventory system we're using early on
+	if(SaveGameHeader.uiSavedGameVersion < SAVE_GAMES_HAVE_NEW_INVENTORY_VECTORS)
+		SaveGameHeader.ubInventorySystem = 0;
+	gGameOptions.ubInventorySystem = SaveGameHeader.ubInventorySystem;
+	if(gGameOptions.ubInventorySystem)
+	{
+		InitInventoryNew();
+		InitNewInventorySystem();
+		InitializeSMPanelCoordsNew();
+		InitializeInvPanelCoordsNew();
+	}
+	else
+	{
+		InitInventoryOld();
+		InitOldInventorySystem();
+		InitializeSMPanelCoordsOld();
+		InitializeInvPanelCoordsOld();
+	}
+
 	guiBrokenSaveGameVersion = SaveGameHeader.uiSavedGameVersion;
 
 	//if the player is loading up an older version of the game, and the person DOESNT have the cheats on, 
@@ -2632,6 +2667,20 @@
 	}
 
 
+	//CHRISL: Load LBENODE information
+	if( SaveGameHeader.uiSavedGameVersion >= 102 )
+	{
+		if ( !LoadLBENODEToSaveGameFile( hFile ) )
+		{
+			FileClose( hFile );
+			guiSaveGameVersion=0;
+			return( FALSE );
+		}
+		#ifdef JA2BETAVERSION
+			LoadGameFilePosition( FileGetPos( hFile ), "LBENODE Data" );
+		#endif
+	}
+
 	///lll
 
 
@@ -2951,6 +3000,12 @@
 		{
 			return(FALSE);
 		}
+
+		// WDS Inventory cleanup, phase 2
+		// Write all the vectors from the soldier into the file
+		if (!SaveVector (hFile, gMercProfiles[ cnt ].inv)) { return FALSE; }
+		if (!SaveVector (hFile, gMercProfiles[ cnt ].bInvStatus)) { return FALSE; }
+		if (!SaveVector (hFile, gMercProfiles[ cnt ].bInvNumber)) { return FALSE; }
 	}
 
 	return( TRUE );
@@ -2980,7 +3035,16 @@
 		{
 			return(FALSE);
 		}
-		gMercProfiles[ cnt ].CopyOldInventoryToNew();
+
+		gMercProfiles[cnt].CopyOldInventoryToNew();
+
+		// WDS Inventory cleanup, phase 2
+		if (guiSaveGameVersion >= SAVE_GAMES_HAVE_NEW_INVENTORY_VECTORS) {
+			if (!LoadVector (hFile, gMercProfiles[ cnt ].inv)) { return FALSE; }
+			if (!LoadVector (hFile, gMercProfiles[ cnt ].bInvStatus)) { return FALSE; }
+			if (!LoadVector (hFile, gMercProfiles[ cnt ].bInvNumber)) { return FALSE; }
+		}
+
 		if ( gMercProfiles[ cnt ].uiProfileChecksum != ProfileChecksum( &(gMercProfiles[ cnt ]) ) )
 		{
 			return( FALSE );
@@ -2990,10 +3054,88 @@
 	return( TRUE );
 }
 
+// CHRISL: New function to save/load LBENODE data
+BOOLEAN LoadLBENODEToSaveGameFile( HWFILE hFile )
+{
+	UINT16	cnt;
+	UINT32	uiNumBytesRead=0;
+	UINT32	uiSaveSize = sizeof( LBENODE ); //SIZEOF_SOLDIERTYPE;
 
+	if ( guiSaveGameVersion < 87 )
+	{
+		JA2EncryptedFileRead( hFile, &LBEptrNum, sizeof(UINT16), &uiNumBytesRead );
+	}
+	else
+	{
+		NewJA2EncryptedFileRead( hFile, &LBEptrNum, sizeof(UINT16), &uiNumBytesRead );
+	}
+	if( uiNumBytesRead != sizeof(UINT16) )
+	{
+		//return(FALSE);
+		LBEptrNum = 0;
+	}
 
+	for(cnt=0; cnt<LBEptrNum; cnt++)
+	{
+		if ( guiSaveGameVersion < 87 )
+		{
+			LBEptr.push_back(LBENODE());
+			JA2EncryptedFileRead( hFile, &LBEptr[cnt], uiSaveSize, &uiNumBytesRead );
+		}
+		else
+		{
+			LBEptr.push_back(LBENODE());
+			NewJA2EncryptedFileRead( hFile, &LBEptr[cnt], uiSaveSize, &uiNumBytesRead );
+		}
+		if( uiNumBytesRead != uiSaveSize )
+		{
+			return(FALSE);
+		}
+	}
 
+	return( TRUE );
+}
+BOOLEAN SaveLBENODEToSaveGameFile( HWFILE hFile )
+{
+	UINT16	cnt;
+	UINT32	uiNumBytesWritten=0;
+	UINT32	uiSaveSize = sizeof( LBENODE ); //SIZEOF_SOLDIERTYPE;
 
+	if ( guiSavedGameVersion < 87 )
+	{
+		JA2EncryptedFileWrite( hFile, &LBEptrNum, sizeof(UINT16), &uiNumBytesWritten );
+	}
+	else
+	{
+		NewJA2EncryptedFileWrite( hFile, &LBEptrNum, sizeof(UINT16), &uiNumBytesWritten );
+	}
+	if( uiNumBytesWritten != sizeof(UINT16) )
+	{
+		return(FALSE);
+	}
+
+	for(cnt=0; cnt<LBEptr.size(); cnt++)
+	{
+		LBEptr[ cnt ].uiNodeChecksum = LBENODEChecksum( &(LBEptr[ cnt ]) );
+		if ( guiSavedGameVersion < 87 )
+		{
+			JA2EncryptedFileWrite( hFile, &LBEptr[cnt], uiSaveSize, &uiNumBytesWritten );
+		}
+		else
+		{
+			NewJA2EncryptedFileWrite( hFile, &LBEptr[cnt], uiSaveSize, &uiNumBytesWritten );
+		}
+		if( uiNumBytesWritten != uiSaveSize )
+		{
+			return(FALSE);
+		}
+	}
+
+	return( TRUE );
+}
+
+
+
 		//Not saving any of these in the soldier struct
 		
 		//	struct TAG_level_node				*pLevelNode;
@@ -3109,6 +3251,12 @@
 					return(FALSE);
 				}
 			}
+
+			// WDS Inventory cleanup, phase 2
+			// Write all the vectors from the soldier into the file
+			if (!SaveVector (hFile, Menptr[cnt].inv.inv)) { return FALSE; }
+			if (!SaveVector (hFile, Menptr[cnt].bNewItemCount)) { return FALSE; }
+			if (!SaveVector (hFile, Menptr[cnt].bNewItemCycleCount)) { return FALSE; }
 		}
 	}
 
@@ -3181,11 +3329,12 @@
 			{
 				return(FALSE);
 			}
+			// CHRISL: We don't want to generate the checksum until after vector inventory is loaded
 			// check checksum
-			if ( MercChecksum( &SavedSoldierInfo ) != SavedSoldierInfo.uiMercChecksum )
-			{
-				return( FALSE );
-			}
+//			if ( MercChecksum( &SavedSoldierInfo ) != SavedSoldierInfo.uiMercChecksum )
+//			{
+//				return( FALSE );
+//			}
 
 			//Make sure all the pointer references are NULL'ed out.  
 			SavedSoldierInfo.pTempObject	 = NULL;
@@ -3295,6 +3444,18 @@
 				Menptr[ cnt ].ubNextToPreviousAttackerID = NOBODY;
 			}
 
+			// WDS Inventory cleanup, phase 2
+			if (guiSaveGameVersion >= SAVE_GAMES_HAVE_NEW_INVENTORY_VECTORS) {
+				if (!LoadVector (hFile, Menptr[cnt].inv.inv)) { return FALSE; }
+				if (!LoadVector (hFile, Menptr[cnt].bNewItemCount)) { return FALSE; }
+				if (!LoadVector (hFile, Menptr[cnt].bNewItemCycleCount)) { return FALSE; }
+			}
+
+			// check checksum
+			if ( MercChecksum( &Menptr[cnt] ) != SavedSoldierInfo.uiMercChecksum )
+			{
+				return( FALSE );
+			}
 		}
 	}
 
Index: SaveLoadGame.h
===================================================================
--- SaveLoadGame.h	(revision 1300)
+++ SaveLoadGame.h	(working copy)
@@ -50,8 +50,10 @@
 
 	UINT32	uiRandom;
 
-	UINT8		ubFiller[110];
+	UINT8	ubInventorySystem;
 
+	UINT8		ubFiller[109];
+
 } SAVED_GAME_HEADER;
 
 
Index: Standard Gaming Platform/FileMan.h
===================================================================
--- Standard Gaming Platform/FileMan.h	(revision 1299)
+++ Standard Gaming Platform/FileMan.h	(working copy)
@@ -24,7 +24,11 @@
 #include "Windows.h"
 
 #include "FileCat.h"
+#include "TopicOps.h"
+#include "Debug.h"
 
+#include <vector>
+
 //**************************************************************************
 //
 //				Defines
@@ -190,6 +194,78 @@
 //Gets the free hard drive space from the drive letter passed in.  It has to be the root dir.  ( eg. c:\ )
 UINT32		GetFreeSpaceOnHardDrive( STR pzDriveLetter );
 
+
+
+// WDS Inventory cleanup, phase 2
+//
+// SaveVector will save any vector into a file.
+// Note!  The vector is assumed to be POD data (plain 'ol data, i.e., no complex classes)
+//
+template<class _Ty>
+BOOLEAN SaveVector(HWFILE& hFile, std::vector<_Ty>& vectorToSave) {
+	UINT32 uiNumBytesWritten = 0;
+
+	// First write how many elements there are in the vector into the file
+	UINT32 uiSaveSize = sizeof(UINT32);
+	UINT32 vectorSize = vectorToSave.size();
+	FileWrite( hFile, &vectorSize, uiSaveSize, &uiNumBytesWritten );
+	if( uiNumBytesWritten != uiSaveSize ) {
+		DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("FAILED to Write Vector to File (1)" ) );
+		return FALSE;
+	}
+
+	// Second write each of the elements in the vector into the file
+	uiSaveSize = sizeof(_Ty);
+	for (vector<_Ty>::iterator current = vectorToSave.begin(); current != vectorToSave.end(); ++current) {
+		FileWrite( hFile, &*current, uiSaveSize, &uiNumBytesWritten );
+		if( uiNumBytesWritten != uiSaveSize ) {
+			DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("FAILED to Write Vector to File (2)" ) );
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+//
+// LoadVector will save any vector into a file.
+// Note!  The vector is assumed to be POD data (plain 'ol data, i.e., no complex classes).
+// If the vector is not empty whatever current elements there are will be thrown away.
+//
+template<class _Ty>
+BOOLEAN LoadVector(HWFILE& hFile, std::vector<_Ty>& vectorToLoad) {
+	UINT32 uiNumBytesRead = 0;
+
+	// First read how many elements there will be in the vector from the file
+	UINT32 uiSaveSize = sizeof(UINT32);
+	UINT32 vectorSize;
+	FileRead( hFile, &vectorSize, uiSaveSize, &uiNumBytesRead );
+	if( uiNumBytesRead != uiSaveSize )
+	{
+		DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("FAILED to Read Vector from File (1)" ) );
+		return FALSE;
+	}
+
+	// Empty the vector of any current elements
+	vectorToLoad.clear();
+//	vectorToLoad.resize(vectorSize);  // Not needed?
+
+	// Read each elements from the file and add it to the end of the vector
+	uiSaveSize = sizeof(_Ty);
+	for (unsigned cnt=0; cnt < vectorSize; ++cnt) {
+		_Ty local;
+		FileRead( hFile, &local, uiSaveSize, &uiNumBytesRead );
+		if( uiNumBytesRead != uiSaveSize )
+		{
+			DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("FAILED to Read Vector from File (2)" ) );
+			return FALSE;
+		}
+		vectorToLoad.push_back(local);
+	}
+
+	return TRUE;
+}
+
 /*
 #ifdef __cplusplus
 }
Index: Strategic/Assignments.cpp
===================================================================
--- Strategic/Assignments.cpp	(revision 1299)
+++ Strategic/Assignments.cpp	(working copy)
@@ -94,28 +94,37 @@
 };
 
 
+/* CHRISL: Adjusted enumerations to allow for seperation of the three different pocket types in the new 
+inventory system. */
 enum {
 	REPAIR_HANDS_AND_ARMOR = 0,
 	REPAIR_HEADGEAR,
-	REPAIR_POCKETS,
+	REPAIR_BIG_POCKETS,
+	REPAIR_MED_POCKETS,
+	REPAIR_SML_POCKETS,
 	NUM_REPAIR_PASS_TYPES,
 };
 
-#define FINAL_REPAIR_PASS			REPAIR_POCKETS
+#define FINAL_REPAIR_PASS			REPAIR_SML_POCKETS
 
 
+/* CHRISL: bSlot[xx] array declaration needs to reflect largest number of inventory locations.  New inventory
+system increses possible locations from 12 to 30. Also added a new field so we can set number of choices based
+on game options. */
 typedef struct REPAIR_PASS_SLOTS_TYPE
 {
-	UINT8		ubChoices;						// how many valid choices there are in this pass
-	INT8		bSlot[ 12 ];					// list of slots to be repaired in this pass
+	UINT8		ubChoices[2];						// how many valid choices there are in this pass
+	INT8		bSlot[ 30 ];					// list of slots to be repaired in this pass
 } REPAIR_PASS_SLOTS_TYPE;
 
-
+/* CHRISL:  Added new definitions introduced by the new inventory system.*/
 REPAIR_PASS_SLOTS_TYPE gRepairPassSlotList[ NUM_REPAIR_PASS_TYPES ] =
-{					// pass					# choices												slots repaired in this pass
-	{ /* hands and armor */			5,	HANDPOS, SECONDHANDPOS, VESTPOS, HELMETPOS, LEGPOS, -1, -1, -1, -1, -1, -1, -1 },
-	{ /* headgear */						2,	HEAD1POS, HEAD2POS, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
-	{ /* pockets */						 12,	BIGPOCK1POS, BIGPOCK2POS, BIGPOCK3POS, BIGPOCK4POS, SMALLPOCK1POS, SMALLPOCK2POS, SMALLPOCK3POS, SMALLPOCK4POS, SMALLPOCK5POS, SMALLPOCK6POS, SMALLPOCK7POS, SMALLPOCK8POS },
+{					// pass		# choices	# new choices		slots repaired in this pass
+	{ /* hands and armor */		5,			12,					HANDPOS, SECONDHANDPOS, VESTPOS, HELMETPOS, LEGPOS, VESTPOCKPOS, LTHIGHPOCKPOS, RTHIGHPOCKPOS, CPACKPOCKPOS, BPACKPOCKPOS, GUNSLINGPOCKPOS, KNIFEPOCKPOS, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+	{ /* headgear */			2,			2,					HEAD1POS, HEAD2POS, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+	{ /* big pockets */			4,			7,					BIGPOCK1POS, BIGPOCK2POS, BIGPOCK3POS, BIGPOCK4POS, BIGPOCK5POS, BIGPOCK6POS, BIGPOCK7POS, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+	{ /* med pockets */			0,			4,					MEDPOCK1POS, MEDPOCK2POS, MEDPOCK3POS, MEDPOCK4POS, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 
+	{ /* sml pockets */			8,			30,					SMALLPOCK1POS, SMALLPOCK2POS, SMALLPOCK3POS, SMALLPOCK4POS, SMALLPOCK5POS, SMALLPOCK6POS, SMALLPOCK7POS, SMALLPOCK8POS, SMALLPOCK9POS, SMALLPOCK10POS, SMALLPOCK11POS, SMALLPOCK12POS, SMALLPOCK13POS, SMALLPOCK14POS, SMALLPOCK15POS, SMALLPOCK16POS, SMALLPOCK17POS, SMALLPOCK18POS, SMALLPOCK19POS, SMALLPOCK20POS, SMALLPOCK21POS, SMALLPOCK22POS, SMALLPOCK23POS, SMALLPOCK24POS, SMALLPOCK25POS, SMALLPOCK26POS, SMALLPOCK27POS, SMALLPOCK28POS, SMALLPOCK29POS, SMALLPOCK30POS },
 };
 
 extern STR16 sRepairsDoneString[];
@@ -650,7 +659,8 @@
 	}
 
 	// find med kit
-	for (bPocket = HANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (bPocket = HANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 	{
 		// doctoring is allowed using either type of med kit (but first aid kit halves doctoring effectiveness)
 		if( IsMedicalKitItem( &( pSoldier -> inv[ bPocket ] ) ) )
@@ -756,7 +766,8 @@
 
 
 	// check for jams
-	for (bPocket = HELMETPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (bPocket = HELMETPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 	{
 		ubItemsInPocket = pSoldier -> inv[ bPocket ].ubNumberOfObjects;
 		// unjam any jammed weapons
@@ -772,7 +783,8 @@
 	}
 
 	// now check for items to repair
-	for( bPocket = HELMETPOS; bPocket <= SMALLPOCK8POS; bPocket++ )
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for( bPocket = HELMETPOS; bPocket < NUM_INV_SLOTS; bPocket++ )
 	{
 		pObj = &(pSoldier->inv[ bPocket ]);
 		
@@ -815,7 +827,8 @@
 			{
 				// okay, seems like a candidate!  Check if he has anything that needs unjamming or repairs
 
-				for ( bPocket = HANDPOS; bPocket <= SMALLPOCK8POS; bPocket++ )
+				// CHRISL: Changed to dynamically determine max inventory locations.
+				for ( bPocket = HANDPOS; bPocket < NUM_INV_SLOTS; bPocket++ )
 				{
 					// the object a weapon? and jammed?
 					if ( ( Item[ pOtherSoldier->inv[ bPocket ].usItem ].usItemClass == IC_GUN ) && ( pOtherSoldier->inv[ bPocket ].ItemData.Gun.bGunAmmoStatus < 0 ) )
@@ -2240,7 +2253,8 @@
 	UINT8 ubPocket;
 
 	// add up kit points
-	for (ubPocket=HANDPOS; ubPocket <= SMALLPOCK8POS; ubPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (ubPocket=HANDPOS; ubPocket < NUM_INV_SLOTS; ubPocket++)
 	{
 		if( Item[pSoldier -> inv[ ubPocket ].usItem].toolkit )
     {
@@ -2258,7 +2272,8 @@
 	UINT16 usKitpts=0;
 
 	// add up kit points of all medkits
-	for (ubPocket = HANDPOS; ubPocket <= SMALLPOCK8POS; ubPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (ubPocket = HANDPOS; ubPocket < NUM_INV_SLOTS; ubPocket++)
 	{
 		// NOTE: Here, we don't care whether these are MEDICAL BAGS or FIRST AID KITS!
     if ( IsMedicalKitItem( &( pSoldier -> inv[ ubPocket ] ) ) )
@@ -2680,7 +2695,8 @@
 
 		// go through doctor's pockets and heal, starting at with his in-hand item
 		// the healing pts are based on what type of medkit is in his hand, so we HAVE to start there first!
-		for (bPocket = HANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+		// CHRISL: Changed to dynamically determine max inventory locations.
+		for (bPocket = HANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 		{
 			bMedFactor = IsMedicalKitItem( &( pDoctor -> inv[ bPocket ] ) );
 			if ( bMedFactor > 0 )
@@ -2722,7 +2738,8 @@
 
 		// go through doctor's pockets and heal, starting at with his in-hand item
 		// the healing pts are based on what type of medkit is in his hand, so we HAVE to start there first!
-		for (bPocket = HANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+		// CHRISL: Changed to dynamically determine max inventory locations.
+		for (bPocket = HANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 		{
 			bMedFactor = IsMedicalKitItem( &( pDoctor -> inv[ bPocket ] ) );
 			if ( bMedFactor > 0 )
@@ -2973,7 +2990,8 @@
 
 	pPassList = &( gRepairPassSlotList[ ubPassType ] );
 
-	for ( bLoop = 0; bLoop < pPassList->ubChoices; bLoop++ )
+	// CHRISL:
+	for ( bLoop = 0; bLoop < pPassList->ubChoices[gGameOptions.ubInventorySystem]; bLoop++ )
 	{
 		bSlotToCheck = pPassList->bSlot[ bLoop ];
 		Assert( bSlotToCheck != -1 );
@@ -3211,7 +3229,8 @@
 			if ( bLoop == 0 )
 			{
 				bLoopStart = SECONDHANDPOS;
-				bLoopEnd = SMALLPOCK8POS;
+				// CHRISL: Changed to dynamically determine max inventory locations.
+				bLoopEnd = (NUM_INV_SLOTS - 1);
 			}
 			else
 			{
@@ -5487,7 +5506,8 @@
 	if( !Item[pSoldier -> inv[ HANDPOS].usItem].toolkit )
 	{
 		// run through rest of inventory looking for toolkits, swap the first one into hand if found
-		for (bPocket = SECONDHANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+		// CHRISL: Changed to dynamically determine max inventory locations.
+		for (bPocket = SECONDHANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 		{
 			if( Item[pSoldier -> inv[ bPocket ].usItem].toolkit )
 			{
@@ -5514,7 +5534,8 @@
 	}
 
 	// run through rest of inventory looking 1st for MEDICAL BAGS, swap the first one into hand if found
-	for (bPocket = SECONDHANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (bPocket = SECONDHANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 	{
 		if ( Item[pSoldier -> inv[ bPocket ].usItem].medicalkit )
 		{
@@ -5531,12 +5552,14 @@
 	}
 
 	// run through rest of inventory looking 1st for MEDICAL BAGS, swap the first one into hand if found
-	for (bPocket = SECONDHANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (bPocket = SECONDHANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 	{
 		if ( Item[pSoldier -> inv[ bPocket ].usItem].firstaidkit )
 		{
 //			if( ( Item[ pSoldier -> inv[ HANDPOS ].usItem ].fFlags & IF_TWOHANDED_GUN ) && ( bPocket >= SMALLPOCK1POS ) )
-			if( ( Item[ pSoldier -> inv[ HANDPOS ].usItem ].twohanded  ) && ( bPocket >= SMALLPOCK1POS ) )
+			// CHRISL: This needs to start with the first "non-big" pocket.
+			if( ( Item[ pSoldier -> inv[ HANDPOS ].usItem ].twohanded  ) && ( bPocket >= MEDPOCK1POS ) )
 			{
 				// first move from hand to second hand
 				SwapObjs( &pSoldier -> inv[ HANDPOS ], &pSoldier -> inv[ SECONDHANDPOS ] );
@@ -11542,7 +11565,8 @@
 
 
 	// try to unjam everything before beginning any actual repairs.. successful unjamming costs 2 points per weapon
-	for (bPocket = HANDPOS; bPocket <= SMALLPOCK8POS; bPocket++)
+	// CHRISL: Changed to dynamically determine max inventory locations.
+	for (bPocket = HANDPOS; bPocket < NUM_INV_SLOTS; bPocket++)
 	{
 		// the object a weapon? and jammed?
 		if ( ( Item[ pOwnerSoldier->inv[ bPocket ].usItem ].usItemClass == IC_GUN ) && ( pOwnerSoldier->inv[ bPocket ].ItemData.Gun.bGunAmmoStatus < 0 ) )
@@ -11587,3 +11611,4 @@
  
 
 
+
Index: Strategic/Game Init.cpp
===================================================================
--- Strategic/Game Init.cpp	(revision 1299)
+++ Strategic/Game Init.cpp	(working copy)
@@ -60,6 +60,7 @@
 	#include "Air Raid.h"
 	#include "Interface.h"
 	#include "cheats.h"
+	#include "Interface Panels.h"
 #endif
 
 // Temp function
@@ -373,6 +374,24 @@
 	// Reset the selected soldier
 	gusSelectedSoldier = NOBODY;
 
+	// CHRISL: Init inventory
+	DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"InitNewGame: set initial inventory coords");
+	if( gubScreenCount == 0 )
+	{
+		if(gGameOptions.ubInventorySystem)
+		{
+			InitNewInventorySystem();
+			InitializeSMPanelCoordsNew();
+			InitializeInvPanelCoordsNew();
+		}
+		else
+		{
+			InitOldInventorySystem();
+			InitializeSMPanelCoordsOld();
+			InitializeInvPanelCoordsOld();
+		}
+	}
+
 	DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"InitNewGame: loading merc profiles");
 	if( gubScreenCount == 0 )
 	{
Index: Strategic/Hourly Update.cpp
===================================================================
--- Strategic/Hourly Update.cpp	(revision 1299)
+++ Strategic/Hourly Update.cpp	(working copy)
@@ -250,7 +250,8 @@
 						usCashAmount = Item[ ALCOHOL ].usPrice;
 						AddTransactionToPlayersBook ( TRANSFER_FUNDS_TO_MERC, pSoldier->ubProfile, GetWorldTotalMin() , -( usCashAmount ) );
 						// give Larry some booze and set slot etc values appropriately
-						bBoozeSlot = FindEmptySlotWithin( pSoldier, HANDPOS, SMALLPOCK8POS );
+						// CHRISL: Change final parameter to allow dynamic control of inventory slots
+						bBoozeSlot = FindEmptySlotWithin( pSoldier, HANDPOS, (NUM_INV_SLOTS-1) );
 						if ( bBoozeSlot != NO_SLOT )
 						{
 							// give Larry booze here
@@ -281,7 +282,8 @@
 					usCashAmount = Item[ ALCOHOL ].usPrice;
 					AddTransactionToPlayersBook ( TRANSFER_FUNDS_TO_MERC, pSoldier->ubProfile, GetWorldTotalMin() , -( usCashAmount ) );
 					// give Larry some booze and set slot etc values appropriately
-					bBoozeSlot = FindEmptySlotWithin( pSoldier, HANDPOS, SMALLPOCK8POS );
+					// CHRISL: Change final parameter to allow dynamic control of inventory slots
+					bBoozeSlot = FindEmptySlotWithin( pSoldier, HANDPOS, (NUM_INV_SLOTS-1) );
 					if ( bBoozeSlot != NO_SLOT )
 					{
 						// give Larry booze here
@@ -335,4 +337,4 @@
 			TacticalCharacterDialogueWithSpecialEvent( pSoldier, 0, DIALOGUE_SPECIAL_EVENT_CONTRACT_ENDING_NO_ASK_EQUIP, 0, 0 );
 		}
 	}
-}
\ No newline at end of file
+}
Index: Strategic/Map Screen Interface Bottom.cpp
===================================================================
--- Strategic/Map Screen Interface Bottom.cpp	(revision 1299)
+++ Strategic/Map Screen Interface Bottom.cpp	(working copy)
@@ -51,17 +51,23 @@
 	#include "SaveLoadScreen.h"
 #endif
 
+/* CHRISL: Adjusted settings to allow new Map_Screen_Bottom_800x600.sti to work.  This is needed if we
+want to have the new inventory panel not overlap the message text area. */
 #define MAP_BOTTOM_X							0
 #define MAP_BOTTOM_Y							(SCREEN_HEIGHT - 121)	//359
 
-#define MESSAGE_SCROLL_AREA_START_X				330
-#define MESSAGE_SCROLL_AREA_END_X				344
+//#define MESSAGE_SCROLL_AREA_START_X				(SCREEN_WIDTH - 534)	//330
+//#define MESSAGE_SCROLL_AREA_END_X				(SCREEN_WIDTH - 522)	//344
 #define MESSAGE_SCROLL_AREA_WIDTH				( MESSAGE_SCROLL_AREA_END_X - MESSAGE_SCROLL_AREA_START_X + 1 )
 
 #define MESSAGE_SCROLL_AREA_START_Y				(SCREEN_HEIGHT - 90)	//390
 #define MESSAGE_SCROLL_AREA_END_Y				(SCREEN_HEIGHT - 32)		//448
 #define MESSAGE_SCROLL_AREA_HEIGHT				( MESSAGE_SCROLL_AREA_END_Y - MESSAGE_SCROLL_AREA_START_Y + 1 )
 
+// CHRISL: Use these if we want scroll bar based on left edge of screen
+#define MESSAGE_SCROLL_AREA_START_X				330
+#define MESSAGE_SCROLL_AREA_END_X				344
+
 #define SLIDER_HEIGHT							11
 #define SLIDER_WIDTH							11
 
@@ -273,7 +279,10 @@
 }
 
 
-void RenderMapScreenInterfaceBottom( void )
+// Headrock: this function used to accept no arguments. It now accepts a Boolean so it can be forced to run
+// the whole process when we call it from other files. See also .h file!!!
+extern void BltCharInvPanel();
+void RenderMapScreenInterfaceBottom( BOOLEAN fForceMapscreenFullRender )
 {
 	// will render the map screen bottom interface
 	HVOBJECT hHandle;
@@ -282,7 +291,8 @@
 	fDisplayOverheadMap = FALSE;
 
 	// render whole panel
-	if( fMapScreenBottomDirty == TRUE )
+	// HEADROCK Changed this line to accept outside influence through the new boolean:
+	if ( fForceMapscreenFullRender == TRUE || fMapScreenBottomDirty == TRUE )
 	{
 		// get and blt panel
 	  GetVideoObject(&hHandle, guiMAPBOTTOMPANEL ); 
@@ -307,7 +317,7 @@
 		MarkButtonsDirty( );
 
 		// invalidate region
-		RestoreExternBackgroundRect( MAP_BOTTOM_X, MAP_BOTTOM_Y, SCREEN_WIDTH, SCREEN_HEIGHT - MAP_BOTTOM_Y );
+		RestoreExternBackgroundRect( MAP_BOTTOM_X, MAP_BOTTOM_Y, SCREEN_WIDTH - MAP_BOTTOM_X, SCREEN_HEIGHT - MAP_BOTTOM_Y );
 
 		// re render radar map
 		RenderRadarScreen( );
@@ -315,6 +325,9 @@
 		// reset dirty flag
 		fMapScreenBottomDirty = FALSE;
 		fMapBottomDirtied = TRUE;
+
+		// Headrock: Moved this next line from the above marker ^
+		fMapScreenBottomDirty = FALSE;
 	}
 
 	DisplayCompressMode( );
@@ -328,8 +341,11 @@
 	// display slider on the scroll bar
 	DisplayScrollBarSlider( );
 
+	// CHRISL: Don't display messagelist if inventory panel is open
+	// CHRISL: Only run this condition if we're drawing the message list on the left
 	// display messages that can be scrolled through
-	DisplayStringsInMapScreenMessageList( );
+	if(!fShowInventoryFlag)
+		DisplayStringsInMapScreenMessageList( );
 	
 	// handle auto scroll
 	//CheckForAndHandleAutoMessageScroll( );
@@ -338,6 +354,10 @@
 
 	EnableDisableBottomButtonsAndRegions( );
 
+	//CHRISL: Force a render of the inventory panel if it's already open
+	//if(fShowInventoryFlag)
+	//	BltCharInvPanel();
+
 	fMapBottomDirtied = FALSE;
 	return;
 }
@@ -394,12 +414,20 @@
 
 
  // scroll buttons
+// CHRISL: Changed coordinates to dynamically place scroll buttons from the right edge of screen.
   guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_UP ]=  LoadButtonImage( "INTERFACE\\map_screen_bottom_arrows.sti" ,11,4,-1,6,-1 );
+//  guiMapMessageScrollButtons[ MAP_SCROLL_MESSAGE_UP ] = QuickCreateButton( guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_UP ], (SCREEN_WIDTH - 533), (SCREEN_HEIGHT - 109), 
+//										BUTTON_TOGGLE, MSYS_PRIORITY_HIGHEST - 1,
+//										(GUI_CALLBACK)BtnGenericMouseMoveButtonCallback, (GUI_CALLBACK)BtnMessageUpMapScreenCallback);
+ 
+	guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_DOWN ]=  LoadButtonImage( "INTERFACE\\map_screen_bottom_arrows.sti" ,12,5,-1,7,-1 );
+//  guiMapMessageScrollButtons[ MAP_SCROLL_MESSAGE_DOWN ] = QuickCreateButton( guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_DOWN ], (SCREEN_WIDTH - 533), (SCREEN_HEIGHT - 28), 
+//										BUTTON_TOGGLE, MSYS_PRIORITY_HIGHEST - 1,
+//										(GUI_CALLBACK)BtnGenericMouseMoveButtonCallback, (GUI_CALLBACK)BtnMessageDownMapScreenCallback);
+// CHRISL: Use these if we want buttons based on left edge of screen
   guiMapMessageScrollButtons[ MAP_SCROLL_MESSAGE_UP ] = QuickCreateButton( guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_UP ], 331, (SCREEN_HEIGHT - 109),
 										BUTTON_TOGGLE, MSYS_PRIORITY_HIGHEST - 1,
 										(GUI_CALLBACK)BtnGenericMouseMoveButtonCallback, (GUI_CALLBACK)BtnMessageUpMapScreenCallback);
- 
-	guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_DOWN ]=  LoadButtonImage( "INTERFACE\\map_screen_bottom_arrows.sti" ,12,5,-1,7,-1 );
   guiMapMessageScrollButtons[ MAP_SCROLL_MESSAGE_DOWN ] = QuickCreateButton( guiMapMessageScrollButtonsImage[ MAP_SCROLL_MESSAGE_DOWN ], 331, (SCREEN_HEIGHT - 28),
 										BUTTON_TOGGLE, MSYS_PRIORITY_HIGHEST - 1,
 										(GUI_CALLBACK)BtnGenericMouseMoveButtonCallback, (GUI_CALLBACK)BtnMessageDownMapScreenCallback);
@@ -1389,8 +1417,10 @@
 	swprintf( sString, L"%s", pMapScreenBottomText[ 0 ] );
 
 	// center it
+	// CHRISL: Replaced X coordinate with dynamic coordinate set from right edge of screen
+	//VarFindFontCenterCoordinates( (SCREEN_WIDTH - 637), (SCREEN_HEIGHT - 107),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
+	// CHRISL: Use this if we want to display from the left edge
 	VarFindFontCenterCoordinates( 359, (SCREEN_HEIGHT - 107),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
-	//VarFindFontCenterCoordinates( 359, 387 - 14,  437 - 359, 10,  COMPFONT, &sFontX, &sFontY, sString );
 	
 	// print it
 	mprintf( sFontX, sFontY, L"%s", sString );
@@ -1398,7 +1428,9 @@
 	swprintf( sString, L"%s", zMarksMapScreenText[ 2 ] );
 
 	// center it
-	//VarFindFontCenterCoordinates( 359, 433 - 14,  437 - 359, 10,  COMPFONT, &sFontX, &sFontY, sString );
+	// CHRISL: Replaced X coordinate with dynamic coordinate set from right edge of screen
+	//VarFindFontCenterCoordinates( (SCREEN_WIDTH - 637), (SCREEN_HEIGHT - 61),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
+	// CHRISL: Use this if we want to display from the left edge
 	VarFindFontCenterCoordinates( 359, (SCREEN_HEIGHT - 61),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
 
 	// print it
@@ -1431,8 +1463,11 @@
 	InsertDollarSignInToString( sString );
 
 	// center it
+	// CHRISL: Replaced X coordinate with dynamic coordinate set from right edge of screen
+	//VarFindFontCenterCoordinates( (SCREEN_WIDTH - 637), (SCREEN_HEIGHT - 91),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
+	// CHRISL: Use this if we want to display from the left edge
 	VarFindFontCenterCoordinates( 359, (SCREEN_HEIGHT - 91),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
-	
+
 	// print it
 	mprintf( sFontX, sFontY, L"%s", sString );
 
@@ -1542,8 +1577,11 @@
 	InsertDollarSignInToString( sString );
 
 	// center it
+	// CHRISL: Replaced X coordinate with dynamic coordinate set from right edge of screen
+	//VarFindFontCenterCoordinates( (SCREEN_WIDTH - 637), (SCREEN_HEIGHT - 45),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
+	// CHRISL: Use this if we want to display from the left edge
 	VarFindFontCenterCoordinates( 359, (SCREEN_HEIGHT - 45),  78, 10,  COMPFONT, &sFontX, &sFontY, sString );
-	
+
 	// print it
 	mprintf( sFontX, sFontY, L"%s", sString );
 	
Index: Strategic/Map Screen Interface Bottom.h
===================================================================
--- Strategic/Map Screen Interface Bottom.h	(revision 1299)
+++ Strategic/Map Screen Interface Bottom.h	(working copy)
@@ -32,7 +32,8 @@
 void DeleteMapScreenInterfaceBottom( void );
 void DestroyButtonsForMapScreenInterfaceBottom( void );
 BOOLEAN CreateButtonsForMapScreenInterfaceBottom( void );
-void RenderMapScreenInterfaceBottom( void );
+// Headrock: Added argument to this function:
+void RenderMapScreenInterfaceBottom( BOOLEAN fForceMapscreenBottomRerender );
 
 // delete map bottom graphics
 void DeleteMapBottomGraphics( void );
@@ -62,4 +63,4 @@
 void ChangeCurrentMapscreenMessageIndex( UINT8 ubNewMessageIndex );
 void MoveToEndOfMapScreenMessageList( void );
 
-#endif
\ No newline at end of file
+#endif
Index: Strategic/mapscreen.cpp
===================================================================
--- Strategic/mapscreen.cpp	(revision 1299)
+++ Strategic/mapscreen.cpp	(working copy)
@@ -148,199 +148,204 @@
 #define	MINS_TO_FLASH_CONTRACT_TIME	(4 * 60)
 
 // Coordinate defines
+// CHRISL: Reclassify all coordinates as int variables and declare their values in an initialization function.
+int TOWN_INFO_X;
+int TOWN_INFO_Y;
 
-#define     TOWN_INFO_X           0
-#define     TOWN_INFO_Y           1
+int PLAYER_INFO_X;
+int PLAYER_INFO_Y;
 
-#define     PLAYER_INFO_X         0
-#define     PLAYER_INFO_Y         107
-
 // item description
-#define			MAP_ITEMDESC_START_X		  0
-#define			MAP_ITEMDESC_START_Y			PLAYER_INFO_Y
+int MAP_ITEMDESC_START_X;
+int MAP_ITEMDESC_START_Y;
 
-#define     INV_REGION_X PLAYER_INFO_X
-#define     INV_REGION_Y PLAYER_INFO_Y
-#define     INV_REGION_WIDTH 261
-#define     INV_REGION_HEIGHT 359-94
-#define     INV_BTN_X PLAYER_INFO_X + 217
-#define     INV_BTN_Y PLAYER_INFO_Y + 210
+int INV_REGION_X;
+int INV_REGION_Y;
+int INV_REGION_WIDTH;
+int INV_REGION_HEIGHT;
+int INV_BTN_X;
+int INV_BTN_Y;
+int INV_BDROP_X;
+int INV_BDROP_Y;
 
-#define			MAP_ARMOR_LABEL_X 208
-#define			MAP_ARMOR_LABEL_Y 180
-#define			MAP_ARMOR_X									209
-#define			MAP_ARMOR_Y									189
-#define			MAP_ARMOR_PERCENT_X 229
-#define			MAP_ARMOR_PERCENT_Y 190
+int MAP_ARMOR_LABEL_X;
+int MAP_ARMOR_LABEL_Y;
+int MAP_ARMOR_X;
+int MAP_ARMOR_Y;
+int MAP_ARMOR_PERCENT_X;
+int MAP_ARMOR_PERCENT_Y;
 
-#define			MAP_WEIGHT_LABEL_X 173
-#define			MAP_WEIGHT_LABEL_Y 256
-#define			MAP_WEIGHT_X								176
-#define			MAP_WEIGHT_Y								266
-#define			MAP_WEIGHT_PERCENT_X 196
-#define			MAP_WEIGHT_PERCENT_Y 266
+int MAP_WEIGHT_LABEL_X;
+int MAP_WEIGHT_LABEL_Y;
+int MAP_WEIGHT_X;
+int MAP_WEIGHT_Y;
+int MAP_WEIGHT_PERCENT_X;
+int MAP_WEIGHT_PERCENT_Y;
 
-#define			MAP_CAMMO_LABEL_X					178
-#define			MAP_CAMMO_LABEL_Y					283
-#define			MAP_CAMMO_X							176
-#define			MAP_CAMMO_Y							292
-#define			MAP_CAMMO_PERCENT_X					196
-#define			MAP_CAMMO_PERCENT_Y					293
+int MAP_CAMMO_LABEL_X;
+int MAP_CAMMO_LABEL_Y;
+int MAP_CAMMO_X;
+int MAP_CAMMO_Y;
+int MAP_CAMMO_PERCENT_X;
+int MAP_CAMMO_PERCENT_Y;
 
-#define			MAP_PERCENT_WIDTH					20
-#define			MAP_PERCENT_HEIGHT					10
+int MAP_PERCENT_WIDTH;
+int MAP_PERCENT_HEIGHT;
 
-#define			MAP_INV_STATS_TITLE_FONT_COLOR		6
-#define			MAP_INV_STATS_TEXT_FONT_COLOR		5
+int MAP_INV_STATS_TITLE_FONT_COLOR;
+int MAP_INV_STATS_TEXT_FONT_COLOR;
 
-#define     PLAYER_INFO_FACE_START_X    9
-#define     PLAYER_INFO_FACE_START_Y    17
-#define     PLAYER_INFO_FACE_END_X		60
-#define     PLAYER_INFO_FACE_END_Y		76
+int PLAYER_INFO_FACE_START_X;
+int PLAYER_INFO_FACE_START_Y;
+int PLAYER_INFO_FACE_END_X;
+int PLAYER_INFO_FACE_END_Y;
 
-#define     INV_BODY_X 71
-#define     INV_BODY_Y 116
+int INV_BODY_X;
+int INV_BODY_Y;
 
-#define     NAME_X						4	
-#define     NAME_WIDTH					55 - NAME_X
+int NAME_X;
+int NAME_WIDTH;
 
-#define     ASSIGN_X					60
-#define     ASSIGN_WIDTH				111 - ASSIGN_X
-#define		SLEEP_X						116
-#define		SLEEP_WIDTH					135 - SLEEP_X
-#define     LOC_X						140
-#define     LOC_WIDTH					172 - LOC_X
-#define     DEST_ETA_X					177
-#define     DEST_ETA_WIDTH				210 - DEST_ETA_X
-#define     TIME_REMAINING_X			215
-#define     TIME_REMAINING_WIDTH		243 - TIME_REMAINING_X
+int ASSIGN_X;
+int ASSIGN_WIDTH;
+int SLEEP_X;
+int SLEEP_WIDTH;
+int LOC_X;
+int LOC_WIDTH;
+int DEST_ETA_X;
+int DEST_ETA_WIDTH;
+int TIME_REMAINING_X;
+int TIME_REMAINING_WIDTH;
 
-#define     CLOCK_Y_START			(MAP_BORDER_Y_OFFSET + 298) // 298
+int CLOCK_Y_START;
 
-#define     DEST_PLOT_X				(MAP_BORDER_X_OFFSET + 463)		//463
-#define     DEST_PLOT_Y				(MAP_BORDER_Y_OFFSET + 345)		//345
+int DEST_PLOT_X;
+int DEST_PLOT_Y;
 
-#define     CLOCK_ETA_X				(MAP_BORDER_X_OFFSET + 484)		//463 - 15 + 6 + 30
-#define     CLOCK_HOUR_X_START		(MAP_BORDER_X_OFFSET + 518)		//463 + 25 + 30
-#define     CLOCK_MIN_X_START		(MAP_BORDER_X_OFFSET + 538)		//463 + 45 + 30
+int CLOCK_ETA_X;
+int CLOCK_HOUR_X_START;
+int CLOCK_MIN_X_START;
 
 // contract
-#define CONTRACT_X      185
-#define CONTRACT_Y      50
+int CONTRACT_X;
+int CONTRACT_Y;
 
 // trash can
-#define TRASH_CAN_X 176
-#define TRASH_CAN_Y 211 + PLAYER_INFO_Y
-#define TRASH_CAN_WIDTH 193 - 165
-#define TRASH_CAN_HEIGHT 239 - 217
+int TRASH_CAN_X;
+int TRASH_CAN_Y;
+int TRASH_CAN_WIDTH;
+int TRASH_CAN_HEIGHT;
 
+// keyring
+int MAP_KEYRING_X;
+int MAP_KEYRING_Y;
+
 //Text offsets
-#define Y_OFFSET 2
+int Y_OFFSET;
 
 // The boxes defines
-#define TRAIN_Y_OFFSET     53
-#define TRAIN_X_OFF        65
-#define TRAIN_WID          80
-#define TRAIN_HEIG         47 
-#define STRING_X_OFFSET    10
-#define STRING_Y_OFFSET     5
-#define POP_UP_BOX_X      120
-#define POP_UP_BOX_Y        0
-#define POP_UP_BOX_WIDTH   60
-#define POP_UP_BOX_HEIGHT  100
-#define MOUSE_PTR_Y_OFFSET  3
-#define POP_UP_Y_OFFSET     3
-#define TRAIN_TEXT_Y_OFFSET 4
+int TRAIN_Y_OFFSET;
+int TRAIN_X_OFF;
+int TRAIN_WID;
+int TRAIN_HEIG;
+int STRING_X_OFFSET;
+int STRING_Y_OFFSET;
+int POP_UP_BOX_X;
+int POP_UP_BOX_Y;
+int POP_UP_BOX_WIDTH;
+int POP_UP_BOX_HEIGHT;
+int MOUSE_PTR_Y_OFFSET;
+int POP_UP_Y_OFFSET;
+int TRAIN_TEXT_Y_OFFSET;
 
 
 // char stat positions
-#define STR_X ( 112 )
-#define STR_Y 42
-#define DEX_X STR_X
-#define DEX_Y 32
-#define AGL_X STR_X 
-#define AGL_Y 22
-#define LDR_X STR_X
-#define LDR_Y 52
-#define WIS_X STR_X
-#define WIS_Y 62
-#define LVL_X ( 159 )
-#define LVL_Y AGL_Y
-#define MRK_X LVL_X
-#define MRK_Y DEX_Y
-#define EXP_X LVL_X
-#define EXP_Y STR_Y
-#define MEC_X LVL_X
-#define MEC_Y LDR_Y
-#define MED_X LVL_X
-#define MED_Y WIS_Y
+int STR_X;
+int STR_Y;
+int DEX_X;
+int DEX_Y;
+int AGL_X;
+int AGL_Y;
+int LDR_X;
+int LDR_Y;
+int WIS_X;
+int WIS_Y;
+int LVL_X;
+int LVL_Y;
+int MRK_X;
+int MRK_Y;
+int EXP_X;
+int EXP_Y;
+int MEC_X;
+int MEC_Y;
+int MED_X;
+int MED_Y;
 
-#define STAT_WID 15
-#define STAT_HEI GetFontHeight(CHAR_FONT)
+int STAT_WID;
+int STAT_HEI;
 
-#define PIC_NAME_X 8
-#define PIC_NAME_Y (66 + 3)
-#define PIC_NAME_WID 60 - PIC_NAME_X
-#define PIC_NAME_HEI 75 - PIC_NAME_Y
-#define CHAR_NAME_X 14
-#define CHAR_NAME_Y (2 + 3)
-#define CHAR_NAME_WID 164 - CHAR_NAME_X
-#define CHAR_NAME_HEI 11 - CHAR_NAME_Y
-#define CHAR_LOC_X    76
-#define CHAR_LOC_Y    84 
-#define CHAR_LOC_WID  16
-#define CHAR_LOC_HEI  9
-#define CHAR_TIME_REMAINING_X		207
-#define CHAR_TIME_REMAINING_Y		65
-#define CHAR_TIME_REMAINING_WID 258 - CHAR_TIME_REMAINING_X
-#define CHAR_TIME_REMAINING_HEI GetFontHeight(CHAR_FONT)
-#define CHAR_SALARY_X						CHAR_TIME_REMAINING_X
-#define CHAR_SALARY_Y						79
-#define CHAR_SALARY_WID					CHAR_TIME_REMAINING_WID - 8		// for right justify
-#define CHAR_SALARY_HEI					CHAR_TIME_REMAINING_HEI
-#define CHAR_MEDICAL_X					CHAR_TIME_REMAINING_X
-#define CHAR_MEDICAL_Y					93
-#define CHAR_MEDICAL_WID				CHAR_TIME_REMAINING_WID - 8		// for right justify
-#define CHAR_MEDICAL_HEI				CHAR_TIME_REMAINING_HEI
-#define CHAR_ASSIGN_X 182
-#define CHAR_ASSIGN1_Y 18
-#define CHAR_ASSIGN2_Y 31
-#define CHAR_ASSIGN_WID 257 - 178
-#define CHAR_ASSIGN_HEI 39 - 29
-#define CHAR_HP_X 133
-#define CHAR_HP_Y 77 + 3
-#define CHAR_HP_WID 175 - CHAR_HP_X
-#define CHAR_HP_HEI  90 - CHAR_HP_Y
-#define CHAR_MORALE_X 133
-#define CHAR_MORALE_Y 91 + 3
-#define CHAR_MORALE_WID 175 - CHAR_MORALE_X
-#define CHAR_MORALE_HEI 101 - CHAR_MORALE_Y
+int PIC_NAME_X;
+int PIC_NAME_Y;
+int PIC_NAME_WID;
+int PIC_NAME_HEI;
+int CHAR_NAME_X;
+int CHAR_NAME_Y;
+int CHAR_NAME_WID;
+int CHAR_NAME_HEI;
+int CHAR_LOC_X;
+int CHAR_LOC_Y;
+int CHAR_LOC_WID;
+int CHAR_LOC_HEI;
+int CHAR_TIME_REMAINING_X;
+int CHAR_TIME_REMAINING_Y;
+int CHAR_TIME_REMAINING_WID;
+int CHAR_TIME_REMAINING_HEI;
+int CHAR_SALARY_X;
+int CHAR_SALARY_Y;
+int CHAR_SALARY_WID;
+int CHAR_SALARY_HEI;
+int CHAR_MEDICAL_X;
+int CHAR_MEDICAL_Y;
+int CHAR_MEDICAL_WID;
+int CHAR_MEDICAL_HEI;
+int CHAR_ASSIGN_X;
+int CHAR_ASSIGN1_Y;
+int CHAR_ASSIGN2_Y;
+int CHAR_ASSIGN_WID;
+int CHAR_ASSIGN_HEI;
+int CHAR_HP_X;
+int CHAR_HP_Y;
+int CHAR_HP_WID;
+int CHAR_HP_HEI;
+int CHAR_MORALE_X;
+int CHAR_MORALE_Y;
+int CHAR_MORALE_WID;
+int CHAR_MORALE_HEI;
 
-#define CROSS_X 195
-#define CROSS_Y 83
-#define CROSS_HEIGHT 20
-#define CROSS_WIDTH  20
-#define CHAR_PAY_X 150
-#define CHAR_PAY_Y 80+4
-#define CHAR_PAY_HEI GetFontHeight(CHAR_FONT)
-#define CHAR_PAY_WID CROSS_X-CHAR_PAY_X
-#define SOLDIER_PIC_X 9
-#define SOLDIER_PIC_Y 20
-#define SOLDIER_HAND_X 6
-#define SOLDIER_HAND_Y 81
-//#define	TM_INV_WIDTH								58
-//#define	TM_INV_HEIGHT								23
+int CROSS_X;
+int CROSS_Y;
+int CROSS_HEIGHT;
+int CROSS_WIDTH;
+int CHAR_PAY_X;
+int CHAR_PAY_Y;
+int CHAR_PAY_HEI;
+int CHAR_PAY_WID;
+int SOLDIER_PIC_X;
+int SOLDIER_PIC_Y;
+int SOLDIER_HAND_X;
+int SOLDIER_HAND_Y;
+//int	TM_INV_WIDTH;
+//int	TM_INV_HEIGHT;
 
 // WANNE: The position of the clock in the strategy screen
-//#define CLOCK_X		(SCREEN_WIDTH - 86)					//554
-//#define CLOCK_Y		(SCREEN_HEIGHT - 21)				//459
+//int CLOCK_X;
+//int CLOCK_Y;
 
 
 #define RGB_WHITE				( FROMRGB( 255, 255, 255 ) )
 #define RGB_YELLOW			( FROMRGB( 255, 255,   0 ) )
 #define RGB_NEAR_BLACK	( FROMRGB(   0,   0,   1 ) )
 
-
 // ENUMS
 
 
@@ -464,35 +469,10 @@
 
 
 // map screen's inventory panel pockets - top right corner coordinates
-INV_REGION_DESC gMapScreenInvPocketXY[] = 
-{
-	204,116,			// HELMETPOS
-	204,145,			// VESTPOS
-	204,205,			// LEGPOS,
-	21,	116,			// HEAD1POS
-	21,	140,			// HEAD2POS
-	21,	194,			// HANDPOS,
-	21,	218,			// SECONDHANDPOS
-	98,	251,			// BIGPOCK1
-	98,	275,			// BIGPOCK2
-	98,	299,			// BIGPOCK3
-	98,	323,			// BIGPOCK4
-	22,	251,			// SMALLPOCK1
-	22,	275,			// SMALLPOCK2
-	22,	299,			// SMALLPOCK3
-	22,	323,			// SMALLPOCK4
-	60,	251,			// SMALLPOCK5
-	60,	275,			// SMALLPOCK6
-	60,	299,			// SMALLPOCK7
-	60,	323				// SMALLPOCK8
-};
+INV_REGION_DESC gMapScreenInvPocketXY[NUM_INV_SLOTS];	// ARRAY FOR INV PANEL INTERFACE ITEM POSITIONS
+INV_REGION_DESC gSCamoXY;
 
-INV_REGION_DESC gSCamoXY = 
-{
-	INV_BODY_X, INV_BODY_Y		// X, Y Location of Map screen's Camouflage region
-};
 
-
 // WANNE: <scroll>
 // buttons images
 //UINT32 guiMapMercsScrollButtonsImage[ 2 ];
@@ -1074,6 +1054,534 @@
 #endif
 
 
+// CHRISL: New functions to handle initialization of inventory coordinates
+BOOLEAN InitializeInvPanelCoordsOld()
+{
+	TOWN_INFO_X						= 0;
+	TOWN_INFO_Y						= 1;
+
+	PLAYER_INFO_X					= 0;
+	PLAYER_INFO_Y					= 107;
+
+	// Inventory slots
+	gMapScreenInvPocketXY[HELMETPOS].sX = PLAYER_INFO_X + 204;		gMapScreenInvPocketXY[HELMETPOS].sY = PLAYER_INFO_Y + 9;	// HELMETPOS
+	gMapScreenInvPocketXY[VESTPOS].sX = PLAYER_INFO_X + 204;		gMapScreenInvPocketXY[VESTPOS].sY = PLAYER_INFO_Y + 38;	// VESTPOS
+	gMapScreenInvPocketXY[LEGPOS].sX = PLAYER_INFO_X + 204;			gMapScreenInvPocketXY[LEGPOS].sY = PLAYER_INFO_Y + 96;	// LEGPOS,
+	gMapScreenInvPocketXY[HEAD1POS].sX = PLAYER_INFO_X + 21;		gMapScreenInvPocketXY[HEAD1POS].sY = PLAYER_INFO_Y + 9;	// HEAD1POS
+	gMapScreenInvPocketXY[HEAD2POS].sX = PLAYER_INFO_X + 21;		gMapScreenInvPocketXY[HEAD2POS].sY = PLAYER_INFO_Y + 33;	// HEAD2POS
+	gMapScreenInvPocketXY[HANDPOS].sX = PLAYER_INFO_X + 21;			gMapScreenInvPocketXY[HANDPOS].sY = PLAYER_INFO_Y + 87;	// HANDPOS,
+	gMapScreenInvPocketXY[SECONDHANDPOS].sX = PLAYER_INFO_X + 21;	gMapScreenInvPocketXY[SECONDHANDPOS].sY = PLAYER_INFO_Y + 111;	// SECONDHANDPOS
+	gMapScreenInvPocketXY[BIGPOCK1POS].sX = PLAYER_INFO_X + 98;		gMapScreenInvPocketXY[BIGPOCK1POS].sY = PLAYER_INFO_Y + 144;	// BIGPOCK1
+	gMapScreenInvPocketXY[BIGPOCK2POS].sX = PLAYER_INFO_X + 98;		gMapScreenInvPocketXY[BIGPOCK2POS].sY = PLAYER_INFO_Y + 168;	// BIGPOCK2
+	gMapScreenInvPocketXY[BIGPOCK3POS].sX = PLAYER_INFO_X + 98;		gMapScreenInvPocketXY[BIGPOCK3POS].sY = PLAYER_INFO_Y + 192;	// BIGPOCK3
+	gMapScreenInvPocketXY[BIGPOCK4POS].sX = PLAYER_INFO_X + 98;		gMapScreenInvPocketXY[BIGPOCK4POS].sY = PLAYER_INFO_Y + 216;	// BIGPOCK4
+	gMapScreenInvPocketXY[SMALLPOCK1POS].sX = PLAYER_INFO_X + 22;	gMapScreenInvPocketXY[SMALLPOCK1POS].sY = PLAYER_INFO_Y + 144;	// SMALLPOCK1
+	gMapScreenInvPocketXY[SMALLPOCK2POS].sX = PLAYER_INFO_X + 22;	gMapScreenInvPocketXY[SMALLPOCK2POS].sY = PLAYER_INFO_Y + 168;	// SMALLPOCK2
+	gMapScreenInvPocketXY[SMALLPOCK3POS].sX = PLAYER_INFO_X + 22;	gMapScreenInvPocketXY[SMALLPOCK3POS].sY = PLAYER_INFO_Y + 192;	// SMALLPOCK3
+	gMapScreenInvPocketXY[SMALLPOCK4POS].sX = PLAYER_INFO_X + 22;	gMapScreenInvPocketXY[SMALLPOCK4POS].sY = PLAYER_INFO_Y + 216;	// SMALLPOCK4
+	gMapScreenInvPocketXY[SMALLPOCK5POS].sX = PLAYER_INFO_X + 60;	gMapScreenInvPocketXY[SMALLPOCK5POS].sY = PLAYER_INFO_Y + 144;	// SMALLPOCK5
+	gMapScreenInvPocketXY[SMALLPOCK6POS].sX = PLAYER_INFO_X + 60;	gMapScreenInvPocketXY[SMALLPOCK6POS].sY = PLAYER_INFO_Y + 168;	// SMALLPOCK6
+	gMapScreenInvPocketXY[SMALLPOCK7POS].sX = PLAYER_INFO_X + 60;	gMapScreenInvPocketXY[SMALLPOCK7POS].sY = PLAYER_INFO_Y + 192;	// SMALLPOCK7
+	gMapScreenInvPocketXY[SMALLPOCK8POS].sX = PLAYER_INFO_X + 60;	gMapScreenInvPocketXY[SMALLPOCK8POS].sY = PLAYER_INFO_Y + 216;	// SMALLPOCK8
+
+	// item description
+	MAP_ITEMDESC_START_X			= 0;
+	MAP_ITEMDESC_START_Y			= PLAYER_INFO_Y;
+
+	INV_REGION_X					= PLAYER_INFO_X;
+	INV_REGION_Y					= PLAYER_INFO_Y;
+	INV_REGION_WIDTH				= 261;
+	INV_REGION_HEIGHT				= 359-94;
+	INV_BTN_X						= PLAYER_INFO_X + 217;
+	INV_BTN_Y						= PLAYER_INFO_Y + 210;
+	INV_BDROP_X						= 0;	// Not used in old inventory
+	INV_BDROP_Y						= 0;	// Not used in old inventory
+
+	MAP_ARMOR_LABEL_X				= 208;
+	MAP_ARMOR_LABEL_Y				= 180;
+	MAP_ARMOR_X						= 209;
+	MAP_ARMOR_Y						= 189;
+	MAP_ARMOR_PERCENT_X				= 229;
+	MAP_ARMOR_PERCENT_Y				= 190;
+
+	MAP_WEIGHT_LABEL_X				= 173;
+	MAP_WEIGHT_LABEL_Y				= 256;
+	MAP_WEIGHT_X					= 176;
+	MAP_WEIGHT_Y					= 266;
+	MAP_WEIGHT_PERCENT_X			= 196;
+	MAP_WEIGHT_PERCENT_Y			= 266;
+
+	MAP_CAMMO_LABEL_X				= 178;
+	MAP_CAMMO_LABEL_Y				= 283;
+	MAP_CAMMO_X						= 176;
+	MAP_CAMMO_Y						= 292;
+	MAP_CAMMO_PERCENT_X				= 196;
+	MAP_CAMMO_PERCENT_Y				= 293;
+
+	MAP_PERCENT_WIDTH				= 20;
+	MAP_PERCENT_HEIGHT				= 10;
+
+	MAP_INV_STATS_TITLE_FONT_COLOR	= 6;
+	MAP_INV_STATS_TEXT_FONT_COLOR	= 5;
+
+	PLAYER_INFO_FACE_START_X		= 9;
+	PLAYER_INFO_FACE_START_Y		= 17;
+	PLAYER_INFO_FACE_END_X			= 60;
+	PLAYER_INFO_FACE_END_Y			= 76;
+
+	INV_BODY_X						= 71;
+	INV_BODY_Y						= 116;
+
+	// WANNE 2 <change 2>
+	NAME_X							= 4;
+	NAME_WIDTH						= 55 - NAME_X;
+
+	ASSIGN_X						= 60;
+	ASSIGN_WIDTH					= 111 - ASSIGN_X;
+	SLEEP_X							= 116;
+	SLEEP_WIDTH						= 135 - SLEEP_X;
+	LOC_X							= 140;
+	LOC_WIDTH						= 172 - LOC_X;
+	DEST_ETA_X						= 177;
+	DEST_ETA_WIDTH					= 210 - DEST_ETA_X;
+	TIME_REMAINING_X				= 215;
+	TIME_REMAINING_WIDTH			= 243 - TIME_REMAINING_X;
+
+	// WANNE 2
+	CLOCK_Y_START					= (MAP_BORDER_Y_OFFSET + 298);
+
+	DEST_PLOT_X						= (MAP_BORDER_X_OFFSET + 463);
+	DEST_PLOT_Y						= (MAP_BORDER_Y_OFFSET + 345);
+
+	// WANNE 2
+	CLOCK_ETA_X						= (MAP_BORDER_X_OFFSET + 484);
+	CLOCK_HOUR_X_START				= (MAP_BORDER_X_OFFSET + 518);
+	CLOCK_MIN_X_START				= (MAP_BORDER_X_OFFSET + 538);
+
+	// contract
+	CONTRACT_X						= 185;
+	CONTRACT_Y						= 50;
+
+	// trash can
+	TRASH_CAN_X						= 176;
+	TRASH_CAN_Y						= 211 + PLAYER_INFO_Y;
+	TRASH_CAN_WIDTH					= 193 - 165;
+	TRASH_CAN_HEIGHT				= 239 - 217;
+
+	// keyring
+	MAP_KEYRING_X					= 217;
+	MAP_KEYRING_Y					= 271;
+
+	//Text offsets
+	Y_OFFSET						= 2;
+
+	// The boxes defines
+	TRAIN_Y_OFFSET					= 53;
+	TRAIN_X_OFF						= 65;
+	TRAIN_WID						= 80;
+	TRAIN_HEIG						= 47;
+	STRING_X_OFFSET					= 10;
+	STRING_Y_OFFSET					= 5;
+	POP_UP_BOX_X					= 120;
+	POP_UP_BOX_Y					= 0;
+	POP_UP_BOX_WIDTH				= 60;
+	POP_UP_BOX_HEIGHT				= 100;
+	MOUSE_PTR_Y_OFFSET				= 3;
+	POP_UP_Y_OFFSET					= 3;
+	TRAIN_TEXT_Y_OFFSET				= 4;
+
+	// char stat positions
+	STR_X							= 112;
+	STR_Y							= 42;
+	DEX_X							= STR_X;
+	DEX_Y							= 32;
+	AGL_X							= STR_X;
+	AGL_Y							= 22;
+	LDR_X							= STR_X;
+	LDR_Y							= 52;
+	WIS_X							= STR_X;
+	WIS_Y							= 62;
+	LVL_X							= 159;
+	LVL_Y							= AGL_Y;
+	MRK_X							= LVL_X;
+	MRK_Y							= DEX_Y;
+	EXP_X							= LVL_X;
+	EXP_Y							= STR_Y;
+	MEC_X							= LVL_X;
+	MEC_Y							= LDR_Y;
+	MED_X							= LVL_X;
+	MED_Y							= WIS_Y;
+
+	STAT_WID						= 15;
+	STAT_HEI						= GetFontHeight(CHAR_FONT);
+
+	PIC_NAME_X						= 8;
+	PIC_NAME_Y						= (66 + 3);
+	PIC_NAME_WID					= 60 - PIC_NAME_X;
+	PIC_NAME_HEI					= 75 - PIC_NAME_Y;
+	CHAR_NAME_X						= 14;
+	CHAR_NAME_Y						= (2 + 3);
+	CHAR_NAME_WID					= 164 - CHAR_NAME_X;
+	CHAR_NAME_HEI					= 11 - CHAR_NAME_Y;
+	CHAR_LOC_X						= 76;
+	CHAR_LOC_Y						= 84;
+	CHAR_LOC_WID					= 16;
+	CHAR_LOC_HEI					= 9;
+	CHAR_TIME_REMAINING_X			= 207;
+	CHAR_TIME_REMAINING_Y			= 65;
+	CHAR_TIME_REMAINING_WID			= 258 - CHAR_TIME_REMAINING_X;
+	CHAR_TIME_REMAINING_HEI			= GetFontHeight(CHAR_FONT);
+	CHAR_SALARY_X					= CHAR_TIME_REMAINING_X;
+	CHAR_SALARY_Y					= 79;
+	CHAR_SALARY_WID					= CHAR_TIME_REMAINING_WID - 8;
+	CHAR_SALARY_HEI					= CHAR_TIME_REMAINING_HEI;
+	CHAR_MEDICAL_X					= CHAR_TIME_REMAINING_X;
+	CHAR_MEDICAL_Y					= 93;
+	CHAR_MEDICAL_WID				= CHAR_TIME_REMAINING_WID - 8;
+	CHAR_MEDICAL_HEI				= CHAR_TIME_REMAINING_HEI;
+	CHAR_ASSIGN_X					= 182;
+	CHAR_ASSIGN1_Y					= 18;
+	CHAR_ASSIGN2_Y					= 31;
+	CHAR_ASSIGN_WID					= 257 - 178;
+	CHAR_ASSIGN_HEI					= 39 - 29;
+	CHAR_HP_X						= 133;
+	CHAR_HP_Y						= 77 + 3;
+	CHAR_HP_WID						= 175 - CHAR_HP_X;
+	CHAR_HP_HEI						= 90 - CHAR_HP_Y;
+	CHAR_MORALE_X					= 133;
+	CHAR_MORALE_Y					= 91 + 3;
+	CHAR_MORALE_WID					= 175 - CHAR_MORALE_X;
+	CHAR_MORALE_HEI					= 101 - CHAR_MORALE_Y;
+
+	CROSS_X							= 195;
+	CROSS_Y							= 83;
+	CROSS_HEIGHT					= 20;
+	CROSS_WIDTH						= 20;
+	CHAR_PAY_X						= 150;
+	CHAR_PAY_Y						= 80+4;
+	CHAR_PAY_HEI					= GetFontHeight(CHAR_FONT);
+	CHAR_PAY_WID					= CROSS_X-CHAR_PAY_X;
+	SOLDIER_PIC_X					= 9;
+	SOLDIER_PIC_Y					= 20;
+	SOLDIER_HAND_X					= 6;
+	SOLDIER_HAND_Y					= 81;
+	//TM_INV_WIDTH					= 58;
+	//TM_INV_HEIGHT					= 23;
+
+	// WANNE 2 (the position of the clock in the strategy screen)
+	//CLOCK_X						= (SCREEN_WIDTH - 86);
+	//CLOCK_Y						= (SCREEN_HEIGHT - 21);
+
+	gSCamoXY.sX = INV_BODY_X;	gSCamoXY.sY = INV_BODY_Y;	// X, Y Location of Map screen's Camouflage region
+
+	return ( TRUE );
+}
+BOOLEAN InitializeInvPanelCoordsNew()
+{
+	TOWN_INFO_X						= 0;
+	TOWN_INFO_Y						= 1;
+
+	PLAYER_INFO_X					= 0;
+	PLAYER_INFO_Y					= 107;
+
+	// Inventory slots
+	gMapScreenInvPocketXY[0].sX = PLAYER_INFO_X + 131;	gMapScreenInvPocketXY[0].sY = PLAYER_INFO_Y + 9;		// HELMETPOS
+	gMapScreenInvPocketXY[1].sX = PLAYER_INFO_X + 131;	gMapScreenInvPocketXY[1].sY = PLAYER_INFO_Y + 38;		// VESTPOS
+	gMapScreenInvPocketXY[2].sX = PLAYER_INFO_X + 131;	gMapScreenInvPocketXY[2].sY = PLAYER_INFO_Y + 97;		// LEGPOS
+	gMapScreenInvPocketXY[3].sX = PLAYER_INFO_X + 14;	gMapScreenInvPocketXY[3].sY = PLAYER_INFO_Y + 9;		// HEAD1POS
+	gMapScreenInvPocketXY[4].sX = PLAYER_INFO_X + 14;	gMapScreenInvPocketXY[4].sY = PLAYER_INFO_Y + 33;		// HEAD2POS
+	gMapScreenInvPocketXY[5].sX = PLAYER_INFO_X + 14;	gMapScreenInvPocketXY[5].sY = PLAYER_INFO_Y + 86;		// HANDPOS
+	gMapScreenInvPocketXY[6].sX = PLAYER_INFO_X + 14;	gMapScreenInvPocketXY[6].sY = PLAYER_INFO_Y + 110;		// SECONDHANDPOS
+	gMapScreenInvPocketXY[7].sX = PLAYER_INFO_X + 186;	gMapScreenInvPocketXY[7].sY = PLAYER_INFO_Y + 156;		// VESTPOCK
+	gMapScreenInvPocketXY[8].sX = PLAYER_INFO_X + 29;	gMapScreenInvPocketXY[8].sY = PLAYER_INFO_Y + 256;		// LTHIGHPOCK
+	gMapScreenInvPocketXY[9].sX = PLAYER_INFO_X + 112;	gMapScreenInvPocketXY[9].sY = PLAYER_INFO_Y + 256;		// RTHIGHPOCK
+	gMapScreenInvPocketXY[10].sX = PLAYER_INFO_X + 194;	gMapScreenInvPocketXY[10].sY = PLAYER_INFO_Y + 256;		// CPACKPOCK
+	gMapScreenInvPocketXY[11].sX = PLAYER_INFO_X + 173;	gMapScreenInvPocketXY[11].sY = PLAYER_INFO_Y + 439;		// BPACKPOCK
+	gMapScreenInvPocketXY[12].sX = PLAYER_INFO_X + 95;	gMapScreenInvPocketXY[12].sY = PLAYER_INFO_Y + 156;		// GUNSLINGPOCKPOS
+	gMapScreenInvPocketXY[13].sX = PLAYER_INFO_X + 36;	gMapScreenInvPocketXY[13].sY = PLAYER_INFO_Y + 156;		// KNIFEPOCKPOS
+	gMapScreenInvPocketXY[14].sX = PLAYER_INFO_X + 186;	gMapScreenInvPocketXY[14].sY = PLAYER_INFO_Y + 336;		// BIGPOCK1
+	gMapScreenInvPocketXY[15].sX = PLAYER_INFO_X + 186;	gMapScreenInvPocketXY[15].sY = PLAYER_INFO_Y + 360;		// BIGPOCK2
+	gMapScreenInvPocketXY[16].sX = PLAYER_INFO_X + 186;	gMapScreenInvPocketXY[16].sY = PLAYER_INFO_Y + 384;		// BIGPOCK3
+	gMapScreenInvPocketXY[17].sX = PLAYER_INFO_X + 98;	gMapScreenInvPocketXY[17].sY = PLAYER_INFO_Y + 379;		// BIGPOCK4
+	gMapScreenInvPocketXY[18].sX = PLAYER_INFO_X + 98;	gMapScreenInvPocketXY[18].sY = PLAYER_INFO_Y + 403;		// BIGPOCK5
+	gMapScreenInvPocketXY[19].sX = PLAYER_INFO_X + 98;	gMapScreenInvPocketXY[19].sY = PLAYER_INFO_Y + 427;		// BIGPOCK6
+	gMapScreenInvPocketXY[20].sX = PLAYER_INFO_X + 98;	gMapScreenInvPocketXY[20].sY = PLAYER_INFO_Y + 451;		// BIGPOCK7
+	gMapScreenInvPocketXY[21].sX = PLAYER_INFO_X + 202;	gMapScreenInvPocketXY[21].sY = PLAYER_INFO_Y + 188;		// MEDPOCK1
+	gMapScreenInvPocketXY[22].sX = PLAYER_INFO_X + 202;	gMapScreenInvPocketXY[22].sY = PLAYER_INFO_Y + 212;		// MEDPOCK2
+	gMapScreenInvPocketXY[23].sX = PLAYER_INFO_X + 29;	gMapScreenInvPocketXY[23].sY = PLAYER_INFO_Y + 336;		// MEDPOCK3
+	gMapScreenInvPocketXY[24].sX = PLAYER_INFO_X + 112;	gMapScreenInvPocketXY[24].sY = PLAYER_INFO_Y + 336;		// MEDPOCK4
+	gMapScreenInvPocketXY[25].sX = PLAYER_INFO_X + 22;	gMapScreenInvPocketXY[25].sY = PLAYER_INFO_Y + 188;		// SMALLPOCK1
+	gMapScreenInvPocketXY[26].sX = PLAYER_INFO_X + 58;	gMapScreenInvPocketXY[26].sY = PLAYER_INFO_Y + 188;		// SMALLPOCK2
+	gMapScreenInvPocketXY[27].sX = PLAYER_INFO_X + 94;	gMapScreenInvPocketXY[27].sY = PLAYER_INFO_Y + 188;		// SMALLPOCK3
+	gMapScreenInvPocketXY[28].sX = PLAYER_INFO_X + 130;	gMapScreenInvPocketXY[28].sY = PLAYER_INFO_Y + 188;		// SMALLPOCK4
+	gMapScreenInvPocketXY[29].sX = PLAYER_INFO_X + 166;	gMapScreenInvPocketXY[29].sY = PLAYER_INFO_Y + 188;		// SMALLPOCK5
+	gMapScreenInvPocketXY[30].sX = PLAYER_INFO_X + 22;	gMapScreenInvPocketXY[30].sY = PLAYER_INFO_Y + 212;		// SMALLPOCK6
+	gMapScreenInvPocketXY[31].sX = PLAYER_INFO_X + 58;	gMapScreenInvPocketXY[31].sY = PLAYER_INFO_Y + 212;		// SMALLPOCK7
+	gMapScreenInvPocketXY[32].sX = PLAYER_INFO_X + 94;	gMapScreenInvPocketXY[32].sY = PLAYER_INFO_Y + 212;		// SMALLPOCK8	
+	gMapScreenInvPocketXY[33].sX = PLAYER_INFO_X + 130;	gMapScreenInvPocketXY[33].sY = PLAYER_INFO_Y + 212;		// SMALLPOCK9
+	gMapScreenInvPocketXY[34].sX = PLAYER_INFO_X + 166;	gMapScreenInvPocketXY[34].sY = PLAYER_INFO_Y + 212;		// SMALLPOCK10
+	gMapScreenInvPocketXY[35].sX = PLAYER_INFO_X + 18;	gMapScreenInvPocketXY[35].sY = PLAYER_INFO_Y + 288;		// SMALLPOCK11
+	gMapScreenInvPocketXY[36].sX = PLAYER_INFO_X + 54;	gMapScreenInvPocketXY[36].sY = PLAYER_INFO_Y + 288;		// SMALLPOCK12
+	gMapScreenInvPocketXY[37].sX = PLAYER_INFO_X + 18;	gMapScreenInvPocketXY[37].sY = PLAYER_INFO_Y + 312;		// SMALLPOCK13
+	gMapScreenInvPocketXY[38].sX = PLAYER_INFO_X + 54;	gMapScreenInvPocketXY[38].sY = PLAYER_INFO_Y + 312;		// SMALLPOCK14
+	gMapScreenInvPocketXY[39].sX = PLAYER_INFO_X + 100;	gMapScreenInvPocketXY[39].sY = PLAYER_INFO_Y + 288;		// SMALLPOCK15
+	gMapScreenInvPocketXY[40].sX = PLAYER_INFO_X + 136;	gMapScreenInvPocketXY[40].sY = PLAYER_INFO_Y + 288;		// SMALLPOCK16
+	gMapScreenInvPocketXY[41].sX = PLAYER_INFO_X + 100;	gMapScreenInvPocketXY[41].sY = PLAYER_INFO_Y + 312;		// SMALLPOCK17
+	gMapScreenInvPocketXY[42].sX = PLAYER_INFO_X + 136;	gMapScreenInvPocketXY[42].sY = PLAYER_INFO_Y + 312;		// SMALLPOCK18
+	gMapScreenInvPocketXY[43].sX = PLAYER_INFO_X + 183;	gMapScreenInvPocketXY[43].sY = PLAYER_INFO_Y + 288;		// SMALLPOCK19
+	gMapScreenInvPocketXY[44].sX = PLAYER_INFO_X + 219;	gMapScreenInvPocketXY[44].sY = PLAYER_INFO_Y + 288;		// SMALLPOCK20
+	gMapScreenInvPocketXY[45].sX = PLAYER_INFO_X + 183;	gMapScreenInvPocketXY[45].sY = PLAYER_INFO_Y + 312;		// SMALLPOCK21
+	gMapScreenInvPocketXY[46].sX = PLAYER_INFO_X + 219;	gMapScreenInvPocketXY[46].sY = PLAYER_INFO_Y + 312;		// SMALLPOCK22
+	gMapScreenInvPocketXY[47].sX = PLAYER_INFO_X + 26;	gMapScreenInvPocketXY[47].sY = PLAYER_INFO_Y + 379;		// SMALLPOCK23
+	gMapScreenInvPocketXY[48].sX = PLAYER_INFO_X + 26;	gMapScreenInvPocketXY[48].sY = PLAYER_INFO_Y + 403;		// SMALLPOCK24
+	gMapScreenInvPocketXY[49].sX = PLAYER_INFO_X + 26;	gMapScreenInvPocketXY[49].sY = PLAYER_INFO_Y + 427;		// SMALLPOCK25
+	gMapScreenInvPocketXY[50].sX = PLAYER_INFO_X + 26;	gMapScreenInvPocketXY[50].sY = PLAYER_INFO_Y + 451;		// SMALLPOCK26
+	gMapScreenInvPocketXY[51].sX = PLAYER_INFO_X + 62;	gMapScreenInvPocketXY[51].sY = PLAYER_INFO_Y + 379;		// SMALLPOCK27
+	gMapScreenInvPocketXY[52].sX = PLAYER_INFO_X + 62;	gMapScreenInvPocketXY[52].sY = PLAYER_INFO_Y + 403;		// SMALLPOCK28
+	gMapScreenInvPocketXY[53].sX = PLAYER_INFO_X + 62;	gMapScreenInvPocketXY[53].sY = PLAYER_INFO_Y + 427;		// SMALLPOCK29
+	gMapScreenInvPocketXY[54].sX = PLAYER_INFO_X + 62;	gMapScreenInvPocketXY[54].sY = PLAYER_INFO_Y + 451;		// SMALLPOCK30
+
+	// item description
+	MAP_ITEMDESC_START_X			= 0;
+	MAP_ITEMDESC_START_Y			= PLAYER_INFO_Y;
+
+	INV_REGION_X					= PLAYER_INFO_X;
+	INV_REGION_Y					= PLAYER_INFO_Y;
+	INV_REGION_WIDTH				= 261;
+	INV_REGION_HEIGHT				= 359-94;
+	INV_BTN_X						= PLAYER_INFO_X + 226;
+	INV_BTN_Y						= PLAYER_INFO_Y + 19;
+	INV_BDROP_X						= PLAYER_INFO_X + 220;
+	INV_BDROP_Y						= PLAYER_INFO_Y + 441;
+
+	MAP_ARMOR_LABEL_X				= 136;
+	MAP_ARMOR_LABEL_Y				= 177;
+	MAP_ARMOR_X						= 138;
+	MAP_ARMOR_Y						= 187;
+	MAP_ARMOR_PERCENT_X				= 158;
+	MAP_ARMOR_PERCENT_Y				= 188;
+
+	MAP_WEIGHT_LABEL_X				= 185;
+	MAP_WEIGHT_LABEL_Y				= 209;
+	MAP_WEIGHT_X					= 188;
+	MAP_WEIGHT_Y					= 219;
+	MAP_WEIGHT_PERCENT_X			= 208;
+	MAP_WEIGHT_PERCENT_Y			= 219;
+
+	MAP_CAMMO_LABEL_X				= 226;
+	MAP_CAMMO_LABEL_Y				= 209;
+	MAP_CAMMO_X						= 224;
+	MAP_CAMMO_Y						= 219;
+	MAP_CAMMO_PERCENT_X				= 244;
+	MAP_CAMMO_PERCENT_Y				= 219;
+
+	MAP_PERCENT_WIDTH				= 20;
+	MAP_PERCENT_HEIGHT				= 10;
+
+	MAP_INV_STATS_TITLE_FONT_COLOR	= 6;
+	MAP_INV_STATS_TEXT_FONT_COLOR	= 5;
+
+	PLAYER_INFO_FACE_START_X		= 9;
+	PLAYER_INFO_FACE_START_Y		= 17;
+	PLAYER_INFO_FACE_END_X			= 60;
+	PLAYER_INFO_FACE_END_Y			= 76;
+
+	INV_BODY_X						= 31;
+	INV_BODY_Y						= 8 + PLAYER_INFO_Y;
+
+	// WANNE 2 <change 2>
+	NAME_X							= 4;
+	NAME_WIDTH						= 55 - NAME_X;
+
+	ASSIGN_X						= 60;
+	ASSIGN_WIDTH					= 111 - ASSIGN_X;
+	SLEEP_X							= 116;
+	SLEEP_WIDTH						= 135 - SLEEP_X;
+	LOC_X							= 140;
+	LOC_WIDTH						= 172 - LOC_X;
+	DEST_ETA_X						= 177;
+	DEST_ETA_WIDTH					= 210 - DEST_ETA_X;
+	TIME_REMAINING_X				= 215;
+	TIME_REMAINING_WIDTH			= 243 - TIME_REMAINING_X;
+
+	// WANNE 2
+	CLOCK_Y_START					= (MAP_BORDER_Y_OFFSET + 298);
+
+	DEST_PLOT_X						= (MAP_BORDER_X_OFFSET + 463);
+	DEST_PLOT_Y						= (MAP_BORDER_Y_OFFSET + 345);
+
+	// WANNE 2
+	CLOCK_ETA_X						= (MAP_BORDER_X_OFFSET + 484);
+	CLOCK_HOUR_X_START				= (MAP_BORDER_X_OFFSET + 518);
+	CLOCK_MIN_X_START				= (MAP_BORDER_X_OFFSET + 538);
+
+	// contract
+	CONTRACT_X						= 185;
+	CONTRACT_Y						= 50;
+
+	// trash can
+	TRASH_CAN_X						= 209;
+	TRASH_CAN_Y						= 59 + PLAYER_INFO_Y;
+	TRASH_CAN_WIDTH					= 193 - 165;
+	TRASH_CAN_HEIGHT				= 239 - 217;
+
+	// keyring
+	MAP_KEYRING_X					= 180;
+	MAP_KEYRING_Y					= 127;
+
+	//Text offsets
+	Y_OFFSET						= 2;
+
+	// The boxes defines
+	TRAIN_Y_OFFSET					= 53;
+	TRAIN_X_OFF						= 65;
+	TRAIN_WID						= 80;
+	TRAIN_HEIG						= 47;
+	STRING_X_OFFSET					= 10;
+	STRING_Y_OFFSET					= 5;
+	POP_UP_BOX_X					= 120;
+	POP_UP_BOX_Y					= 0;
+	POP_UP_BOX_WIDTH				= 60;
+	POP_UP_BOX_HEIGHT				= 100;
+	MOUSE_PTR_Y_OFFSET				= 3;
+	POP_UP_Y_OFFSET					= 3;
+	TRAIN_TEXT_Y_OFFSET				= 4;
+
+	// char stat positions
+	STR_X							= 112;
+	STR_Y							= 42;
+	DEX_X							= STR_X;
+	DEX_Y							= 32;
+	AGL_X							= STR_X;
+	AGL_Y							= 22;
+	LDR_X							= STR_X;
+	LDR_Y							= 52;
+	WIS_X							= STR_X;
+	WIS_Y							= 62;
+	LVL_X							= 159;
+	LVL_Y							= AGL_Y;
+	MRK_X							= LVL_X;
+	MRK_Y							= DEX_Y;
+	EXP_X							= LVL_X;
+	EXP_Y							= STR_Y;
+	MEC_X							= LVL_X;
+	MEC_Y							= LDR_Y;
+	MED_X							= LVL_X;
+	MED_Y							= WIS_Y;
+
+	STAT_WID						= 15;
+	STAT_HEI						= GetFontHeight(CHAR_FONT);
+
+	PIC_NAME_X						= 8;
+	PIC_NAME_Y						= (66 + 3);
+	PIC_NAME_WID					= 60 - PIC_NAME_X;
+	PIC_NAME_HEI					= 75 - PIC_NAME_Y;
+	CHAR_NAME_X						= 14;
+	CHAR_NAME_Y						= (2 + 3);
+	CHAR_NAME_WID					= 164 - CHAR_NAME_X;
+	CHAR_NAME_HEI					= 11 - CHAR_NAME_Y;
+	CHAR_LOC_X						= 76;
+	CHAR_LOC_Y						= 84;
+	CHAR_LOC_WID					= 16;
+	CHAR_LOC_HEI					= 9;
+	CHAR_TIME_REMAINING_X			= 207;
+	CHAR_TIME_REMAINING_Y			= 65;
+	CHAR_TIME_REMAINING_WID			= 258 - CHAR_TIME_REMAINING_X;
+	CHAR_TIME_REMAINING_HEI			= GetFontHeight(CHAR_FONT);
+	CHAR_SALARY_X					= CHAR_TIME_REMAINING_X;
+	CHAR_SALARY_Y					= 79;
+	CHAR_SALARY_WID					= CHAR_TIME_REMAINING_WID - 8;
+	CHAR_SALARY_HEI					= CHAR_TIME_REMAINING_HEI;
+	CHAR_MEDICAL_X					= CHAR_TIME_REMAINING_X;
+	CHAR_MEDICAL_Y					= 93;
+	CHAR_MEDICAL_WID				= CHAR_TIME_REMAINING_WID - 8;
+	CHAR_MEDICAL_HEI				= CHAR_TIME_REMAINING_HEI;
+	CHAR_ASSIGN_X					= 182;
+	CHAR_ASSIGN1_Y					= 18;
+	CHAR_ASSIGN2_Y					= 31;
+	CHAR_ASSIGN_WID					= 257 - 178;
+	CHAR_ASSIGN_HEI					= 39 - 29;
+	CHAR_HP_X						= 133;
+	CHAR_HP_Y						= 77 + 3;
+	CHAR_HP_WID						= 175 - CHAR_HP_X;
+	CHAR_HP_HEI						= 90 - CHAR_HP_Y;
+	CHAR_MORALE_X					= 133;
+	CHAR_MORALE_Y					= 91 + 3;
+	CHAR_MORALE_WID					= 175 - CHAR_MORALE_X;
+	CHAR_MORALE_HEI					= 101 - CHAR_MORALE_Y;
+
+	CROSS_X							= 195;
+	CROSS_Y							= 83;
+	CROSS_HEIGHT					= 20;
+	CROSS_WIDTH						= 20;
+	CHAR_PAY_X						= 150;
+	CHAR_PAY_Y						= 80+4;
+	CHAR_PAY_HEI					= GetFontHeight(CHAR_FONT);
+	CHAR_PAY_WID					= CROSS_X-CHAR_PAY_X;
+	SOLDIER_PIC_X					= 9;
+	SOLDIER_PIC_Y					= 20;
+	SOLDIER_HAND_X					= 6;
+	SOLDIER_HAND_Y					= 81;
+	//TM_INV_WIDTH					= 58;
+	//TM_INV_HEIGHT					= 23;
+
+	// WANNE 2 (the position of the clock in the strategy screen)
+	//CLOCK_X						= (SCREEN_WIDTH - 86);
+	//CLOCK_Y						= (SCREEN_HEIGHT - 21);
+
+	gSCamoXY.sX = INV_BODY_X;	gSCamoXY.sY = INV_BODY_Y;	// X, Y Location of Map screen's Camouflage region
+
+	return ( TRUE );
+}
+BOOLEAN InitializeInvPanelCoordsVehicle( )
+{
+	InitializeInvPanelCoordsNew();
+	// Inventory slots
+	gMapScreenInvPocketXY[14].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[14].sY = PLAYER_INFO_Y + 156;
+	gMapScreenInvPocketXY[15].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[15].sY = PLAYER_INFO_Y + 156;
+	gMapScreenInvPocketXY[16].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[16].sY = PLAYER_INFO_Y + 156;
+	gMapScreenInvPocketXY[17].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[17].sY = PLAYER_INFO_Y + 180;
+	gMapScreenInvPocketXY[18].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[18].sY = PLAYER_INFO_Y + 180;
+	gMapScreenInvPocketXY[19].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[19].sY = PLAYER_INFO_Y + 180;
+	gMapScreenInvPocketXY[20].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[20].sY = PLAYER_INFO_Y + 204;
+	gMapScreenInvPocketXY[21].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[21].sY = PLAYER_INFO_Y + 204;
+	gMapScreenInvPocketXY[22].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[22].sY = PLAYER_INFO_Y + 204;
+	gMapScreenInvPocketXY[23].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[23].sY = PLAYER_INFO_Y + 228;
+	gMapScreenInvPocketXY[24].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[24].sY = PLAYER_INFO_Y + 228;
+	gMapScreenInvPocketXY[25].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[25].sY = PLAYER_INFO_Y + 228;
+	gMapScreenInvPocketXY[26].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[26].sY = PLAYER_INFO_Y + 252;
+	gMapScreenInvPocketXY[27].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[27].sY = PLAYER_INFO_Y + 252;
+	gMapScreenInvPocketXY[28].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[28].sY = PLAYER_INFO_Y + 252;
+	gMapScreenInvPocketXY[29].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[29].sY = PLAYER_INFO_Y + 276;
+	gMapScreenInvPocketXY[30].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[30].sY = PLAYER_INFO_Y + 276;
+	gMapScreenInvPocketXY[31].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[31].sY = PLAYER_INFO_Y + 276;
+	gMapScreenInvPocketXY[32].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[32].sY = PLAYER_INFO_Y + 300;
+	gMapScreenInvPocketXY[33].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[33].sY = PLAYER_INFO_Y + 300;
+	gMapScreenInvPocketXY[34].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[34].sY = PLAYER_INFO_Y + 300;
+	gMapScreenInvPocketXY[35].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[35].sY = PLAYER_INFO_Y + 324;
+	gMapScreenInvPocketXY[36].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[36].sY = PLAYER_INFO_Y + 324;
+	gMapScreenInvPocketXY[37].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[37].sY = PLAYER_INFO_Y + 324;
+	gMapScreenInvPocketXY[38].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[38].sY = PLAYER_INFO_Y + 348;
+	gMapScreenInvPocketXY[39].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[39].sY = PLAYER_INFO_Y + 348;
+	gMapScreenInvPocketXY[40].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[40].sY = PLAYER_INFO_Y + 348;
+	gMapScreenInvPocketXY[41].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[41].sY = PLAYER_INFO_Y + 372;
+	gMapScreenInvPocketXY[42].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[42].sY = PLAYER_INFO_Y + 372;
+	gMapScreenInvPocketXY[43].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[43].sY = PLAYER_INFO_Y + 372;
+	gMapScreenInvPocketXY[44].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[44].sY = PLAYER_INFO_Y + 396;
+	gMapScreenInvPocketXY[45].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[45].sY = PLAYER_INFO_Y + 396;
+	gMapScreenInvPocketXY[46].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[46].sY = PLAYER_INFO_Y + 396;
+	gMapScreenInvPocketXY[47].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[47].sY = PLAYER_INFO_Y + 420;
+	gMapScreenInvPocketXY[48].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[48].sY = PLAYER_INFO_Y + 420;
+	gMapScreenInvPocketXY[49].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[49].sY = PLAYER_INFO_Y + 420;
+	gMapScreenInvPocketXY[50].sX = PLAYER_INFO_X + 37;	gMapScreenInvPocketXY[50].sY = PLAYER_INFO_Y + 444;
+	gMapScreenInvPocketXY[51].sX = PLAYER_INFO_X + 104;	gMapScreenInvPocketXY[51].sY = PLAYER_INFO_Y + 444;
+	gMapScreenInvPocketXY[52].sX = PLAYER_INFO_X + 171;	gMapScreenInvPocketXY[52].sY = PLAYER_INFO_Y + 444;
+
+	InitInventoryVehicle(gMapScreenInvPocketXY, MAPInvMoveCallback, MAPInvClickCallback, FALSE);
+
+	return ( TRUE );
+}
+
 // the tries to select a mapscreen character by his soldier ID
 BOOLEAN SetInfoChar( UINT8 ubID )
 {
@@ -3941,6 +4449,8 @@
 		else
 		{
 			fShowInventoryFlag = FALSE;
+			// CHRISL: Added call to re-render the bottom panel
+			RenderMapScreenInterfaceBottom ( TRUE );
 			// set help text for item glow region
 			SetRegionFastHelpText( &gCharInfoHandRegion, pMiscMapScreenMouseRegionHelpText[ 0 ] );
 		}
@@ -6720,6 +7230,12 @@
   // disable allmouse regions in this space
   fTeamPanelDirty=TRUE;
 
+  // CHRISL: Setup default coords
+  if(gGameOptions.ubInventorySystem)
+	  InitializeInvPanelCoordsNew();
+  else
+	  InitializeInvPanelCoordsNew();
+
   InitInvSlotInterface( gMapScreenInvPocketXY, &gSCamoXY, MAPInvMoveCallback, MAPInvClickCallback, MAPInvMoveCamoCallback, MAPInvClickCamoCallback, FALSE );
   MSYS_EnableRegion(&gMPanelRegion);
 
@@ -6751,7 +7267,6 @@
 }
 
 
-
 void BltCharInvPanel()
 {
 	UINT32 uiDestPitchBYTES;
@@ -6768,15 +7283,34 @@
 	
 	GetSoldier( &pSoldier, gCharactersList[bSelectedInfoChar].usSolID );
 
-  
-  pDestBuf = (UINT16*)LockVideoSurface( guiSAVEBUFFER, &uiDestPitchBYTES);
-  GetVideoObject(&hCharListHandle, guiMAPINV);
-  Blt8BPPDataTo16BPPBufferTransparent( pDestBuf, uiDestPitchBYTES, hCharListHandle, PLAYER_INFO_X, PLAYER_INFO_Y, 0);
-  UnLockVideoSurface( guiSAVEBUFFER ); 
-  
-  Assert( pSoldier );
-  CreateDestroyMapInvButton();
+  	pDestBuf = (UINT16*)LockVideoSurface( guiSAVEBUFFER, &uiDestPitchBYTES);
+	GetVideoObject(&hCharListHandle, guiMAPINV);
+	// CHRISL: Changed last parameter so we can display graphic based on inventory system used
+	if(gGameOptions.ubInventorySystem && gGameExternalOptions.fVehicleInventory && (pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+	{
+		InitializeInvPanelCoordsVehicle();
+		Blt8BPPDataTo16BPPBufferTransparent( pDestBuf, uiDestPitchBYTES, hCharListHandle, PLAYER_INFO_X, PLAYER_INFO_Y, 2);
+	}
+	else if(gGameOptions.ubInventorySystem)
+	{
+		InitializeInvPanelCoordsNew();
+		fShowInventoryFlag = FALSE;
+		CreateDestroyMapInvButton();
+		fShowInventoryFlag = TRUE;
+		CreateDestroyMapInvButton();
+//		ResetMapInvRegions(gMapScreenInvPocketXY, MAPInvMoveCallback, MAPInvClickCallback, FALSE);
+		Blt8BPPDataTo16BPPBufferTransparent( pDestBuf, uiDestPitchBYTES, hCharListHandle, PLAYER_INFO_X, PLAYER_INFO_Y, 1);
+	}
+	else
+	{
+		InitializeInvPanelCoordsOld();
+		Blt8BPPDataTo16BPPBufferTransparent( pDestBuf, uiDestPitchBYTES, hCharListHandle, PLAYER_INFO_X, PLAYER_INFO_Y, 0);
+	}
+	UnLockVideoSurface( guiSAVEBUFFER ); 
 
+	Assert( pSoldier );
+	CreateDestroyMapInvButton();
+
 	if( gbCheckForMouseOverItemPos != -1 )
 	{
 		if( HandleCompatibleAmmoUIForMapScreen( pSoldier, (INT32)gbCheckForMouseOverItemPos, TRUE, TRUE ) == TRUE )
@@ -6813,31 +7347,36 @@
 	SetFontBackground( FONT_MCOLOR_BLACK );
 	SetFontForeground( MAP_INV_STATS_TITLE_FONT_COLOR );
 
-	// print armor/weight/camo labels
-  mprintf( MAP_ARMOR_LABEL_X, MAP_ARMOR_LABEL_Y, pInvPanelTitleStrings[ 0 ] );
-  mprintf( MAP_ARMOR_PERCENT_X, MAP_ARMOR_PERCENT_Y, L"%%" );
+	// CHRISL: Only display next three values if we're a merc
+//	if(!(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+	if(!(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+	{
+		// print armor/weight/camo labels
+		mprintf( MAP_ARMOR_LABEL_X, MAP_ARMOR_LABEL_Y, pInvPanelTitleStrings[ 0 ] );
+		mprintf( MAP_ARMOR_PERCENT_X, MAP_ARMOR_PERCENT_Y, L"%%" );
 
-  mprintf( MAP_WEIGHT_LABEL_X, MAP_WEIGHT_LABEL_Y, pInvPanelTitleStrings[ 1 ]  );
-  mprintf( MAP_WEIGHT_PERCENT_X, MAP_WEIGHT_PERCENT_Y, L"%%" );
- 
-	mprintf( MAP_CAMMO_LABEL_X, MAP_CAMMO_LABEL_Y, pInvPanelTitleStrings[ 2 ]  );
-  mprintf( MAP_CAMMO_PERCENT_X, MAP_CAMMO_PERCENT_Y, L"%%" );
+		mprintf( MAP_WEIGHT_LABEL_X, MAP_WEIGHT_LABEL_Y, pInvPanelTitleStrings[ 1 ]  );
+		mprintf( MAP_WEIGHT_PERCENT_X, MAP_WEIGHT_PERCENT_Y, L"%%" );
 
-	// display armor value
-	swprintf( sString, L"%3d", ArmourPercent( pSoldier ) );
-	FindFontRightCoordinates(MAP_ARMOR_X, MAP_ARMOR_Y, MAP_PERCENT_WIDTH, MAP_PERCENT_HEIGHT, sString, BLOCKFONT2, &usX, &usY);
-	mprintf( usX, usY, sString ); 
+		mprintf( MAP_CAMMO_LABEL_X, MAP_CAMMO_LABEL_Y, pInvPanelTitleStrings[ 2 ]  );
+		mprintf( MAP_CAMMO_PERCENT_X, MAP_CAMMO_PERCENT_Y, L"%%" );
 
-	// Display weight value
-	swprintf( sString, L"%3d", CalculateCarriedWeight( pSoldier ) );
-	FindFontRightCoordinates(MAP_WEIGHT_X, MAP_WEIGHT_Y, MAP_PERCENT_WIDTH, MAP_PERCENT_HEIGHT, sString, BLOCKFONT2, &usX, &usY);
-	mprintf( usX, usY, sString ); 
+		// display armor value
+		swprintf( sString, L"%3d", ArmourPercent( pSoldier ) );
+		FindFontRightCoordinates(MAP_ARMOR_X, MAP_ARMOR_Y, MAP_PERCENT_WIDTH, MAP_PERCENT_HEIGHT, sString, BLOCKFONT2, &usX, &usY);
+		mprintf( usX, usY, sString ); 
 
-	// Display camo value
-	swprintf( sString, L"%3d", max(0, min ((pSoldier->bCamo + pSoldier->wornCamo + pSoldier->urbanCamo+pSoldier->wornUrbanCamo+pSoldier->desertCamo+pSoldier->wornDesertCamo+pSoldier->snowCamo+pSoldier->wornSnowCamo ),100 )) );
-	FindFontRightCoordinates(MAP_CAMMO_X, MAP_CAMMO_Y, MAP_PERCENT_WIDTH, MAP_PERCENT_HEIGHT, sString, BLOCKFONT2, &usX, &usY);
-	mprintf( usX, usY, sString ); 
+		// Display weight value
+		swprintf( sString, L"%3d", CalculateCarriedWeight( pSoldier ) );
+		FindFontRightCoordinates(MAP_WEIGHT_X, MAP_WEIGHT_Y, MAP_PERCENT_WIDTH, MAP_PERCENT_HEIGHT, sString, BLOCKFONT2, &usX, &usY);
+		mprintf( usX, usY, sString ); 
 
+		// Display camo value
+		swprintf( sString, L"%3d", max(0, min ((pSoldier->bCamo + pSoldier->wornCamo + pSoldier->urbanCamo+pSoldier->wornUrbanCamo+pSoldier->desertCamo+pSoldier->wornDesertCamo+pSoldier->snowCamo+pSoldier->wornSnowCamo ),100 )) );
+		FindFontRightCoordinates(MAP_CAMMO_X, MAP_CAMMO_Y, MAP_PERCENT_WIDTH, MAP_PERCENT_HEIGHT, sString, BLOCKFONT2, &usX, &usY);
+		mprintf( usX, usY, sString ); 
+	}
+
 	if( InKeyRingPopup( ) )
 	{
 		// shade the background
@@ -6949,6 +7488,12 @@
 	return( fRet );
 }
 
+//CHRISL: functons for LBENODE system
+extern BOOLEAN MoveItemToLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj );
+extern BOOLEAN MoveItemFromLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj );
+extern BOOLEAN ChangeZipperStatus(SOLDIERTYPE *pSoldier, BOOLEAN newStatus);
+extern BOOLEAN CanItemFitInPosition( SOLDIERTYPE *pSoldier, OBJECTTYPE *pObj, INT8 bPos, BOOLEAN fDoingPlacement );
+
 // this is Map Screen's version of SMInvClickCallback()
 void MAPInvClickCallback( MOUSE_REGION *pRegion, INT32 iReason )
 {
@@ -6992,6 +7537,32 @@
 				CleanUpStack( &( pSoldier->inv[ uiHandPos ] ), NULL );
 			}
 
+			/* CHRISL: For New Inventory system.  Are we removing an existing LBE item?  If so, we need to pull
+			all items in the relevant IC Group pockets out of the soldiers inventory and put them into the LBE items
+			inventory. But first, find out if we already have a LBE item inventory for this item and this merc.  If we 
+			do, remove the items from it and place them into the sector the LBE inventory is located in.*/
+			if(gGameOptions.ubInventorySystem && !(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+			{
+				if(uiHandPos == VESTPOCKPOS || uiHandPos == LTHIGHPOCKPOS || uiHandPos == RTHIGHPOCKPOS || uiHandPos == CPACKPOCKPOS || uiHandPos == BPACKPOCKPOS)
+				{
+					/*if we pick up a backpack without reactivating the drop pack button, and we have a
+					dropkey, reactivate the button*/
+					if(uiHandPos == BPACKPOCKPOS)
+					{
+						// Deal with the zipper before we do anything
+						if(pSoldier->ZipperFlag)
+							if(!ChangeZipperStatus(pSoldier, FALSE))
+								return;
+						// Do we still have a linked backpack?  If so, reset droppackflag
+						if(pSoldier->DropPackKey != ITEM_NOT_FOUND)
+						{
+							pSoldier->DropPackFlag = TRUE;
+						}
+					}
+					MoveItemToLBEItem( pSoldier, uiHandPos, gpItemPointer );
+				}
+			}
+
 			// remember what it was
 			usOldItemIndex = pSoldier->inv[ uiHandPos ].usItem;
 
@@ -7036,8 +7607,11 @@
 			// !!! ATTACHING/MERGING ITEMS IN MAP SCREEN IS NOT SUPPORTED !!!
 			if ( uiHandPos == HANDPOS || uiHandPos == SECONDHANDPOS || uiHandPos == HELMETPOS || uiHandPos == VESTPOS || uiHandPos == LEGPOS )
 			{
+				if(gGameOptions.ubInventorySystem && !(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+				{
+				}
 				//if ( ValidAttachmentClass( usNewItemIndex, usOldItemIndex ) )
-				if ( ValidAttachment( usNewItemIndex, usOldItemIndex ) )
+				else if ( ValidAttachment( usNewItemIndex, usOldItemIndex ) )
 				{
 					// it's an attempt to attach; bring up the inventory panel
 					if ( !InItemDescriptionBox( ) )
@@ -7068,6 +7642,34 @@
 				// else handle normally
 			}
 
+			/* CHRISL: For New Inventory system.  Are we swapping LBE Items?  We'll need to move any
+			items in the associated IC group pockets into a new LBENODE.  We'll have to check
+			whether we already have an LBENODE for this type of LBE item and, if so, remove
+			the items from it, place them in the LBE Items current sector, and delete the existing
+			LBENODE.  Then we need to know if the LBE Item in the cursor is an LBENODE
+			or just a normal OBJECTTYPE.  If it's an LBENODE, we need to move it's items into
+			the appropriate pockets for the soldier and then delete the LBENODE.*/
+			if(gGameOptions.ubInventorySystem && !(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+			{
+				if((uiHandPos == VESTPOCKPOS || uiHandPos == LTHIGHPOCKPOS || uiHandPos == RTHIGHPOCKPOS || uiHandPos == CPACKPOCKPOS || uiHandPos == BPACKPOCKPOS) && CanItemFitInPosition(pSoldier, gpItemPointer, uiHandPos, FALSE))
+				{
+					//If we put a new pack in the backpack pocket, turn off the droppack button
+					if(uiHandPos == BPACKPOCKPOS)
+					{
+						// First, deal with the zipper
+						if(pSoldier->ZipperFlag)
+							if(!ChangeZipperStatus(pSoldier, FALSE))
+								return;
+						if(pSoldier->DropPackFlag)
+							pSoldier->DropPackFlag = FALSE;
+					}
+					// Are we swaping LBE items?
+					if(pSoldier->inv[uiHandPos].usItem != NONE)	// Item already exists in this pocket
+						MoveItemToLBEItem( pSoldier, uiHandPos, gpItemPointer );
+					MoveItemFromLBEItem( pSoldier, uiHandPos, gpItemPointer );
+				}
+			}
+
 			// Else, try to place here
 			if ( PlaceObject( pSoldier, (UINT8)uiHandPos, gpItemPointer ) )
 			{
@@ -7138,11 +7740,14 @@
 
 		// Some global stuff here - for esc, etc
 		// Check for # of slots in item
-		if ( ( pSoldier->inv[ uiHandPos ].ubNumberOfObjects > 1 ) && ( ItemSlotLimit( pSoldier->inv[ uiHandPos ].usItem, (UINT8)uiHandPos ) > 0 ) )
+		// CHRISL: Use new ItemSlotLimit function if we're using the new inventory system
+		UINT8 isLimit = (!gGameOptions.ubInventorySystem) ? ItemSlotLimit(pSoldier->inv[ uiHandPos ].usItem, (UINT16)uiHandPos) : ItemSlotLimit(&pSoldier->inv[uiHandPos], (UINT16)uiHandPos, pSoldier);
+		if ( ( pSoldier->inv[ uiHandPos ].ubNumberOfObjects > 1 ) && ( isLimit > 0 ) )
 		{
 			if ( !InItemStackPopup( ) )
 			{
-				InitItemStackPopup( pSoldier, (UINT8)uiHandPos, 0, INV_REGION_Y, 261, 248 );
+				// CHRISL: Changed final parameter so that we fill the inventory screen
+				InitItemStackPopup( pSoldier, (UINT8)uiHandPos, 0, INV_REGION_Y, 261, ( SCREEN_HEIGHT - PLAYER_INFO_Y ) );
 			  fTeamPanelDirty=TRUE;
 			  fInterfacePanelDirty = DIRTYLEVEL2;
 			}
@@ -7537,6 +8142,11 @@
 	// render map
   RenderMapRegionBackground( );
 	
+	// Headrock: Moved the following line here from the marker below, so that the Inventory Bottom panel
+	// renders underneath the character info panel (and so doesn't truncate the large open inventory). We may
+	// need to put TRUE here if there's any problem, but I doubt it.
+	RenderMapScreenInterfaceBottom( FALSE );
+ 
 	if( fDisableDueToBattleRoster == FALSE )
 	{
 	  // render team
@@ -7557,7 +8167,8 @@
 	}
 
 	// now render lower panel
-	RenderMapScreenInterfaceBottom( );
+	// HEADROCK - Moved the following line upwards, so it renders BEFORE the character info panel.
+	// RenderMapScreenInterfaceBottom( );
 }
 
 void CreateMouseRegionsForTeamList( void )
@@ -8735,8 +9346,27 @@
 	
 	// restore background for area
 	
-	RestoreExternBackgroundRect( 0, 107, 261, SCREEN_HEIGHT - 106 - 121 );
+	// HEADROCK: Character Panel rerender size depends on whether the inventory is open or closed. I shrink it
+	// when it's closed so that it doesn't distort the message log, and grow it when it's open so that it shows
+	// at full length. Very tricky business.
+	// Please rewrite this though, because I added a hotfix to deal with higher resolutions. In 1024x768, if 
+	// the height is set at SCREEN_HEIGHT - 107 , the program fails to draw the message log. This is intentional
+	// in 800x600, but because we're using the same inventory for higher resolutions, it simply isn't long enough 
+	// to cover the fact that the message log is not rendering, so the rectangle must be shortened to exclude the
+	// height of the inventory bottom (121 pixels). Also will require a change for 640x480, but I can't run the 
+	// game at that resolution with our new slots enabled, so I can't test it. Note that it may be wise to replace
+	// SCREEN_HEIGHT here with a proper constant that dictates the vertical inventory height. Or maybe not. Works
+	// fine this way as well.
 
+	if (fShowInventoryFlag == TRUE && SCREEN_HEIGHT == 600)
+	{
+		RestoreExternBackgroundRect( 0, 107, 261, SCREEN_HEIGHT - 107 );
+	}
+
+	if (fShowInventoryFlag == FALSE || SCREEN_HEIGHT > 600)
+	{
+		RestoreExternBackgroundRect( 0, 107, 261, SCREEN_HEIGHT - 107 - 121 );
+	}
 	MapscreenMarkButtonsDirty();
 
 	return;
@@ -10118,7 +10748,6 @@
 
 		// map inv done button
 		RemoveButton( giMapInvDoneButton );
-    
 		// get rid of button image
 		UnloadButtonImage( giMapInvButtonDoneImage );
 
@@ -13072,6 +13701,8 @@
 		}
 		else
 		{
+			// Headrock. New line forces InvBottom rerender when the inventory is opened and closed.
+			RenderMapScreenInterfaceBottom ( TRUE ); 
 			SetRegionFastHelpText( &gCharInfoHandRegion, pMiscMapScreenMouseRegionHelpText[ 0 ] );
 		}
 	}
Index: Strategic/mapscreen.h
===================================================================
--- Strategic/mapscreen.h	(revision 1299)
+++ Strategic/mapscreen.h	(working copy)
@@ -84,5 +84,9 @@
 
 BOOLEAN MapCharacterHasAccessibleInventory( INT8 bCharNumber );
 
+// CHRISL: New functions to handle initialization of inventory coordinates
+BOOLEAN InitializeInvPanelCoordsOld( );
+BOOLEAN InitializeInvPanelCoordsNew( );
+BOOLEAN InitializeInvPanelCoordsVehicle( );
 
-#endif
\ No newline at end of file
+#endif
Index: Strategic/PreBattle Interface.cpp
===================================================================
--- Strategic/PreBattle Interface.cpp	(revision 1299)
+++ Strategic/PreBattle Interface.cpp	(working copy)
@@ -396,7 +396,8 @@
 
 	fMapScreenBottomDirty = TRUE;
 	ChangeSelectedMapSector( gubPBSectorX, gubPBSectorY, gubPBSectorZ );
-	RenderMapScreenInterfaceBottom();
+	// Headrock: Added FALSE argument, We might need TRUE but not sure. Will need to initiate battle :)
+	RenderMapScreenInterfaceBottom( FALSE );
 
 	//If we are currently in tactical, then set the flag to automatically bring up the mapscreen.
 	if( guiCurrentScreen == GAME_SCREEN )
Index: Tactical/Arms Dealer Init.cpp
===================================================================
--- Tactical/Arms Dealer Init.cpp	(revision 1299)
+++ Tactical/Arms Dealer Init.cpp	(working copy)
@@ -967,6 +967,10 @@
 	//	case IC_APPLIABLE:
 			break;
 
+	// CHRISL: Itendify new class for inventory system
+		case IC_LBEGEAR:
+			return( 0 );
+			break;
 		default:
 			AssertMsg( FALSE, String( "GetArmsDealerItemTypeFromItemNumber(), invalid class %d for item %d.  DF 0.", Item[ usItem ].usItemClass, usItem ) );
 			break;
@@ -1561,7 +1565,7 @@
 			for ( ubCnt = 0; ubCnt < pObject->ubNumberOfObjects; ubCnt++ )
 			{
 				AddAmmoToArmsDealerInventory( ubArmsDealer, pObject->usItem, pObject->ItemData.Ammo.ubShotsLeft[ ubCnt ] );
-			}
+ 			}
 			break;
 
 		default:
Index: Tactical/ArmsDealerInvInit.cpp
===================================================================
--- Tactical/ArmsDealerInvInit.cpp	(revision 1299)
+++ Tactical/ArmsDealerInvInit.cpp	(working copy)
@@ -20,6 +20,7 @@
 extern INT8	gbSelectedArmsDealerID;
 
 
+// CHRISL: Updated this to include IC_LBEGEAR class
 // This table controls the order items appear in inventory at BR's and dealers, and which kinds of items are sold used
 ITEM_SORT_ENTRY DealerItemSortInfo[ ] =
 {
@@ -36,6 +37,7 @@
 	{ IC_BLADE,						NOGUNCLASS,		FALSE	},
 	{ IC_THROWING_KNIFE,	NOGUNCLASS,		FALSE	},
 	{ IC_PUNCH,						NOGUNCLASS,		FALSE	},
+	{ IC_LBEGEAR,					NOGUNCLASS,		TRUE	},
 	{ IC_ARMOUR,					NOGUNCLASS,		TRUE	},
 	{ IC_FACE,						NOGUNCLASS,		TRUE	},
 	{ IC_MEDKIT,					NOGUNCLASS,		FALSE	},
Index: Tactical/End Game.cpp
===================================================================
--- Tactical/End Game.cpp	(revision 1299)
+++ Tactical/End Game.cpp	(working copy)
@@ -183,13 +183,13 @@
 		{
 			if ( OK_INSECTOR_MERC( pTeamSoldier ) && !( pTeamSoldier->uiStatusFlags & SOLDIER_GASSED ) && !AM_AN_EPC( pTeamSoldier ) )
 			{
-				if ( QuoteExp_WitnessDeidrannaDeath[ pTeamSoldier->ubProfile ] )
-				{
+					if ( QuoteExp_WitnessDeidrannaDeath[ pTeamSoldier->ubProfile ] )
+					{
 					if ( SoldierTo3DLocationLineOfSightTest( pTeamSoldier, sGridNo,  bLevel, 3, TRUE, CALC_FROM_ALL_DIRS ) )
-					{
-						TacticalCharacterDialogue( pTeamSoldier, QUOTE_KILLING_DEIDRANNA );	
+						{
+							TacticalCharacterDialogue( pTeamSoldier, QUOTE_KILLING_DEIDRANNA );	
+						}
 					}
-				}
 			}
 		}
 	}
@@ -472,13 +472,13 @@
 		{
 			if ( OK_INSECTOR_MERC( pTeamSoldier ) && !( pTeamSoldier->uiStatusFlags & SOLDIER_GASSED ) && !AM_AN_EPC( pTeamSoldier ) )
 			{
-				if ( QuoteExp_WitnessQueenBugDeath[ pTeamSoldier->ubProfile ] )
-				{
+					if ( QuoteExp_WitnessQueenBugDeath[ pTeamSoldier->ubProfile ] )
+					{
 					if ( SoldierTo3DLocationLineOfSightTest( pTeamSoldier, sGridNo,  bLevel, 3, TRUE, CALC_FROM_ALL_DIRS ) )
-					{
-						TacticalCharacterDialogue( pTeamSoldier, QUOTE_KILLING_QUEEN );	
+						{
+							TacticalCharacterDialogue( pTeamSoldier, QUOTE_KILLING_QUEEN );	
+						}
 					}
-				}
 			}
 		}
 	}
Index: Tactical/Handle Items.cpp
===================================================================
--- Tactical/Handle Items.cpp	(revision 1299)
+++ Tactical/Handle Items.cpp	(working copy)
@@ -5379,22 +5379,54 @@
 			else
 			{
 				// Check, if we can steal the item
+				// CHRISL: Added new case definitions for new inventory pockets
 				switch (i)
 				{
-				case HANDPOS:
-				case SECONDHANDPOS:
-				case BIGPOCK1POS:
-				case BIGPOCK2POS:
-				case BIGPOCK3POS:
-				case BIGPOCK4POS:
-				case SMALLPOCK1POS:
-				case SMALLPOCK2POS:
-				case SMALLPOCK3POS:
-				case SMALLPOCK4POS:
-				case SMALLPOCK5POS:
-				case SMALLPOCK6POS:
-				case SMALLPOCK7POS:
-				case SMALLPOCK8POS:
+					case HANDPOS:
+					case SECONDHANDPOS:
+					case GUNSLINGPOCKPOS:
+					case KNIFEPOCKPOS:
+					case BIGPOCK1POS:
+					case BIGPOCK2POS:
+					case BIGPOCK3POS:
+					case BIGPOCK4POS:
+					case BIGPOCK5POS:
+					case BIGPOCK6POS:
+					case BIGPOCK7POS:
+					case MEDPOCK1POS:
+					case MEDPOCK2POS:
+					case MEDPOCK3POS:
+					case MEDPOCK4POS:
+					case SMALLPOCK1POS:
+					case SMALLPOCK2POS:
+					case SMALLPOCK3POS:
+					case SMALLPOCK4POS:
+					case SMALLPOCK5POS:
+					case SMALLPOCK6POS:
+					case SMALLPOCK7POS:
+					case SMALLPOCK8POS:
+					case SMALLPOCK9POS:
+					case SMALLPOCK10POS:
+					case SMALLPOCK11POS:
+					case SMALLPOCK12POS:
+					case SMALLPOCK13POS:
+					case SMALLPOCK14POS:
+					case SMALLPOCK15POS:
+					case SMALLPOCK16POS:
+					case SMALLPOCK17POS:
+					case SMALLPOCK18POS:
+					case SMALLPOCK19POS:
+					case SMALLPOCK20POS:
+					case SMALLPOCK21POS:
+					case SMALLPOCK22POS:
+					case SMALLPOCK23POS:
+					case SMALLPOCK24POS:
+					case SMALLPOCK25POS:
+					case SMALLPOCK26POS:
+					case SMALLPOCK27POS:
+					case SMALLPOCK28POS:
+					case SMALLPOCK29POS:
+					case SMALLPOCK30POS:
 					fStealItem = TRUE;
 					break;
 				default:
Index: Tactical/Handle UI.cpp
===================================================================
--- Tactical/Handle UI.cpp	(revision 1299)
+++ Tactical/Handle UI.cpp	(working copy)
@@ -1915,6 +1915,23 @@
 			// Get soldier
 			if ( GetSoldier( &pSoldier, gusSelectedSoldier )  )
 			{
+				// CHRISL: This block should only run if we're running in the new inventory system
+				if(gGameOptions.ubInventorySystem)
+				{
+					// CHRISL: If we're in combat and zipper is active, don't allow movement
+					if((gTacticalStatus.uiFlags & INCOMBAT) && pSoldier->ZipperFlag)
+					{
+						CHAR16 noPackText[STRING_LENGTH] = L"Can not move while backpack zipper active";
+						ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, noPackText );
+						return( GAME_SCREEN );
+					}
+					// CHRISL: If we're not in combat but the zipper is active and we're moving, deactivate the zipper
+					if(!(gTacticalStatus.uiFlags & INCOMBAT) && pSoldier->ZipperFlag)
+					{
+						pSoldier->ZipperFlag=FALSE;
+						RenderBackpackButtons(0);
+					}
+				}
 				// FOR REALTIME - DO MOVEMENT BASED ON STANCE!
 				if ( ( gTacticalStatus.uiFlags & REALTIME ) || !( gTacticalStatus.uiFlags & INCOMBAT ) )
 				{
@@ -4338,30 +4355,51 @@
 	bCurrentHeight = ( ubDesiredStance - gAnimControl[ pSoldier->usAnimState ].ubEndHeight );
 
 	// Now change to appropriate animation
-
+	// CHRISL: Modify function to include extra cost if wearing a backpack but only while running new inventory system
 	switch( bCurrentHeight )
 	{
 	case ANIM_STAND - ANIM_CROUCH:
+		if(gGameOptions.ubInventorySystem)
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && !pSoldier->ZipperFlag)
+				bAP = bBP = 1;
+		bAP += AP_CROUCH;
+		bBP += BP_CROUCH;
+		break;
 	case ANIM_CROUCH - ANIM_STAND:
-
-		bAP = AP_CROUCH;
-		bBP = BP_CROUCH;
+		if(gGameOptions.ubInventorySystem)
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && !pSoldier->ZipperFlag)
+				bAP = bBP = 2;
+		bAP += AP_CROUCH;
+		bBP += BP_CROUCH;
 		break;
-
 	case ANIM_STAND - ANIM_PRONE:
+		if(gGameOptions.ubInventorySystem)
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && !pSoldier->ZipperFlag)
+				bAP = bBP = 2;
+		bAP += AP_CROUCH + AP_PRONE;
+		bBP += BP_CROUCH + BP_PRONE;
+		break;
 	case ANIM_PRONE - ANIM_STAND:
-
-		bAP = AP_CROUCH + AP_PRONE;
-		bBP = BP_CROUCH + BP_PRONE;
+		if(gGameOptions.ubInventorySystem)
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && !pSoldier->ZipperFlag)
+				bAP = bBP = 4;
+		bAP += AP_CROUCH + AP_PRONE;
+		bBP += BP_CROUCH + BP_PRONE;
 		break;
-
 	case ANIM_CROUCH - ANIM_PRONE:
+		if(gGameOptions.ubInventorySystem)
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && !pSoldier->ZipperFlag)
+				bAP = bBP = 1;
+		bAP += AP_PRONE;
+		bBP += BP_PRONE;
+		break;
 	case ANIM_PRONE - ANIM_CROUCH:
-
-		bAP = AP_PRONE;
-		bBP = BP_PRONE;
+		if(gGameOptions.ubInventorySystem)
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && !pSoldier->ZipperFlag)
+				bAP = bBP = 2;
+		bAP += AP_PRONE;
+		bBP += BP_PRONE;
 		break;
-
 	}
 
 	return ( EnoughPoints( pSoldier, bAP, bBP , TRUE ) );
Index: Tactical/Interface Control.cpp
===================================================================
--- Tactical/Interface Control.cpp	(revision 1299)
+++ Tactical/Interface Control.cpp	(working copy)
@@ -67,7 +67,8 @@
 
 MOUSE_REGION		gLockPanelOverlayRegion;
 
-extern void			RenderTownIDString( );
+// CHRISL: Change function definition to allow passing of X,Y coords to control placement of TownID string
+extern void			RenderTownIDString( INT16 sX, INT16 sY );
 extern BOOLEAN	gfUIOverItemPool;
 extern INT16		gfUIOverItemPoolGridNo;
 extern BOOLEAN	gfInMovementMenu;
@@ -1055,4 +1056,4 @@
 	}
 
 	return( TRUE );
-}
\ No newline at end of file
+}
Index: Tactical/Interface Items.cpp
===================================================================
--- Tactical/Interface Items.cpp	(revision 1299)
+++ Tactical/Interface Items.cpp	(working copy)
@@ -108,12 +108,20 @@
 #define		ITEM_STATS_WIDTH					26
 #define		ITEM_STATS_HEIGHT					8
 
-#define		ITEMDESC_START_X					214
-#define		ITEMDESC_START_Y					1 + INV_INTERFACE_START_Y
-#define		ITEMDESC_HEIGHT					133
-#define		ITEMDESC_WIDTH					320
-#define   MAP_ITEMDESC_HEIGHT     268
-#define   MAP_ITEMDESC_WIDTH      272
+// CHRISL: Changed some coord defines to INT16s so we can adjust their value based on game options
+INT16	ITEMDESC_START_X;
+INT16	ITEMDESC_START_Y;
+INT16	ITEMDESC_HEIGHT;
+INT16	ITEMDESC_WIDTH;
+INT16   MAP_ITEMDESC_HEIGHT;
+INT16	MAP_ITEMDESC_WIDTH;
+
+//#define		ITEMDESC_START_X					214
+//#define		ITEMDESC_START_Y					1 + INV_INTERFACE_START_Y
+//#define		ITEMDESC_HEIGHT					133
+//#define		ITEMDESC_WIDTH					320
+//#define   MAP_ITEMDESC_HEIGHT     268
+//#define   MAP_ITEMDESC_WIDTH      272
 #define		ITEMDESC_NAME_X					(16 + gsInvDescX)
 #define		ITEMDESC_NAME_Y					(67 + gsInvDescY)
 #define		ITEMDESC_CALIBER_X			(162 + gsInvDescX)
@@ -210,10 +218,15 @@
 #define BAD_REPAIR_EASE							-2	
 #define BAD_ACCURACY							-1	
 
-#define KEYRING_X 487
-#define KEYRING_Y (105 + INV_INTERFACE_START_Y)
-#define MAP_KEYRING_X 217
-#define MAP_KEYRING_Y 271
+// CHRISL: Adjust coords for layout changes needed for new inventory system
+extern int KEYRING_X;
+extern int KEYRING_Y;
+extern int MAP_KEYRING_X;
+extern int MAP_KEYRING_Y;
+//#define KEYRING_X 487
+//#define KEYRING_Y (105 + INV_INTERFACE_START_Y)
+//#define MAP_KEYRING_X 217
+//#define MAP_KEYRING_Y 271
 #define KEYRING_WIDTH 30
 #define KEYRING_HEIGHT 24
 #define TACTICAL_INVENTORY_KEYRING_GRAPHIC_OFFSET_X 215
@@ -324,6 +337,9 @@
 #define			NUMBER_KEYS_ON_KEYRING 28
 #define			KEY_RING_ROW_WIDTH 7
 #define			MAP_KEY_RING_ROW_WIDTH 4
+// CHRISL:
+#define			INV_ITEM_ROW_WIDTH 7
+#define			MAP_INV_ITEM_ROW_WIDTH 6
 
 // ITEM STACK POPUP STUFF
 BOOLEAN			gfInItemStackPopup = FALSE;
@@ -527,30 +543,10 @@
 BOOLEAN gfItemDescHelpTextOffset = FALSE;
 
 // ARRAY FOR INV PANEL INTERFACE ITEM POSITIONS (sX,sY get set via InitInvSlotInterface() )
-INV_REGIONS gSMInvData[] = 
-{
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		HEAD_INV_SLOT_WIDTH,	HEAD_INV_SLOT_HEIGHT,		0,	0,			// HELMETPOS
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,		0,	0,			// VESTPOS
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		LEGS_INV_SLOT_WIDTH,	LEGS_INV_SLOT_HEIGHT,		0,	0,			// LEGPOS,
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// HEAD1POS
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// HEAD2POS
-	TRUE,		INV_BAR_DX,		INV_BAR_DY,		BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,		0,	0,			// HANDPOS,
-	TRUE,		INV_BAR_DX,		INV_BAR_DY,		BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,		0,	0,			// SECONDHANDPOS
-	TRUE,		INV_BAR_DX,		INV_BAR_DY,		BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,		0,	0,			// BIGPOCK1
-	TRUE,		INV_BAR_DX,		INV_BAR_DY,		BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,		0,	0,			// BIGPOCK2
-	TRUE,		INV_BAR_DX,		INV_BAR_DY,		BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,		0,	0,			// BIGPOCK3
-	TRUE,		INV_BAR_DX,		INV_BAR_DY,		BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,		0,	0,			// BIGPOCK4
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK1
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK2
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK3
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK4
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK5
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK6
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0,			// SMALLPOCK7
-	FALSE,		INV_BAR_DX,		INV_BAR_DY,		SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,			0,	0				// SMALLPOCK8
-};
+/* CHRISL: Add new region definitions for the new inventory slots needed for the new inventory
+system to work properly. */
+INV_REGIONS gSMInvData[NUM_INV_SLOTS];
 
-
 typedef struct
 {
 	UINT32	uiTotalAmount;
@@ -849,20 +845,150 @@
 	}
 }
 
+// CHRISL: New function to setup GSMInvData based on game options
+void InitInvData(INT8 num, BOOLEAN fBigPocket, INT16 sBarDx, INT16 sBarDy, INT16 sWidth, INT16 sHeight, INT16 sX, INT16 sY)
+{
+	gSMInvData[num].fBigPocket = fBigPocket;
+	gSMInvData[num].sBarDx = sBarDx;
+	gSMInvData[num].sBarDy = sBarDy;
+	gSMInvData[num].sHeight = sHeight;
+	gSMInvData[num].sWidth = sWidth;
+	gSMInvData[num].sX = sX;
+	gSMInvData[num].sY = sY;
+}
+void InitInventoryOld()
+{
+	InitInvData(HELMETPOS,		FALSE,	INV_BAR_DX,	INV_BAR_DY,	HEAD_INV_SLOT_WIDTH,	HEAD_INV_SLOT_HEIGHT,	0, 0);	// HELMETPOS
+	InitInvData(VESTPOS,		FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// VESTPOS
+	InitInvData(LEGPOS,			FALSE,	INV_BAR_DX,	INV_BAR_DY,	LEGS_INV_SLOT_WIDTH,	LEGS_INV_SLOT_HEIGHT,	0, 0);	// LEGPOS
+	InitInvData(HEAD1POS,		FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// HEAD1POS
+	InitInvData(HEAD2POS,		FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// HEAD2POS
+	InitInvData(HANDPOS,		TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// HANDPOS
+	InitInvData(SECONDHANDPOS,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// SECONDHANDPOS
+	InitInvData(BIGPOCK1POS,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK1
+	InitInvData(BIGPOCK2POS,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK2
+	InitInvData(BIGPOCK3POS,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK3
+	InitInvData(BIGPOCK4POS,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK4
+	InitInvData(SMALLPOCK1POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK1
+	InitInvData(SMALLPOCK2POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK2
+	InitInvData(SMALLPOCK3POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK3
+	InitInvData(SMALLPOCK4POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK4
+	InitInvData(SMALLPOCK5POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK5
+	InitInvData(SMALLPOCK6POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK6
+	InitInvData(SMALLPOCK7POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK7
+	InitInvData(SMALLPOCK8POS,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK8
+}
+void InitInventoryNew()
+{
+	InitInvData(0,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	HEAD_INV_SLOT_WIDTH,	HEAD_INV_SLOT_HEIGHT,	0, 0);	// HELMETPOS
+	InitInvData(1,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// VESTPOS
+	InitInvData(2,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	LEGS_INV_SLOT_WIDTH,	LEGS_INV_SLOT_HEIGHT,	0, 0);	// LEGPOS
+	InitInvData(3,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// HEAD1POS
+	InitInvData(4,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// HEAD2POS
+	InitInvData(5,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// HANDPOS
+	InitInvData(6,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// SECONDHANDPOS
+	InitInvData(7,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// VESTPOCKPOS
+	InitInvData(8,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// LTHIGHPOCKPOS
+	InitInvData(9,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// RTHIGHPOCKPOS
+	InitInvData(10,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// CPACKPOCKPOS
+	InitInvData(11,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// BPACKPOCKPOS
+	InitInvData(12,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// GUNSLINGPOCKPOS
+	InitInvData(13,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// KNIFEPOCKPOS
+	InitInvData(14,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK1
+	InitInvData(15,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK2
+	InitInvData(16,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK3
+	InitInvData(17,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK4
+	InitInvData(18,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK5
+	InitInvData(19,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK6
+	InitInvData(20,	TRUE,	INV_BAR_DX,	INV_BAR_DY,	BIG_INV_SLOT_WIDTH,		BIG_INV_SLOT_HEIGHT,	0, 0);	// BIGPOCK7
+	InitInvData(21,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// MEDPOCK1
+	InitInvData(22,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// MEDPOCK2
+	InitInvData(23,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// MEDPOCK3
+	InitInvData(24,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	VEST_INV_SLOT_WIDTH,	VEST_INV_SLOT_HEIGHT,	0, 0);	// MEDPOCK4
+	InitInvData(25,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK1
+	InitInvData(26,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK2
+	InitInvData(27,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK3
+	InitInvData(28,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK4
+	InitInvData(29,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK5
+	InitInvData(30,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK6
+	InitInvData(31,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK7
+	InitInvData(32,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK8
+	InitInvData(33,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK9
+	InitInvData(34,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK10
+	InitInvData(35,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK11
+	InitInvData(36,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK12
+	InitInvData(37,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK13
+	InitInvData(38,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK14
+	InitInvData(39,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK15
+	InitInvData(40,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK16
+	InitInvData(41,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK17
+	InitInvData(42,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK18
+	InitInvData(43,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK19
+	InitInvData(44,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK20
+	InitInvData(45,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK21
+	InitInvData(46,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK22
+	InitInvData(47,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK23
+	InitInvData(48,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK24
+	InitInvData(49,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK25
+	InitInvData(50,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK26
+	InitInvData(51,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK27
+	InitInvData(52,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK28
+	InitInvData(53,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK29
+	InitInvData(54,	FALSE,	INV_BAR_DX,	INV_BAR_DY,	SM_INV_SLOT_WIDTH,		SM_INV_SLOT_HEIGHT,		0, 0);	// SMALLPOCK30
+}
+void InitInventoryVehicle(INV_REGION_DESC *pRegionDesc, MOUSE_CALLBACK INVMoveCallback, MOUSE_CALLBACK INVClickCallback, BOOLEAN fSetHighestPrioity)
+{
+	int cnt;
+
+	for(cnt=0; cnt<NUM_INV_SLOTS; cnt++)
+	{
+		MSYS_RemoveRegion( &gSMInvRegion[ cnt ]);
+		if(vehicleInv[cnt])
+			InitInvData(cnt, TRUE, INV_BAR_DX, INV_BAR_DY, BIG_INV_SLOT_WIDTH, BIG_INV_SLOT_HEIGHT, pRegionDesc[cnt].sX, pRegionDesc[cnt].sY);
+		else
+			InitInvData(cnt, TRUE, INV_BAR_DX, INV_BAR_DY, BIG_INV_SLOT_WIDTH, BIG_INV_SLOT_HEIGHT, 0, 0);
+		MSYS_DefineRegion( &gSMInvRegion[ cnt ], gSMInvData[ cnt ].sX, gSMInvData[ cnt ].sY, (INT16)(gSMInvData[ cnt ].sX + gSMInvData[ cnt ].sWidth), (INT16)(gSMInvData[ cnt ].sY + gSMInvData[ cnt ].sHeight), ( INT8 )( fSetHighestPrioity ? MSYS_PRIORITY_HIGHEST : MSYS_PRIORITY_HIGH ),
+							 MSYS_NO_CURSOR, INVMoveCallback, INVClickCallback ); 
+		// Add region
+		MSYS_AddRegion( &gSMInvRegion[ cnt ] );
+		MSYS_SetRegionUserData( &gSMInvRegion[ cnt ], 0, cnt );
+	}
+}
+// CHRISL: Function to recreate inventory mouse regions
+void ResetMapInvRegions(INV_REGION_DESC *pRegionDesc, MOUSE_CALLBACK INVMoveCallback, MOUSE_CALLBACK INVClickCallback, BOOLEAN fSetHighestPrioity)
+{
+	for(int cnt=0; cnt<NUM_INV_SLOTS; cnt++)
+	{
+		MSYS_RemoveRegion( &gSMInvRegion[ cnt ]);
+		MSYS_DefineRegion( &gSMInvRegion[ cnt ], gSMInvData[ cnt ].sX, gSMInvData[ cnt ].sY, (INT16)(gSMInvData[ cnt ].sX + gSMInvData[ cnt ].sWidth), (INT16)(gSMInvData[ cnt ].sY + gSMInvData[ cnt ].sHeight), ( INT8 )( fSetHighestPrioity ? MSYS_PRIORITY_HIGHEST : MSYS_PRIORITY_HIGH ),
+							 MSYS_NO_CURSOR, INVMoveCallback, INVClickCallback ); 
+		// Add region
+		MSYS_AddRegion( &gSMInvRegion[ cnt ] );
+		MSYS_SetRegionUserData( &gSMInvRegion[ cnt ], 0, cnt );
+	}
+}
+
 BOOLEAN InitInvSlotInterface( INV_REGION_DESC *pRegionDesc , INV_REGION_DESC *pCamoRegion, MOUSE_CALLBACK INVMoveCallback, MOUSE_CALLBACK INVClickCallback, MOUSE_CALLBACK INVMoveCammoCallback, MOUSE_CALLBACK INVClickCammoCallback, BOOLEAN fSetHighestPrioity )
 {
 	INT32 cnt;
-  VOBJECT_DESC    VObjectDesc;
+	VOBJECT_DESC    VObjectDesc;
 	
-/*
- *  Ok i think that here the money button and window is initialized 
- *  so we also will initialize here coord of button
- *  this function is called in tactical screen when SMPanel is initialized 
- *  and also in StrategicScreen i think i didnt check it. 
- *  any questions? joker
- */
+	/*
+	*  Ok i think that here the money button and window is initialized 
+	*  so we also will initialize here coord of button
+	*  this function is called in tactical screen when SMPanel is initialized 
+	*  and also in StrategicScreen i think i didnt check it. 
+	*  any questions? joker
+	*/
 
-	gMoneyButtonLoc.x = (343 + INTERFACE_START_X);
+	// CHRISL: Initialize gSMInvData based on inventory system
+	if(gGameOptions.ubInventorySystem)
+		InitInventoryNew();
+	else
+		InitInventoryOld();
+	
+	// CHRISL: Adjusted location of the Money button on the tactical inventory screen
+	gMoneyButtonLoc.x = (!gGameOptions.ubInventorySystem) ? (343 + INTERFACE_START_X) : (244 + INTERFACE_START_X);
 	gMoneyButtonLoc.y = ( 11 + INV_INTERFACE_START_Y );
 	// Load all four body type images
 	VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
@@ -1000,6 +1126,7 @@
 
 		MSYS_DisableRegion( &gSM_SELMERCMoneyRegion );			
 		EnableKeyRing( FALSE );
+		RenderBackpackButtons(3);	/* CHRISL: Needed for new inventory backpack buttons */
 	}
 	else
 	{
@@ -1007,6 +1134,7 @@
 
 		MSYS_EnableRegion( &gSM_SELMERCMoneyRegion );			
 		EnableKeyRing( TRUE );
+		RenderBackpackButtons(2);	/* CHRISL: Needed for new inventory backpack buttons */
 	}
 	
 }
@@ -1065,8 +1193,8 @@
 
 void HandleRenderInvSlots( SOLDIERTYPE *pSoldier, UINT8 fDirtyLevel )
 {
-	INT32									cnt;
-	static CHAR16					pStr[ 512 ]; 
+	INT32			cnt, sX, sY;
+	static CHAR16	pStr[ 512 ]; 
 
 	if ( InItemDescriptionBox( ) || InItemStackPopup( ) || InKeyRingPopup( ) )
 	{
@@ -1099,32 +1227,73 @@
 		if ( KeyExistsInKeyRing( pSoldier, ANYKEY, NULL ) )
 		{
 			// blit gold key here?
+			// CHRISL: adjust settings to use variables for coords
 			if ( guiCurrentItemDescriptionScreen != MAP_SCREEN )
 			{
-				BltVideoObjectFromIndex( guiSAVEBUFFER, guiGoldKeyVO, 0, 496, KEYRING_Y + 1, VO_BLT_SRCTRANSPARENCY, NULL );
-				RestoreExternBackgroundRect( 496, KEYRING_Y + 1, 29, 23 );
+				sX=(!gGameOptions.ubInventorySystem)?496:221;
+				sY=(!gGameOptions.ubInventorySystem)?INV_INTERFACE_START_Y+106:INV_INTERFACE_START_Y+5;
 			}
 			else
 			{
-				BltVideoObjectFromIndex( guiSAVEBUFFER, guiGoldKeyVO, 0, 217, 271, VO_BLT_SRCTRANSPARENCY, NULL );
-				RestoreExternBackgroundRect( 217, 271, 29, 23 );
+				sX=(!gGameOptions.ubInventorySystem)?217:188;
+				sY=(!gGameOptions.ubInventorySystem)?271:126;
 			}
+			BltVideoObjectFromIndex( guiSAVEBUFFER, guiGoldKeyVO, 0, sX, sY, VO_BLT_SRCTRANSPARENCY, NULL );
+			RestoreExternBackgroundRect( sX, sY, 29, 23 );
 		}
 	}	
 }
 
+// CHRISL: New function to determine whether to activate Combat and Backpack slots
+BOOLEAN CheckActivationStatus(SOLDIERTYPE *pSoldier, INT16 cSlot, INT16 bSlot, INT16 sPocket)
+{
+	INT8	cLevel, bLevel;
 
+	cLevel = LoadBearingEquipment[Item[pSoldier->inv[cSlot].usItem].ubClassIndex].lbeCombo;
+	bLevel = LoadBearingEquipment[Item[pSoldier->inv[bSlot].usItem].ubClassIndex].lbeCombo;
+	
+	if(sPocket==cSlot)
+	{
+		if(pSoldier->inv[bSlot].usItem != NOTHING)
+		{
+			if(bLevel == NOTHING)
+			{
+				return(TRUE);
+			}
+		}
+	}
+	if(sPocket==bSlot)
+	{
+		if(pSoldier->inv[cSlot].usItem != NOTHING)
+		{
+			if(cLevel == NOTHING)
+			{
+				return(TRUE);
+			}
+		}
+	}
+	return(FALSE);
+}
+
+/* CHRISL: This function needed to be reworked so that inactive pockets would be properly "hatched" and so
+that active, empty pockets will display the appropriate background silhouette. */
+extern BOOLEAN CanItemFitInPosition( SOLDIERTYPE *pSoldier, OBJECTTYPE *pObj, INT8 bPos, BOOLEAN fDoingPlacement );
 void INVRenderINVPanelItem( SOLDIERTYPE *pSoldier, INT16 sPocket, UINT8 fDirtyLevel )
 {
-	INT16 sX, sY;
+	INT16 sX, sY, newX, newY;
 	INT16	sBarX, sBarY;
 	OBJECTTYPE  *pObject;
 	BOOLEAN	fOutline = FALSE;
-	INT16		sOutlineColor = 0;
+	INT16		sOutlineColor = 0, lbePocket = ITEM_NOT_FOUND;
 	UINT8		fRenderDirtyLevel;
 	BOOLEAN fHatchItOut = FALSE;
+	UINT32		iClass;
 
-
+	// CHRISL: Only run if we're looking at a legitimate pocket
+	if(!gGameOptions.ubInventorySystem && !oldInv[sPocket])
+		return;
+	if((pSoldier->uiStatusFlags & SOLDIER_VEHICLE) && !vehicleInv[sPocket])
+		return;
 	//Assign the screen
 	guiCurrentItemDescriptionScreen = guiCurrentScreen;
 
@@ -1133,6 +1302,78 @@
 	sX = gSMInvData[ sPocket ].sX;
 	sY = gSMInvData[ sPocket ].sY;
 
+	if(gGameOptions.ubInventorySystem && !(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+	{
+		// If sPocket is not an equiped pocket, gather pocket information
+		if(icClass[sPocket] != ITEM_NOT_FOUND)
+		{
+			switch (icClass[sPocket])
+			{
+				case THIGH_PACK:
+				case VEST_PACK:
+				case COMBAT_PACK:
+				case BACKPACK:
+					lbePocket = (pSoldier->inv[icLBE[sPocket]].usItem == NOTHING) ? LoadBearingEquipment[icClass[sPocket]].lbePocketIndex[icPocket[sPocket]] : LoadBearingEquipment[Item[pSoldier->inv[icLBE[sPocket]].usItem].ubClassIndex].lbePocketIndex[icPocket[sPocket]];
+					iClass = Item[pSoldier->inv[sPocket].usItem].usItemClass;
+					if(icLBE[sPocket] == BPACKPOCKPOS && !(pSoldier->ZipperFlag) && (gTacticalStatus.uiFlags & INCOMBAT))
+						lbePocket = 0;
+					if (lbePocket == 0)	// Deactivate Pocket
+					{
+						fHatchItOut = TRUE;
+					}
+					else if ( pObject->usItem == NOTHING )	// Nothing in sPocket.  Display silouhette.
+					{
+						INVRenderSilhouette( guiSAVEBUFFER, lbePocket, 0, sX, sY, gSMInvData[ sPocket ].sWidth, gSMInvData[ sPocket ].sHeight);
+					}
+					break;
+				case LBE_POCKET:
+					if ( pObject->usItem == NOTHING )
+					{
+						if ( sPocket == VESTPOCKPOS )
+							lbePocket = 0;
+						else if ( sPocket == LTHIGHPOCKPOS )
+							lbePocket = 1;
+						else if ( sPocket == RTHIGHPOCKPOS )
+							lbePocket = 2;
+						else if ( sPocket == CPACKPOCKPOS )
+							lbePocket = 3;
+						else if ( sPocket == BPACKPOCKPOS )
+							lbePocket = 4;
+						if ( lbePocket != ITEM_NOT_FOUND )
+							INVRenderSilhouette( guiSAVEBUFFER, ITEM_NOT_FOUND, lbePocket, sX, sY, gSMInvData[ sPocket ].sWidth, gSMInvData[ sPocket ].sHeight);
+					}
+					// Removed backpack/gunsling restrictions
+					if ( CheckActivationStatus(pSoldier, CPACKPOCKPOS, BPACKPOCKPOS, sPocket)/* ||
+						(sPocket == BPACKPOCKPOS && pSoldier->inv[GUNSLINGPOCKPOS].usItem != NOTHING)*/)
+					{
+						fHatchItOut = TRUE;
+					}
+					break;
+				case OTHER_POCKET:
+					if ( pObject->usItem == NOTHING )
+					{
+						if ( sPocket == GUNSLINGPOCKPOS ) // Gun Sling
+							lbePocket = 1;
+						else
+							lbePocket = 2;
+						INVRenderSilhouette( guiSAVEBUFFER, lbePocket, 0, sX, sY, gSMInvData[ sPocket ].sWidth, gSMInvData[ sPocket ].sHeight);
+					}
+					// Removed backpack/gunsling restrictions
+					//if(sPocket == GUNSLINGPOCKPOS && pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING)
+					//{
+					//	fHatchItOut = TRUE;
+					//}
+					break;
+				default:
+					if ( pObject->usItem == NOTHING )
+					{
+						// Display appropriate silouhette
+					}
+					break;
+			}
+		}
+	}
+
 	if ( fDirtyLevel == DIRTYLEVEL2 )
 	{
 		// CHECK FOR COMPATIBILITY WITH MAGAZINES
@@ -1179,15 +1420,20 @@
 		if (sPocket == SECONDHANDPOS && Item[pSoldier->inv[HANDPOS].usItem].twohanded )
 		{
 //			if( guiCurrentScreen != MAP_SCREEN )
+			// CHRISL: Change coords for STI that covers 2nd hand location when carrying a 2handed weapon
 			if( guiCurrentItemDescriptionScreen != MAP_SCREEN )
 			{
-				BltVideoObjectFromIndex( guiSAVEBUFFER, guiSecItemHiddenVO, 0, 217, sY, VO_BLT_SRCTRANSPARENCY, NULL );
-				RestoreExternBackgroundRect( 217, sY, 72, 28 );
+				newX = (!gGameOptions.ubInventorySystem) ? 217 : 114;
+				newY = (!gGameOptions.ubInventorySystem) ? sY : (sY - 1);
+				BltVideoObjectFromIndex( guiSAVEBUFFER, guiSecItemHiddenVO, gGameOptions.ubInventorySystem, newX, newY, VO_BLT_SRCTRANSPARENCY, NULL );
+				RestoreExternBackgroundRect( newX, newY, 72, 28 );
 			}
 			else
 			{
-				BltVideoObjectFromIndex( guiSAVEBUFFER, guiMapInvSecondHandBlockout, 0, 14, 218, VO_BLT_SRCTRANSPARENCY, NULL );
-				RestoreExternBackgroundRect( 14, 218, 102, 24 );
+				newX = (!gGameOptions.ubInventorySystem) ? 14 : 6;
+				newY = (!gGameOptions.ubInventorySystem) ? 218 : 217;
+				BltVideoObjectFromIndex( guiSAVEBUFFER, guiMapInvSecondHandBlockout, gGameOptions.ubInventorySystem, newX, newY, VO_BLT_SRCTRANSPARENCY, NULL );
+				RestoreExternBackgroundRect( newX, newY, 102, 24 );
 			}
 		}		
 	}
@@ -1207,8 +1453,33 @@
 	//INVRenderItem( guiSAVEBUFFER, pObject, (INT16)(sX + gSMInvData[ sPocket ].sSubX), (INT16)(sY + gSMInvData[ sPocket ].sSubY), gSMInvData[ sPocket ].sWidth, gSMInvData[ sPocket ].sHeight, fDirtyLevel, &(gfSM_HandInvDispText[ sPocket ] ) );
 	INVRenderItem( guiSAVEBUFFER, pSoldier, pObject, sX, sY, gSMInvData[ sPocket ].sWidth, gSMInvData[ sPocket ].sHeight, fRenderDirtyLevel, NULL, 0, fOutline, sOutlineColor );
 
-	if ( gbInvalidPlacementSlot[ sPocket ] )
+	// CHRISL: Display pocket capacity if we're holding something in the cursor
+	if (!gfSMDisableForItems && gGameOptions.ubInventorySystem && gpItemPointer != NULL)
 	{
+		RenderPocketItemCapacity( ItemSlotLimit(gpItemPointer, sPocket, pSoldier), sPocket, pSoldier);
+		if(ItemSlotLimit(gpItemPointer, sPocket, pSoldier)==0 || !CanItemFitInPosition(pSoldier, gpItemPointer, (INT8)sPocket, FALSE))
+			fHatchItOut = TRUE;
+	}
+
+	// CHRISL: Change whether we hatch a pocket to be dependant on the current item
+	if(gpItemPointer != NULL)
+	{
+		if(!gfSMDisableForItems && !CanItemFitInPosition(pSoldier, gpItemPointer, (INT8)sPocket, FALSE))
+			fHatchItOut = TRUE;
+	}
+	else if(pObject->usItem != NOTHING)
+	{
+		if(!gfSMDisableForItems && !CanItemFitInPosition(pSoldier, pObject, (INT8)sPocket, FALSE))
+			fHatchItOut = TRUE;
+	}
+	// CHRISL: Don't hatch second hand position if we're holding a two handed item
+	if(sPocket == SECONDHANDPOS)
+	{
+		if(Item[pSoldier->inv[HANDPOS].usItem].twohanded)
+			fHatchItOut = FALSE;
+	}
+/*	if ( gbInvalidPlacementSlot[ sPocket ] )
+	{
 		if ( sPocket != SECONDHANDPOS )
 		{
 			// If we are in inv panel and our guy is not = cursor guy...
@@ -1217,7 +1488,7 @@
 				fHatchItOut = TRUE;
 			}
 		}
-	}
+	}*/
 
 	//if we are in the shop keeper interface
 	if( guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE )
@@ -2004,7 +2275,86 @@
 
 }
 
+// CHRISL: Function to display pocket inventory quantity based on object in cursor
+void RenderPocketItemCapacity( INT8 pCapacity, INT16 bPos, SOLDIERTYPE *pSoldier )
+{
+	INT16				sX, sY;
+	static CHAR16		pStr[ 100 ];
 
+	// Can pocket hold the item in the cursor?
+	if(!CanItemFitInPosition( pSoldier, gpItemPointer, (INT8)bPos, FALSE ) || (pCapacity == 0 && !CompatibleAmmoForGun(gpItemPointer, &pSoldier->inv[bPos])) || InItemDescriptionBox( ))
+		return;
+
+	// Setup display parameters
+	SetFont( ITEM_FONT );
+	SetFontBackground( FONT_MCOLOR_BLACK );
+	SetFontForeground( FONT_RED );
+	if(CompatibleAmmoForGun(gpItemPointer, &pSoldier->inv[bPos]))
+		swprintf( pStr, L"L" );
+	else if(pCapacity != 0 && CanItemFitInPosition(pSoldier, gpItemPointer, (INT8)bPos, FALSE))
+	{
+		// Adjust capacity to account for current items
+		if(gpItemPointer->usItem == pSoldier->inv[bPos].usItem)
+		{
+			pCapacity = pCapacity - pSoldier->inv[bPos].ubNumberOfObjects;
+			if(pCapacity > 0)
+				swprintf( pStr, L"+%d", pCapacity );
+			else
+				swprintf( pStr, L"-" );
+		}
+		else
+			swprintf( pStr, L"%d", pCapacity );
+	}
+	sX = gSMInvData[ bPos ].sX + 1;
+	sY = gSMInvData[ bPos ].sY;
+	UINT32 uiWhichBuffer = ( guiCurrentItemDescriptionScreen == MAP_SCREEN ) ? guiSAVEBUFFER : guiRENDERBUFFER;
+
+	// Display pocket capacity
+	if ( uiWhichBuffer == guiSAVEBUFFER )
+	{
+		RestoreExternBackgroundRect( sX, sY, 15, 15 );
+	}
+	mprintf( sX, sY, pStr );
+	gprintfinvalidate( sX, sY, pStr );
+	return;
+}
+// CHRISL: New function to render silhouettes
+void INVRenderSilhouette( UINT32 uiBuffer, INT16 PocketIndex, INT16 SilIndex, INT16 sX, INT16 sY, INT16 sWidth, INT16 sHeight)
+{
+	ETRLEObject						*pTrav;
+	HVOBJECT						hVObject;
+	UINT32							usHeight, usWidth;
+	INT16							sCenX, sCenY;
+	
+	if(gfSMDisableForItems)
+		return;
+	SetFont( ITEM_FONT );
+	GetVideoObject( &hVObject, guiSILHOUETTE );
+	if ( PocketIndex != ITEM_NOT_FOUND )
+		SilIndex = LBEPocketType[PocketIndex].pSilhouette;
+
+	pTrav = &(hVObject->pETRLEObject[ SilIndex ] );
+
+	usHeight				= (UINT32)pTrav->usHeight;
+	usWidth					= (UINT32)pTrav->usWidth;
+
+	// CENTER IN SLOT!
+	// CANCEL OFFSETS!
+	sCenX =  sX + (INT16)( abs( sWidth - (double)usWidth ) / 2 ) - pTrav->sOffsetX;
+	sCenY =  sY + (INT16)( abs( sHeight - (double)usHeight ) / 2 ) - pTrav->sOffsetY;
+
+	BltVideoObjectOutlineFromIndex( uiBuffer, guiSILHOUETTE, SilIndex, sCenX, sCenY, 0 /*sOutlineColor*/, FALSE );
+
+	if ( uiBuffer == FRAME_BUFFER )
+	{
+		InvalidateRegion( sX, sY, (INT16)(sX + sWidth), (INT16)(sY + sHeight ) );
+	}
+	else
+	{
+		RestoreExternBackgroundRect( sX, sY, sWidth, sHeight );
+	}
+}
+
 void INVRenderItem( UINT32 uiBuffer, SOLDIERTYPE * pSoldier, OBJECTTYPE  *pObject, INT16 sX, INT16 sY, INT16 sWidth, INT16 sHeight, UINT8 fDirtyLevel, UINT8 *pubHighlightCounter, UINT8 ubStatusIndex, BOOLEAN fOutline, INT16 sOutlineColor )
 {
 	UINT16								uiStringLength;
@@ -2194,6 +2544,31 @@
 
 			}
 
+			if(gGameOptions.ubInventorySystem)
+			{
+				// CHRISL: Display astrisk when LBENODE active
+				if ( pObject->ItemData.Trigger.bDetonatorType == ITEM_NOT_FOUND )
+				{
+					SetFontForeground( FONT_BLUE );
+
+					sNewY = sY;
+					swprintf( pStr, L"*" );
+
+					// Get length of string
+					uiStringLength=StringPixLength(pStr, ITEM_FONT );
+
+					sNewX = sX + sWidth - uiStringLength - 4;
+
+					if ( uiBuffer == guiSAVEBUFFER )
+					{
+						RestoreExternBackgroundRect( sNewX, sNewY, 15, 15 );
+					}
+					mprintf( sNewX, sNewY, pStr );
+					gprintfinvalidate( sNewX, sNewY, pStr );
+
+				}
+			}
+
 			if ( pSoldier && pObject == &(pSoldier->inv[HANDPOS] ) && pSoldier->bWeaponMode != WM_NORMAL )
 			{
 				sNewY = sY + 13; // rather arbitrary
@@ -2390,6 +2765,16 @@
 	INT16		sForeColour;
 	INT16 sProsConsIndent;
 
+	// CHRISL: Set some initial coords
+	ITEMDESC_START_X	= (!gGameOptions.ubInventorySystem) ? 214 : 115;
+	ITEMDESC_START_Y	= (!gGameOptions.ubInventorySystem) ? (1 + INV_INTERFACE_START_Y) : (1 + INV_INTERFACE_START_Y);
+	ITEMDESC_HEIGHT		= (!gGameOptions.ubInventorySystem) ? 133 : 195;
+	ITEMDESC_WIDTH		= (!gGameOptions.ubInventorySystem) ? 320 : 678;
+	MAP_ITEMDESC_HEIGHT	= (!gGameOptions.ubInventorySystem) ? 268 : 490;
+	MAP_ITEMDESC_WIDTH	= (!gGameOptions.ubInventorySystem) ? 272 : 272;
+	//MAP_KEYRING_X		= (!gGameOptions.ubInventorySystem) ? 217 : 180;
+	//MAP_KEYRING_Y		= (!gGameOptions.ubInventorySystem) ? 271 : 127;
+
 	//Set the current screen
 	guiCurrentItemDescriptionScreen = guiCurrentScreen;
 
@@ -3087,6 +3472,7 @@
 	UINT8									ubAttackAPs;
 	BOOLEAN								fHatchOutAttachments = gfItemDescObjectIsAttachment; // if examining attachment, always hatch out attachment slots
 	INT16									sProsConsIndent;
+	INT8							showBox=0;
 
   if( ( guiCurrentItemDescriptionScreen == MAP_SCREEN ) &&(gfInItemDescBox ) )
 	{
@@ -3101,7 +3487,15 @@
 		sCenX = MAP_ITEMDESC_ITEM_X + (INT16)( abs( ITEMDESC_ITEM_WIDTH - (double)usWidth ) / 2 ) - pTrav->sOffsetX;
 		sCenY = MAP_ITEMDESC_ITEM_Y + (INT16)( abs( ITEMDESC_ITEM_HEIGHT - (double)usHeight ) / 2 )- pTrav->sOffsetY;
 
-		BltVideoObjectFromIndex( guiSAVEBUFFER, guiMapItemDescBox, 0, gsInvDescX, gsInvDescY, VO_BLT_SRCTRANSPARENCY, NULL );
+		// CHRISL: Determine if we're looking at an LBENODE and display alternate box graphic
+		if(gGameOptions.ubInventorySystem)
+		{
+			if(gpItemDescObject->ItemData.Trigger.bDetonatorType == -1)
+				showBox = LBEptr[gpItemDescObject->ItemData.Trigger.usBombItem].lbeClass;
+			else if(Item[gpItemDescObject->usItem].usItemClass == IC_LBEGEAR)
+				showBox = LoadBearingEquipment[Item[gpItemDescObject->usItem].ubClassIndex].lbeClass;
+		}
+		BltVideoObjectFromIndex( guiSAVEBUFFER, guiMapItemDescBox, showBox, gsInvDescX, gsInvDescY, VO_BLT_SRCTRANSPARENCY, NULL );
 
 		//Display the money 'seperating' border
 		if ( gpItemDescObject->usItem == MONEY )
@@ -3120,6 +3514,16 @@
 		// Display ststus
 		DrawItemUIBarEx( gpItemDescObject, gubItemDescStatusIndex, (INT16)MAP_ITEMDESC_ITEM_STATUS_X, (INT16)MAP_ITEMDESC_ITEM_STATUS_Y, ITEMDESC_ITEM_STATUS_WIDTH, ITEMDESC_ITEM_STATUS_HEIGHT_MAP, 	Get16BPPColor( DESC_STATUS_BAR ), Get16BPPColor( DESC_STATUS_BAR_SHADOW ), TRUE, guiSAVEBUFFER );
 
+		// CHRISL:  This block will display hatching for inactive LBE pockets
+		// Display LBENODE attached items
+		if(gGameOptions.ubInventorySystem)
+		{
+			if(gpItemDescObject->ItemData.Trigger.bDetonatorType == -1)
+				RenderLBENODEItems( gpItemDescObject, TRUE, TRUE );
+			else if(Item[gpItemDescObject->usItem].usItemClass == IC_LBEGEAR)
+				RenderLBENODEItems( gpItemDescObject, FALSE, TRUE );
+		}
+
 		if (gpItemPointer)
 		{
 //			if ( ( Item[ gpItemPointer->usItem ].fFlags & ITEM_HIDDEN_ADDON ) ||
@@ -3199,6 +3603,16 @@
 
 		RestoreExternBackgroundRect( gsInvDescX, gsInvDescY, MAP_ITEMDESC_WIDTH, MAP_ITEMDESC_HEIGHT );
 
+		// CHRISL: This block will display misc information for items stored in LBE Pockets
+		// Display LBENODE attached items
+		if(gGameOptions.ubInventorySystem)
+		{
+			if(gpItemDescObject->ItemData.Trigger.bDetonatorType == -1)
+				RenderLBENODEItems( gpItemDescObject, TRUE, TRUE );
+			else if(Item[gpItemDescObject->usItem].usItemClass == IC_LBEGEAR)
+				RenderLBENODEItems( gpItemDescObject, FALSE, TRUE );
+		}
+
 		// Render font desc
 		SetFont( ITEMDESC_FONT );
 		SetFontBackground( FONT_MCOLOR_BLACK );
@@ -3617,7 +4031,22 @@
 		sCenX = ITEMDESC_ITEM_X + (INT16)( abs( ITEMDESC_ITEM_WIDTH - (double)usWidth ) / 2 ) - pTrav->sOffsetX;
 		sCenY = ITEMDESC_ITEM_Y + (INT16)( abs( ITEMDESC_ITEM_HEIGHT - (double)usHeight ) / 2 ) - pTrav->sOffsetY;
 
-		BltVideoObjectFromIndex( guiSAVEBUFFER, guiItemDescBox, 0, gsInvDescX, gsInvDescY, VO_BLT_SRCTRANSPARENCY, NULL );
+		// CHRISL: Determine if we're looking at an LBENODE and display alternate box graphic
+		RenderBackpackButtons(1);
+		if(gGameOptions.ubInventorySystem)
+		{
+			if(gpItemDescObject->ItemData.Trigger.bDetonatorType == -1)
+				showBox = LBEptr[gpItemDescObject->ItemData.Trigger.usBombItem].lbeClass;
+			else if(Item[gpItemDescObject->usItem].usItemClass == IC_LBEGEAR)
+				showBox = LoadBearingEquipment[Item[gpItemDescObject->usItem].ubClassIndex].lbeClass;
+		}
+		// CHRISL: Setup default coords if we haven't initialized them yet
+		if(gsInvDescX == NONE && gsInvDescY == NONE)
+		{
+			gsInvDescX = 115;
+			gsInvDescY = (INT16)(INV_INTERFACE_START_Y + 1 );
+		}
+		BltVideoObjectFromIndex( guiSAVEBUFFER, guiItemDescBox, showBox, gsInvDescX, gsInvDescY, VO_BLT_SRCTRANSPARENCY, NULL );
 
 		if ( gpItemDescObject->usItem == MONEY )
 		{
@@ -3633,6 +4062,16 @@
 		// Display status
 		DrawItemUIBarEx( gpItemDescObject, gubItemDescStatusIndex, (INT16)ITEMDESC_ITEM_STATUS_X, (INT16)ITEMDESC_ITEM_STATUS_Y, ITEMDESC_ITEM_STATUS_WIDTH, ITEMDESC_ITEM_STATUS_HEIGHT, 	Get16BPPColor( DESC_STATUS_BAR ), Get16BPPColor( DESC_STATUS_BAR_SHADOW ), TRUE, guiSAVEBUFFER );
 	
+		// CHRISL:  This block will display hatching for inactive LBE pockets
+		// Display LBENODE attached items
+		if(gGameOptions.ubInventorySystem)
+		{
+			if(gpItemDescObject->ItemData.Trigger.bDetonatorType == -1)
+				RenderLBENODEItems( gpItemDescObject, TRUE, FALSE );
+			else if(Item[gpItemDescObject->usItem].usItemClass == IC_LBEGEAR)
+				RenderLBENODEItems( gpItemDescObject, FALSE, FALSE );
+		}
+
 		if (gpItemPointer)
 		{
 //			if ( ( Item[ gpItemPointer->usItem ].fFlags & ITEM_HIDDEN_ADDON ) ||
@@ -3700,6 +4139,16 @@
 
 		RestoreExternBackgroundRect( gsInvDescX, gsInvDescY, ITEMDESC_WIDTH, ITEMDESC_HEIGHT );
 
+		// CHRISL: This block will display misc information for items stored in LBE Pockets
+		// Display LBENODE attached items
+		if(gGameOptions.ubInventorySystem)
+		{
+			if(gpItemDescObject->ItemData.Trigger.bDetonatorType == -1)
+				RenderLBENODEItems( gpItemDescObject, TRUE, FALSE );
+			else if(Item[gpItemDescObject->usItem].usItemClass == IC_LBEGEAR)
+				RenderLBENODEItems( gpItemDescObject, FALSE, FALSE );
+		}
+
 		// Render font desc
 		SetFont( ITEMDESC_FONT );
 		SetFontBackground( FONT_MCOLOR_BLACK );
@@ -4104,6 +4553,190 @@
 
 }
 
+// CHRISL: New function to display items stored in an LBENODE
+void RenderLBENODEItems( OBJECTTYPE *pObj, BOOLEAN activeNode, BOOLEAN stratScreen )
+{
+	extern INV_REGION_DESC gSMInvPocketXY[NUM_INV_SLOTS];
+	extern INV_REGION_DESC gMapScreenInvPocketXY[NUM_INV_SLOTS];
+	SOLDIERTYPE	*pSoldier;
+	OBJECTTYPE	*pObject;
+	int			offSetX;
+	int			offSetY;
+	int			pocketKey[12];
+	int			Num_Pockets;
+	INT16		sX, sY;
+	INT16		sBarX, sBarY;
+	INT16		lbePocket = ITEM_NOT_FOUND;
+	BOOLEAN		fHatchItOut = FALSE;
+	UINT32		lClass;
+	UINT16		lIndex;
+
+	// Set selected merc
+	if(guiCurrentItemDescriptionScreen == MAP_SCREEN)
+		GetSoldier( &pSoldier, gCharactersList[bSelectedInfoChar].usSolID );
+	else
+		pSoldier = gpSMCurrentMerc;
+	
+	// Start by verifying that this item is an LBENODE
+//	if(pObj->bDetonatorType != -1)
+	if(Item[pObj->usItem].usItemClass != IC_LBEGEAR)
+		return;
+
+	if(pObj->ItemData.Trigger.bDetonatorType == -1)
+	{
+		lIndex = pObj->ItemData.Trigger.usBombItem;
+		lClass = LBEptr[lIndex].lbeClass;
+	}
+	else
+		lClass = LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass;
+	if(lClass == 1 && pObj->ItemData.Trigger.bDetonatorType != -1 && pObj == &pSoldier->inv[RTHIGHPOCKPOS])
+		lClass = 5;
+	// Setup pocket coords
+	switch (lClass)
+	{
+		case THIGH_PACK:
+			pocketKey[0] = SMALLPOCK11POS;
+			pocketKey[1] = SMALLPOCK12POS;
+			pocketKey[2] = SMALLPOCK13POS;
+			pocketKey[3] = SMALLPOCK14POS;
+			pocketKey[4] = MEDPOCK3POS;
+			if(stratScreen){
+				offSetX = 83;
+				offSetY = -1;
+			}
+			else{
+				offSetX = 203;
+				offSetY = -79;
+			}
+			Num_Pockets = 5;
+			break;
+		case VEST_PACK:
+			pocketKey[0] = SMALLPOCK1POS;
+			pocketKey[1] = SMALLPOCK2POS;
+			pocketKey[2] = SMALLPOCK3POS;
+			pocketKey[3] = SMALLPOCK4POS;
+			pocketKey[4] = SMALLPOCK5POS;
+			pocketKey[5] = SMALLPOCK6POS;
+			pocketKey[6] = SMALLPOCK7POS;
+			pocketKey[7] = SMALLPOCK8POS;
+			pocketKey[8] = SMALLPOCK9POS;
+			pocketKey[9] = SMALLPOCK10POS;
+			pocketKey[10] = MEDPOCK1POS;
+			pocketKey[11] = MEDPOCK2POS;
+			if(stratScreen){
+				offSetX = 0;
+				offSetY = 111;
+			}
+			else{
+				offSetX = 94;
+				offSetY = 30;
+			}
+			Num_Pockets = 12;
+			break;
+		case COMBAT_PACK:
+			pocketKey[0] = SMALLPOCK19POS;
+			pocketKey[1] = SMALLPOCK20POS;
+			pocketKey[2] = SMALLPOCK21POS;
+			pocketKey[3] = SMALLPOCK22POS;
+			pocketKey[4] = BIGPOCK1POS;
+			pocketKey[5] = BIGPOCK2POS;
+			pocketKey[6] = BIGPOCK3POS;
+			if(stratScreen){
+				offSetX = -82;
+				offSetY = -1;
+			}
+			else{
+				offSetX = -8;
+				offSetY = -87;
+			}
+			Num_Pockets = 7;
+			break;
+		case BACKPACK:
+			pocketKey[0] = SMALLPOCK23POS;
+			pocketKey[1] = SMALLPOCK24POS;
+			pocketKey[2] = SMALLPOCK25POS;
+			pocketKey[3] = SMALLPOCK26POS;
+			pocketKey[4] = SMALLPOCK27POS;
+			pocketKey[5] = SMALLPOCK28POS;
+			pocketKey[6] = SMALLPOCK29POS;
+			pocketKey[7] = SMALLPOCK30POS;
+			pocketKey[8] = BIGPOCK4POS;
+			pocketKey[9] = BIGPOCK5POS;
+			pocketKey[10] = BIGPOCK6POS;
+			pocketKey[11] = BIGPOCK7POS;
+			if(stratScreen){
+				offSetX = 42;
+				offSetY = -104;
+			}
+			else{
+				offSetX = -170;
+				offSetY = 12;
+			}
+			Num_Pockets = 12;
+			break;
+		case 5:
+			pocketKey[0] = SMALLPOCK15POS;
+			pocketKey[1] = SMALLPOCK16POS;
+			pocketKey[2] = SMALLPOCK17POS;
+			pocketKey[3] = SMALLPOCK18POS;
+			pocketKey[4] = MEDPOCK4POS;
+			if(stratScreen){
+				offSetX = 1;
+				offSetY = -1;
+			}
+			else{
+				offSetX = 117;
+				offSetY = -79;
+			}
+			Num_Pockets = 5;
+			break;
+		default:
+			Num_Pockets = 0;
+			break;
+	}
+	// Display contents of LBENODE
+	for(int cnt=0; cnt<Num_Pockets; cnt++)
+	{
+		if(stratScreen){
+			sX = gMapScreenInvPocketXY[pocketKey[cnt]].sX + offSetX;
+			sY = gMapScreenInvPocketXY[pocketKey[cnt]].sY + offSetY;
+		}
+		else{
+			sX = gSMInvPocketXY[pocketKey[cnt]].sX + offSetX;
+			sY = gSMInvPocketXY[pocketKey[cnt]].sY + offSetY;
+		}
+		lbePocket = LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbePocketIndex[icPocket[pocketKey[cnt]]];
+		if(activeNode)
+			pObject = &(LBEptr[lIndex].inv[cnt]);
+		else
+		{
+			if(pObj == &pSoldier->inv[VESTPOCKPOS] || pObj == &pSoldier->inv[LTHIGHPOCKPOS] || pObj == &pSoldier->inv[RTHIGHPOCKPOS] || pObj == &pSoldier->inv[CPACKPOCKPOS] || pObj == &pSoldier->inv[BPACKPOCKPOS])
+				pObject = &(pSoldier->inv[pocketKey[cnt]]);
+			else
+				pObject = NULL;
+		}
+		fHatchItOut = FALSE;
+		if (lbePocket == 0)	// Deactivate Pocket
+			fHatchItOut = TRUE;
+		else if ( pObject == NULL || pObject->usItem == NOTHING )	// Nothing in sPocket.  Display silouhette.
+			INVRenderSilhouette( guiSAVEBUFFER, lbePocket, 0, sX, sY, gSMInvData[ pocketKey[cnt] ].sWidth, gSMInvData[ pocketKey[cnt] ].sHeight);
+		if(pObject != NULL)
+			INVRenderItem( guiSAVEBUFFER, pSoldier, pObject, sX, sY, gSMInvData[ pocketKey[cnt] ].sWidth, gSMInvData[ pocketKey[cnt] ].sHeight, 2, NULL, 0, 0, 0 );
+		if (gpItemPointer != NULL)
+			RenderPocketItemCapacity( ItemSlotLimit(gpItemPointer, pocketKey[cnt], pSoldier), pocketKey[cnt], pSoldier);
+		if ( fHatchItOut )
+			DrawHatchOnInventory( guiSAVEBUFFER, sX, sY, (UINT16)(gSMInvData[ pocketKey[cnt] ].sWidth-1), (UINT16)(gSMInvData[ pocketKey[cnt] ].sHeight-1) );
+		// if there's an item in there
+		if ( pObject != NULL && pObject->usItem != NOTHING )
+		{
+			// Add item status bar
+			sBarX = sX - gSMInvData[ pocketKey[cnt] ].sBarDx;
+			sBarY = sY + gSMInvData[ pocketKey[cnt] ].sBarDy;
+			DrawItemUIBarEx( pObject, 0, sBarX, sBarY, ITEM_BAR_WIDTH, ITEM_BAR_HEIGHT,	Get16BPPColor( STATUS_BAR ), Get16BPPColor( STATUS_BAR_SHADOW ), TRUE , guiSAVEBUFFER);
+		}
+	}
+}
+
 void HandleItemDescriptionBox( BOOLEAN *pfDirty )
 {
 	if ( fItemDescDelete )
@@ -4209,6 +4842,7 @@
 	//Remove
 	DeleteVideoObjectFromIndex( guiItemDescBox );
 	DeleteVideoObjectFromIndex( guiMapItemDescBox );
+	RenderBackpackButtons(0);	/* CHRISL: Needed for new inventory backpack buttons */
 	DeleteVideoObjectFromIndex( guiBullet );
 	// Delete item graphic
 	DeleteVideoObjectFromIndex( guiItemGraphic );
@@ -5306,9 +5940,21 @@
   ETRLEObject						*pTrav;
 	HVOBJECT							hVObject;
 	INT32						cnt;
-	UINT16				 usPopupWidth;
+	UINT16				 usPopupWidth, usPopupHeight;
 	INT16					sItemSlotWidth, sItemSlotHeight;
+	INT16 sItemWidth = 0, sOffSetY = 0;
 
+	// CHRISL: Setup witdh and offset to layer inventory boxes if necessary
+	if( guiCurrentScreen == MAP_SCREEN )
+	{
+		sItemWidth						= MAP_INV_ITEM_ROW_WIDTH;
+		sOffSetY						= 170;
+	}
+	else
+	{
+		sItemWidth						= INV_ITEM_ROW_WIDTH;
+	}
+
 	
 	// Set some globals
 	gsItemPopupInvX					= sInvX;
@@ -5322,7 +5968,8 @@
 
 	// Determine # of items
 	gpItemPopupObject = &(pSoldier->inv[ ubPosition ] );
-	ubLimit = ItemSlotLimit( gpItemPopupObject->usItem, ubPosition );
+	// CHRISL:
+	ubLimit = (!gGameOptions.ubInventorySystem) ? ItemSlotLimit( gpItemPopupObject->usItem, ubPosition ) : ItemSlotLimit( gpItemPopupObject, ubPosition, pSoldier );
 
 	// Return false if #objects not >1
 	if ( ubLimit <1 )
@@ -5330,13 +5977,14 @@
 		return( FALSE );
 	}
 
-	if( guiCurrentItemDescriptionScreen == MAP_SCREEN )
-	{
-    if ( ubLimit > 6 )
-    {
-      ubLimit = 6;
-    }
-  }
+	//CHRISL: No longer needed now that we're displaying multiple rows of inventory items.
+//	if( guiCurrentItemDescriptionScreen == MAP_SCREEN )
+//	{
+//    if ( ubLimit > 6 )
+//    {
+//      ubLimit = 6;
+//    }
+//  }
 
 	// Load graphics
 	VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
@@ -5347,6 +5995,7 @@
 	GetVideoObject( &hVObject, guiItemPopupBoxes );
 	pTrav = &(hVObject->pETRLEObject[ 0 ] );
 	usPopupWidth = pTrav->usWidth;
+	usPopupHeight = pTrav->usHeight;
 
 	// Determine position, height and width of mouse region, area
 	GetSlotInvXY( ubPosition, &sX, &sY );
@@ -5357,9 +6006,12 @@
 	gsItemPopupHeight = pTrav->usHeight;
 	gubNumItemPopups = ubLimit;
 
+	// CHRISL: Don't center.  Instead, put interface in upper left corner or mouse area
 	// Calculate X,Y, first center
-	sCenX = sX - ( ( gsItemPopupWidth / 2 ) + ( sItemSlotWidth / 2 ) );
-	sCenY	= sY;
+	//sCenX = sX - ( ( gsItemPopupWidth / 2 ) + ( sItemSlotWidth / 2 ) );
+	//sCenY	= sY;
+	sCenX	= gsItemPopupInvX;
+	sCenY	= gsItemPopupInvY;
 
 	// Limit it to window for item desc
 	if ( sCenX < gsItemPopupInvX )
@@ -5384,8 +6036,16 @@
 	for ( cnt = 0; cnt < gubNumItemPopups; cnt++ )
 	{
 		// Build a mouse region here that is over any others.....
-		MSYS_DefineRegion( &gItemPopupRegions[cnt], (INT16)(sCenX + ( cnt * usPopupWidth ) ), sCenY , (INT16)(sCenX + ( (cnt+1) * usPopupWidth ) ),(INT16)( sCenY + gsItemPopupHeight ), MSYS_PRIORITY_HIGHEST,
-							 MSYS_NO_CURSOR, MSYS_NO_CALLBACK, ItemPopupRegionCallback ); 
+		// CHRISL: New region definition to handle multiple rows of items
+//		MSYS_DefineRegion( &gItemPopupRegions[cnt], (INT16)(sCenX + ( cnt * usPopupWidth ) ), sCenY , (INT16)(sCenX + ( (cnt+1) * usPopupWidth ) ),(INT16)( sCenY + gsItemPopupHeight ), MSYS_PRIORITY_HIGHEST,
+//							 MSYS_NO_CURSOR, MSYS_NO_CALLBACK, ItemPopupRegionCallback ); 
+		MSYS_DefineRegion( &gItemPopupRegions[cnt], 
+				(INT16)( gsItemPopupX + ( cnt % sItemWidth * usPopupWidth ) ), // top left
+				(INT16)( gsItemPopupY + sOffSetY + ( cnt / sItemWidth * usPopupHeight ) ), // top right
+				(INT16)( gsItemPopupX + ( ( cnt % sItemWidth ) + 1 ) * usPopupWidth ), // bottom left
+				(INT16)( gsItemPopupY + ( (cnt / sItemWidth + 1) * usPopupHeight ) + sOffSetY ), // bottom right
+				MSYS_PRIORITY_HIGHEST,
+				MSYS_NO_CURSOR, MSYS_NO_CALLBACK, ItemPopupRegionCallback ); 
 		// Add region
 		MSYS_AddRegion( &gItemPopupRegions[cnt]);
 		MSYS_SetRegionUserData( &gItemPopupRegions[cnt], 0, cnt );
@@ -5447,7 +6107,19 @@
 	HVOBJECT							hVObject;
 	UINT32								cnt;
 	INT16									sX, sY, sNewX, sNewY;
+	INT16 sItemWidth = 0, sOffSetY = 0;
 
+	// CHRISL: Setup witdh and offset to layer inventory boxes if necessary
+	if( guiCurrentScreen == MAP_SCREEN )
+	{
+		sItemWidth						= MAP_INV_ITEM_ROW_WIDTH;
+		sOffSetY						= 170;
+	}
+	else
+	{
+		sItemWidth						= INV_ITEM_ROW_WIDTH;
+	}
+
 	if ( gfInItemStackPopup )
 	{
 
@@ -5470,19 +6142,25 @@
 	
 	for ( cnt = 0; cnt < gubNumItemPopups; cnt++ )
 	{
-		BltVideoObjectFromIndex( FRAME_BUFFER, guiItemPopupBoxes, 0, gsItemPopupX + ( cnt * usWidth ), gsItemPopupY, VO_BLT_SRCTRANSPARENCY, NULL );
+		// CHRISL: Layer item boxes if we have too many to display in a single row
+		//BltVideoObjectFromIndex( FRAME_BUFFER, guiItemPopupBoxes, 0, gsItemPopupX + ( cnt * usWidth ), gsItemPopupY, VO_BLT_SRCTRANSPARENCY, NULL );
+		sX = (INT16)(gsItemPopupX + ( cnt % sItemWidth * usWidth ));
+		sY = (INT16)(gsItemPopupY + sOffSetY + ( cnt / sItemWidth * usHeight ));
+		BltVideoObjectFromIndex( FRAME_BUFFER, guiItemPopupBoxes, 0, (INT16)sX, ( INT16 )sY, VO_BLT_SRCTRANSPARENCY, NULL );
 
 		if ( cnt < gpItemPopupObject->ubNumberOfObjects )
 		{
-			sX = (INT16)(gsItemPopupX + ( cnt * usWidth ) + 11);
-			sY = (INT16)( gsItemPopupY + 3 );
+			// CHRISL: Coord updates to work with mutliple rows
+			//sX = (INT16)(gsItemPopupX + ( cnt * usWidth ) + 11);
+			//sY = (INT16)( gsItemPopupY + 3 );
 
-			INVRenderItem( FRAME_BUFFER, NULL, gpItemPopupObject, sX, sY, 29, 23, DIRTYLEVEL2, NULL, (UINT8)RENDER_ITEM_NOSTATUS, FALSE, 0 );
+			INVRenderItem( FRAME_BUFFER, NULL, gpItemPopupObject, sX+11, sY+3, 29, 23, DIRTYLEVEL2, NULL, (UINT8)RENDER_ITEM_NOSTATUS, FALSE, 0 );
 
+			// CHRISL: Coord updates to work with mutliple rows
 			// Do status bar here...
 			sNewX = (INT16)( gsItemPopupX + ( cnt * usWidth ) + 7 );
 			sNewY = gsItemPopupY + INV_BAR_DY + 3;
-			DrawItemUIBarEx( gpItemPopupObject, (UINT8)cnt, sNewX, sNewY, ITEM_BAR_WIDTH, ITEM_BAR_HEIGHT, 	Get16BPPColor( STATUS_BAR ), Get16BPPColor( STATUS_BAR_SHADOW ), TRUE , FRAME_BUFFER );
+			DrawItemUIBarEx( gpItemPopupObject, (UINT8)cnt, sX+7, sY+INV_BAR_DY+3, ITEM_BAR_WIDTH, ITEM_BAR_HEIGHT, 	Get16BPPColor( STATUS_BAR ), Get16BPPColor( STATUS_BAR_SHADOW ), TRUE , FRAME_BUFFER );
 
 		}
 	}
@@ -6756,6 +7434,27 @@
 				  //gprintfinvalidate( sNewX, sNewY, pStr );
 			  }
 
+			  if(gGameOptions.ubInventorySystem)
+			  {
+				  // CHRISL: Show astrisk for active LBENODE
+				  if ( pObject->ItemData.Trigger.bDetonatorType == ITEM_NOT_FOUND)
+				  {
+					  SetFontForeground( FONT_BLUE );
+						SetFontShadow( DEFAULT_SHADOW );
+
+					  sNewY = sCenY + 2;
+					  swprintf( pStr, L"*" );
+
+					  // Get length of string
+					  uiStringLength=StringPixLength( pStr, ITEM_FONT );
+
+					  sNewX = sCenX + 43 - uiStringLength - 4;
+
+  					mprintf_buffer( pDestBuf, uiDestPitchBYTES, ITEMDESC_FONT, sNewX, sNewY, pStr );
+					  //gprintfinvalidate( sNewX, sNewY, pStr );
+				  }
+			  }
+
 				if ( gItemPickupMenu.bCurSelect == ( cnt + gItemPickupMenu.ubScrollAnchor ) )
 				{
 					//SetFontForeground( ITEMDESC_FONTSHADOW2 );
Index: Tactical/Interface Items.h
===================================================================
--- Tactical/Interface Items.h	(revision 1299)
+++ Tactical/Interface Items.h	(working copy)
@@ -79,8 +79,19 @@
 //  Last parameter used mainly for when mouse is over item
 
 void INVRenderItem( UINT32 uiBuffer, SOLDIERTYPE * pSoldier, OBJECTTYPE  *pObject, INT16 sX, INT16 sY, INT16 sWidth, INT16 sHeight, UINT8 fDirtyLevel, UINT8 *pubHighlightCounter, UINT8 ubStatusIndex, BOOLEAN fOutline, INT16 sOutlineColor );
+// CHRISL: Add a new function that will be used to render a pocket silhouette
+void INVRenderSilhouette( UINT32 uiBugger, INT16 PocketIndex, INT16 SilIndex, INT16 sX, INT16 sY, INT16 sWideth, INT16 sHeight);
+// CHRISL: New function to handle display of inventory quantities based on item current in cursor
+void RenderPocketItemCapacity( INT8 pCapacity, INT16 bPos, SOLDIERTYPE *pSoldier );
+// CHRISL: New function to display items stored in an LBENODE
+void RenderLBENODEItems( OBJECTTYPE *pObj, BOOLEAN activeNode, BOOLEAN stratScreen );
+// CHRISL: New function to setup GSMInvData based on game options
+void InitInvData(INT8 num, BOOLEAN fBigPocket, INT16 sBarDx, INT16 sBarDy, INT16 sWidth, INT16 sHeight, INT16 sX, INT16 sY);
+void InitInventoryOld();
+void InitInventoryNew();
+void InitInventoryVehicle(INV_REGION_DESC *pRegionDesc, MOUSE_CALLBACK INVMoveCallback, MOUSE_CALLBACK INVClickCallback, BOOLEAN fSetHighestPrioity);
+void ResetMapInvRegions(INV_REGION_DESC *pRegionDesc, MOUSE_CALLBACK INVMoveCallback, MOUSE_CALLBACK INVClickCallback, BOOLEAN fSetHighestPrioity);
 
-
 extern BOOLEAN		gfInItemDescBox;
 
 BOOLEAN InItemDescriptionBox( );
@@ -156,4 +167,4 @@
 
 BOOLEAN InitializeStealItemPickupMenu( SOLDIERTYPE *pSoldier, SOLDIERTYPE *pOpponent, ITEM_POOL *pItemPool, UINT8 ubCount);
 
-#endif
\ No newline at end of file
+#endif
Index: Tactical/Interface Panels.cpp
===================================================================
--- Tactical/Interface Panels.cpp	(revision 1299)
+++ Tactical/Interface Panels.cpp	(working copy)
@@ -96,7 +96,8 @@
  *  joker 
  */
 
-INV_REGION_DESC gSMInvPocketXY[19];	// ARRAY FOR INV PANEL INTERFACE ITEM POSITIONS
+// CHRISL: Change key value to use dynamically generated NUM_INV_SLOTS instead of static setting
+INV_REGION_DESC gSMInvPocketXY[NUM_INV_SLOTS];	// ARRAY FOR INV PANEL INTERFACE ITEM POSITIONS
 INV_REGION_DESC gSMCamoXY;			// X, Y Location of cammo region
 
 /*  So this coords buttons, bars etc. also ware declered here as constant and we also need them
@@ -184,6 +185,13 @@
 int SM_DONE_Y;
 int SM_MAPSCREEN_X;
 int SM_MAPSCREEN_Y;
+// CHRISL: backpack buttons
+int SM_DROPPACK_X;
+int SM_DROPPACK_Y;
+int SM_ZIPPER_X;
+int SM_ZIPPER_Y;
+extern int INV_BDROP_X;
+extern int INV_BDROP_Y;
 
 int SM_POSITIONB_X;
 int SM_POSITIONB_Y;
@@ -315,8 +323,19 @@
 int	INTERFACE_CLOCK_Y;
 int	LOCATION_NAME_X;
 int	LOCATION_NAME_Y;
+/* CHRISL: Added new "TM" variables to allow team and inventory screens to place the clock and location name
+independantly of each other */
+int	INTERFACE_CLOCK_TM_X;
+int	INTERFACE_CLOCK_TM_Y;
+int	LOCATION_NAME_TM_X;
+int	LOCATION_NAME_TM_Y;
 
+// CHRISL: Keyring coords moved from Interface Items.cpp
+int KEYRING_X;
+int KEYRING_Y;
 
+extern UINT32 guiCurrentItemDescriptionScreen;
+
 typedef enum
 {
 	STANCEUP_IMAGES = 0,
@@ -334,6 +353,7 @@
 	STANCE_IMAGES,
 	DONE_IMAGES,
 	MAPSCREEN_IMAGES,
+	BACKPACK_IMAGES,
 	NUM_SM_BUTTON_IMAGES
 };
 
@@ -352,6 +372,12 @@
 INT32		giSMStealthImages	= -1;
 INT32		giSMStealthButton	= -1;
 
+// CHRISL: Backpack buttons
+INT32		giSMDropPackImages			= -1;
+INT32		giSMDropPackButton			= -1;
+INT32		giSMZipperImages			= -1;
+INT32		giSMZipperButton			= -1;
+
 BOOLEAN		gfSwitchPanel		= FALSE;
 UINT8		gbNewPanel			= SM_PANEL;
 UINT8		gubNewPanelParam	= 0;
@@ -392,6 +418,12 @@
 void ConfirmationToDepositMoneyToPlayersAccount( UINT8 ubExitValue );
 void MergeMessageBoxCallBack( UINT8 ubExitValue );
 
+// CHRISL:
+BOOLEAN MoveItemsToActivePockets( SOLDIERTYPE *pSoldier, INT8 LBESlots[], UINT32 uiHandPos, OBJECTTYPE *pObj );
+BOOLEAN MoveItemToLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj );
+BOOLEAN MoveItemFromLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj );
+INT16 GetFreeLBEPackIndex( void );
+
 UINT8	gubHandPos;
 UINT16	gusOldItemIndex;
 UINT16	gusNewItemIndex;
@@ -435,6 +467,9 @@
 INT8				gbSMCurStanceObj;
 UINT16				gusSMCurrentMerc = 0;
 SOLDIERTYPE			*gpSMCurrentMerc = NULL;
+// CHRISL:
+vector<LBENODE>	LBEptr;
+UINT16		LBEptrNum=0;
 extern	INT8		gbCompatibleApplyItem; 
 extern	SOLDIERTYPE *gpItemPopupSoldier;
 
@@ -449,6 +484,17 @@
 	7,		5,		6,	
 	19,		17,		18
 };
+//CHRISL: New arrays to deal with backpack button positions
+INT8		gbDropPackButPos[2][2] =
+{
+	2,	3,
+	3,	2
+};
+INT8		gbZipperButPos[2][2] =
+{
+	0,	1,
+	1,	0
+};
 
 
 // Mouse button and region callbacks
@@ -475,6 +521,13 @@
 void BtnSMDoneCallback(GUI_BUTTON *btn,INT32 reason);
 void BtnMapScreenCallback(GUI_BUTTON *btn,INT32 reason);
 
+// CHRISL: New callback functions for backpack buttons
+void BtnDropPackCallback(GUI_BUTTON *btn,INT32 reason);
+void BtnZipperCallback(GUI_BUTTON *btn,INT32 reason);
+void BtnMapDropPackCallback( GUI_BUTTON *btn, INT32 reason );
+BOOLEAN ChangeZipperStatus(SOLDIERTYPE *pSoldier, BOOLEAN newStatus);
+BOOLEAN ChangeDropPackStatus(SOLDIERTYPE *pSoldier, BOOLEAN newStatus);
+
 void BtnPrevMercCallback(GUI_BUTTON *btn,INT32 reason);
 void BtnNextMercCallback(GUI_BUTTON *btn,INT32 reason);
 void BtnOptionsCallback(GUI_BUTTON *btn,INT32 reason);
@@ -543,6 +596,9 @@
 	SOLDIERTYPE		*pSoldier;
 	UINT8			ubSrcSoldier;
 
+	// CHRISL: If Merc hasn't been set, default to first merc
+	if(gpSMCurrentMerc==NULL)
+		gpSMCurrentMerc = MercPtrs[ 0 ];
 	Assert( gpSMCurrentMerc != NULL);
 
 	if ( guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE )
@@ -802,6 +858,7 @@
 		giSMStealthButton = QuickCreateButton( giSMStealthImages, SM_STEALTHMODE_X, SM_STEALTHMODE_Y,
 										BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1,
 										DEFAULT_MOVE_CALLBACK, (GUI_CALLBACK)BtnStealthModeCallback );
+		RenderBackpackButtons(0);	/* CHRISL: Needed for new inventory backpack buttons */
 
 		SetButtonFastHelpText( giSMStealthButton, TacticalStr[ TOGGLE_STEALTH_MODE_POPUPTEXT ] );
 
@@ -813,6 +870,7 @@
 			{
 					DisableButton( giSMStealthButton );
 			}
+			RenderBackpackButtons(3);	/* CHRISL: Needed for new inventory backpack buttons */
 		}
 	}
 
@@ -989,6 +1047,7 @@
 		{
 				DisableButton( giSMStealthButton );
 		}
+		RenderBackpackButtons(3);	/* CHRISL: Needed for new inventory backpack buttons */
 	}
 	else
 	{
@@ -1009,6 +1068,7 @@
 		{
 				EnableButton( giSMStealthButton );
 		}
+		RenderBackpackButtons(2);	/* CHRISL: Needed for new inventory backpack buttons */
 	}
 
 	// CJC Dec 4 2002: or if item pickup menu is up
@@ -1068,7 +1128,78 @@
 	fInterfacePanelDirty = DIRTYLEVEL2;
 }
 
+//CHRISL: Function to handle backpack button rendering
+void RenderBackpackButtons(int bpAction)
+{
+	// Only run function if we're using new inventory system
+	if(!gGameOptions.ubInventorySystem)
+		return;
+	// Only run this if we're not on the strategic screen
+	if(guiCurrentItemDescriptionScreen == MAP_SCREEN)
+		return;
+	// If Merc hasn't been set, default to first merc
+	if(gpSMCurrentMerc==NULL)
+		gpSMCurrentMerc = MercPtrs[ 0 ];
+	Assert(gpSMCurrentMerc!=NULL);
+	// Deal with buttons depending on which screen is currently active
+	switch (bpAction)
+	{
+		case 0:
+			// Activate buttons
+			if(giSMZipperButton != -1)
+				RemoveButton( giSMZipperButton );
+			if(giSMZipperImages != -1)
+				UnloadButtonImage( giSMZipperImages );
+			if(giSMDropPackButton != -1)
+				RemoveButton( giSMDropPackButton );
+			if(giSMDropPackImages != -1)
+				UnloadButtonImage( giSMDropPackImages );
+			giSMZipperImages	= UseLoadedButtonImage( iSMPanelImages[ BACKPACK_IMAGES  ] ,gbZipperButPos[ gpSMCurrentMerc->ZipperFlag ][0] ,gbZipperButPos[ gpSMCurrentMerc->ZipperFlag ][0],-1,gbZipperButPos[ gpSMCurrentMerc->ZipperFlag ][1],-1 );
+			giSMDropPackImages	= UseLoadedButtonImage( iSMPanelImages[ BACKPACK_IMAGES  ] ,gbDropPackButPos[ gpSMCurrentMerc->DropPackFlag ][0] ,gbDropPackButPos[ gpSMCurrentMerc->DropPackFlag ][0],-1,gbDropPackButPos[ gpSMCurrentMerc->DropPackFlag ][1],-1 );
 
+			giSMZipperButton	= QuickCreateButton( giSMZipperImages, SM_ZIPPER_X, SM_ZIPPER_Y,
+													BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1,
+													DEFAULT_MOVE_CALLBACK, (GUI_CALLBACK)BtnZipperCallback );
+			giSMDropPackButton	= QuickCreateButton( giSMDropPackImages, SM_DROPPACK_X, SM_DROPPACK_Y,
+													BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1,
+													DEFAULT_MOVE_CALLBACK, (GUI_CALLBACK)BtnDropPackCallback );
+			//SetButtonFastHelpText( giSMZipperButton, TacticalStr[  ] );
+			//SetButtonFastHelpText( giSMDropPackButton, TacticalStr[  ] );
+			break;
+		case 1:
+			// Deactivate buttons
+			if(giSMZipperButton != -1)
+				RemoveButton( giSMZipperButton );
+			if(giSMDropPackButton != -1)
+				RemoveButton( giSMDropPackButton );
+			giSMDropPackImages	= -1;
+			giSMDropPackButton	= -1;
+			giSMZipperImages	= -1;
+			giSMZipperButton	= -1;
+			break;
+		case 2:
+			// Enable buttons
+			if(giSMDropPackButton != -1)
+				EnableButton( giSMDropPackButton );
+			if(giSMZipperButton != -1)
+				EnableButton( giSMZipperButton );
+			break;
+		case 3:
+			// Disable buttons
+			if(giSMDropPackButton != -1)
+				DisableButton( giSMDropPackButton );
+			if(giSMZipperButton != -1)
+				DisableButton( giSMZipperButton );
+			break;
+		case 4:
+			if(giSMZipperImages != -1)
+				UnloadButtonImage( giSMZipperImages );
+			if(giSMDropPackImages != -1)
+				UnloadButtonImage( giSMDropPackImages );
+			break;
+	}
+}
+
 void EnableSMPanelButtons( BOOLEAN fEnable , BOOLEAN fFromItemPickup )
 {
 	if ( fFromItemPickup )
@@ -1140,6 +1271,7 @@
 				{
 					EnableButton( giSMStealthButton );
 				}
+				RenderBackpackButtons(2);	/* CHRISL: Needed for new inventory backpack buttons */
 
 				if ( gfDisableTacticalPanelButtons )
 				{
@@ -1182,6 +1314,7 @@
 			{
 					DisableButton( giSMStealthButton );
 			}
+			RenderBackpackButtons(3);	/* CHRISL: Needed for new inventory backpack buttons */
 
 			if ( !fFromItemPickup )
 			{
@@ -1207,9 +1340,31 @@
 	return( gusSMCurrentMerc );
 }
 
+// CHRISL: New functions to define initial settings for New Inventory system
+void InitNewInventorySystem( )
+{
+	INTERFACE_WIDTH			= 640;
+	INTERFACE_HEIGHT		= 120;
+	INV_INTERFACE_HEIGHT	= 200;
+	INTERFACE_START_X		= 0;
+	INTERFACE_START_Y		= ( SCREEN_HEIGHT - INTERFACE_HEIGHT );
+	INV_INTERFACE_START_Y	= ( SCREEN_HEIGHT - INV_INTERFACE_HEIGHT );
+}
 
-BOOLEAN InitializeSMPanelCoords( )
+// CHRISL: New functions to define initial settings for Old Inventory system
+void InitOldInventorySystem( )
 {
+	INTERFACE_WIDTH			= 640;
+	INTERFACE_HEIGHT		= 120;
+	INV_INTERFACE_HEIGHT	= 140;
+	INTERFACE_START_X		= 0;
+	INTERFACE_START_Y		= ( SCREEN_HEIGHT - INTERFACE_HEIGHT );
+	INV_INTERFACE_START_Y	= ( SCREEN_HEIGHT - INV_INTERFACE_HEIGHT );
+}
+
+// CHRISL: These functions will setup inventory panel coords based on game options
+BOOLEAN InitializeSMPanelCoordsOld()
+{
 	// int i; // unused (jonathanl)
 	/* 
 	 * now i use standard positions and i add to them starting coords of panel but 
@@ -1218,25 +1373,25 @@
 	 * any questions? joker
 	 */
 	// Inventory slots
-	gSMInvPocketXY[0].sX = INTERFACE_START_X + 344;		gSMInvPocketXY[0].sY = INV_INTERFACE_START_Y + 7;	// HELMETPOS
-	gSMInvPocketXY[1].sX = INTERFACE_START_X + 344;		gSMInvPocketXY[1].sY = INV_INTERFACE_START_Y + 36;	// VESTPOS
-	gSMInvPocketXY[2].sX = INTERFACE_START_X + 344;		gSMInvPocketXY[2].sY = INV_INTERFACE_START_Y + 96;	// LEGPOS,
-	gSMInvPocketXY[3].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[3].sY = INV_INTERFACE_START_Y + 7;	// HEAD1POS
-	gSMInvPocketXY[4].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[4].sY = INV_INTERFACE_START_Y + 31;	// HEAD2POS
-	gSMInvPocketXY[5].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[5].sY = INV_INTERFACE_START_Y + 84;	// HANDPOS,
-	gSMInvPocketXY[6].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[6].sY = INV_INTERFACE_START_Y + 108;	// SECONDHANDPOS
-	gSMInvPocketXY[7].sX = INTERFACE_START_X + 468;		gSMInvPocketXY[7].sY = INV_INTERFACE_START_Y + 6;	// BIGPOCK1
-	gSMInvPocketXY[8].sX = INTERFACE_START_X + 468;		gSMInvPocketXY[8].sY = INV_INTERFACE_START_Y + 30;	// BIGPOCK2
-	gSMInvPocketXY[9].sX = INTERFACE_START_X + 468;		gSMInvPocketXY[9].sY = INV_INTERFACE_START_Y + 54;	// BIGPOCK3
-	gSMInvPocketXY[10].sX = INTERFACE_START_X + 468;	gSMInvPocketXY[10].sY = INV_INTERFACE_START_Y + 78;	// BIGPOCK4
-	gSMInvPocketXY[11].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[11].sY = INV_INTERFACE_START_Y + 6;	// SMALLPOCK1
-	gSMInvPocketXY[12].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[12].sY = INV_INTERFACE_START_Y + 30;	// SMALLPOCK2
-	gSMInvPocketXY[13].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[13].sY = INV_INTERFACE_START_Y + 54;	// SMALLPOCK3
-	gSMInvPocketXY[14].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[14].sY = INV_INTERFACE_START_Y + 78;	// SMALLPOCK4
-	gSMInvPocketXY[15].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[15].sY = INV_INTERFACE_START_Y + 6;	// SMALLPOCK5
-	gSMInvPocketXY[16].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[16].sY = INV_INTERFACE_START_Y + 30;	// SMALLPOCK6
-	gSMInvPocketXY[17].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[17].sY = INV_INTERFACE_START_Y + 54;	// SMALLPOCK7
-	gSMInvPocketXY[18].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[18].sY = INV_INTERFACE_START_Y + 78;	// SMALLPOCK8
+	gSMInvPocketXY[HELMETPOS].sX = INTERFACE_START_X + 344;		gSMInvPocketXY[HELMETPOS].sY = INV_INTERFACE_START_Y + 7;	// HELMETPOS
+	gSMInvPocketXY[VESTPOS].sX = INTERFACE_START_X + 344;		gSMInvPocketXY[VESTPOS].sY = INV_INTERFACE_START_Y + 36;	// VESTPOS
+	gSMInvPocketXY[LEGPOS].sX = INTERFACE_START_X + 344;		gSMInvPocketXY[LEGPOS].sY = INV_INTERFACE_START_Y + 96;	// LEGPOS,
+	gSMInvPocketXY[HEAD1POS].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[HEAD1POS].sY = INV_INTERFACE_START_Y + 7;	// HEAD1POS
+	gSMInvPocketXY[HEAD2POS].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[HEAD2POS].sY = INV_INTERFACE_START_Y + 31;	// HEAD2POS
+	gSMInvPocketXY[HANDPOS].sX = INTERFACE_START_X + 226;		gSMInvPocketXY[HANDPOS].sY = INV_INTERFACE_START_Y + 84;	// HANDPOS,
+	gSMInvPocketXY[SECONDHANDPOS].sX = INTERFACE_START_X + 226;	gSMInvPocketXY[SECONDHANDPOS].sY = INV_INTERFACE_START_Y + 108;	// SECONDHANDPOS
+	gSMInvPocketXY[BIGPOCK1POS].sX = INTERFACE_START_X + 468;	gSMInvPocketXY[BIGPOCK1POS].sY = INV_INTERFACE_START_Y + 6;	// BIGPOCK1
+	gSMInvPocketXY[BIGPOCK2POS].sX = INTERFACE_START_X + 468;	gSMInvPocketXY[BIGPOCK2POS].sY = INV_INTERFACE_START_Y + 30;	// BIGPOCK2
+	gSMInvPocketXY[BIGPOCK3POS].sX = INTERFACE_START_X + 468;	gSMInvPocketXY[BIGPOCK3POS].sY = INV_INTERFACE_START_Y + 54;	// BIGPOCK3
+	gSMInvPocketXY[BIGPOCK4POS].sX = INTERFACE_START_X + 468;	gSMInvPocketXY[BIGPOCK4POS].sY = INV_INTERFACE_START_Y + 78;	// BIGPOCK4
+	gSMInvPocketXY[SMALLPOCK1POS].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[SMALLPOCK1POS].sY = INV_INTERFACE_START_Y + 6;	// SMALLPOCK1
+	gSMInvPocketXY[SMALLPOCK2POS].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[SMALLPOCK2POS].sY = INV_INTERFACE_START_Y + 30;	// SMALLPOCK2
+	gSMInvPocketXY[SMALLPOCK3POS].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[SMALLPOCK3POS].sY = INV_INTERFACE_START_Y + 54;	// SMALLPOCK3
+	gSMInvPocketXY[SMALLPOCK4POS].sX = INTERFACE_START_X + 396;	gSMInvPocketXY[SMALLPOCK4POS].sY = INV_INTERFACE_START_Y + 78;	// SMALLPOCK4
+	gSMInvPocketXY[SMALLPOCK5POS].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[SMALLPOCK5POS].sY = INV_INTERFACE_START_Y + 6;	// SMALLPOCK5
+	gSMInvPocketXY[SMALLPOCK6POS].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[SMALLPOCK6POS].sY = INV_INTERFACE_START_Y + 30;	// SMALLPOCK6
+	gSMInvPocketXY[SMALLPOCK7POS].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[SMALLPOCK7POS].sY = INV_INTERFACE_START_Y + 54;	// SMALLPOCK7
+	gSMInvPocketXY[SMALLPOCK8POS].sX = INTERFACE_START_X + 432;	gSMInvPocketXY[SMALLPOCK8POS].sY = INV_INTERFACE_START_Y + 78;	// SMALLPOCK8
 	
 	SM_ITEMDESC_START_X		= ( 214 + INTERFACE_START_X );
 	SM_ITEMDESC_START_Y		= ( 1 +   INV_INTERFACE_START_Y );
@@ -1387,9 +1542,245 @@
 	LOCATION_NAME_X		=	(SCREEN_WIDTH - 92);				//( 548	+ INTERFACE_START_X		);
 	LOCATION_NAME_Y		= ( 65	+ INTERFACE_START_Y		);
 
+	// Keyring
+	KEYRING_X			= 487;
+	KEYRING_Y			= (105 + INV_INTERFACE_START_Y);
+
 	// so we got everything "dynamic" now we just return TRUE
 	return ( TRUE );
 }
+BOOLEAN InitializeSMPanelCoordsNew()
+{
+	// int i; // unused (jonathanl)
+	/* 
+	 * now i use standard positions and i add to them starting coords of panel but 
+	 * we can add here function that will read coord in panel from file
+	 * that will be phase2 of making GUI more customizable
+	 * any questions? joker
+	 */
+	/* CHRISL: Inventory slot information was completly altered to allow for new inventory pockets and
+	to allow the new inventory interface to function properly. Also altered many of the interface coords
+	so that the new interface would line up correctly.*/
+	// Inventory slots
+	gSMInvPocketXY[0].sX = INTERFACE_START_X + 258;		gSMInvPocketXY[0].sY = INV_INTERFACE_START_Y + 68;		// HELMETPOS
+	gSMInvPocketXY[1].sX = INTERFACE_START_X + 258;		gSMInvPocketXY[1].sY = INV_INTERFACE_START_Y + 96;		// VESTPOS
+	gSMInvPocketXY[2].sX = INTERFACE_START_X + 258;		gSMInvPocketXY[2].sY = INV_INTERFACE_START_Y + 157;		// LEGPOS
+	gSMInvPocketXY[3].sX = INTERFACE_START_X + 124;		gSMInvPocketXY[3].sY = INV_INTERFACE_START_Y + 68;		// HEAD1POS
+	gSMInvPocketXY[4].sX = INTERFACE_START_X + 124;		gSMInvPocketXY[4].sY = INV_INTERFACE_START_Y + 92;		// HEAD2POS
+	gSMInvPocketXY[5].sX = INTERFACE_START_X + 124;		gSMInvPocketXY[5].sY = INV_INTERFACE_START_Y + 146;		// HANDPOS
+	gSMInvPocketXY[6].sX = INTERFACE_START_X + 124;		gSMInvPocketXY[6].sY = INV_INTERFACE_START_Y + 170;		// SECONDHANDPOS
+	gSMInvPocketXY[7].sX = INTERFACE_START_X + 284;		gSMInvPocketXY[7].sY = INV_INTERFACE_START_Y + 13;		// VESTPOCK
+	gSMInvPocketXY[8].sX = INTERFACE_START_X + 323;		gSMInvPocketXY[8].sY = INV_INTERFACE_START_Y + 79;		// LTHIGHPOCK
+	gSMInvPocketXY[9].sX = INTERFACE_START_X + 439;		gSMInvPocketXY[9].sY = INV_INTERFACE_START_Y + 79;		// RTHIGHPOCK
+	gSMInvPocketXY[10].sX = INTERFACE_START_X + 586;	gSMInvPocketXY[10].sY = INV_INTERFACE_START_Y + 79;		// CPACKPOCK
+	gSMInvPocketXY[11].sX = INTERFACE_START_X + 594;	gSMInvPocketXY[11].sY = INV_INTERFACE_START_Y + 13;		// BPACKPOCK
+	gSMInvPocketXY[12].sX = INTERFACE_START_X + 505;	gSMInvPocketXY[12].sY = INV_INTERFACE_START_Y + 79;		// GUNSLINGPOCKPOS
+	gSMInvPocketXY[13].sX = INTERFACE_START_X + 388;	gSMInvPocketXY[13].sY = INV_INTERFACE_START_Y + 79;		// KNIFEPOCKPOS
+	gSMInvPocketXY[14].sX = INTERFACE_START_X + 566;	gSMInvPocketXY[14].sY = INV_INTERFACE_START_Y + 116;	// BIGPOCK1
+	gSMInvPocketXY[15].sX = INTERFACE_START_X + 566;	gSMInvPocketXY[15].sY = INV_INTERFACE_START_Y + 140;	// BIGPOCK2
+	gSMInvPocketXY[16].sX = INTERFACE_START_X + 566;	gSMInvPocketXY[16].sY = INV_INTERFACE_START_Y + 164;	// BIGPOCK3
+	gSMInvPocketXY[17].sX = INTERFACE_START_X + 729;	gSMInvPocketXY[17].sY = INV_INTERFACE_START_Y + 10;		// BIGPOCK4
+	gSMInvPocketXY[18].sX = INTERFACE_START_X + 729;	gSMInvPocketXY[18].sY = INV_INTERFACE_START_Y + 34;		// BIGPOCK5
+	gSMInvPocketXY[19].sX = INTERFACE_START_X + 729;	gSMInvPocketXY[19].sY = INV_INTERFACE_START_Y + 58;		// BIGPOCK6
+	gSMInvPocketXY[20].sX = INTERFACE_START_X + 729;	gSMInvPocketXY[20].sY = INV_INTERFACE_START_Y + 82;		// BIGPOCK7
+	gSMInvPocketXY[21].sX = INTERFACE_START_X + 527;	gSMInvPocketXY[21].sY = INV_INTERFACE_START_Y + 10;		// MEDPOCK1
+	gSMInvPocketXY[22].sX = INTERFACE_START_X + 527;	gSMInvPocketXY[22].sY = INV_INTERFACE_START_Y + 34;		// MEDPOCK2
+	gSMInvPocketXY[23].sX = INTERFACE_START_X + 333;	gSMInvPocketXY[23].sY = INV_INTERFACE_START_Y + 164;	// MEDPOCK3
+	gSMInvPocketXY[24].sX = INTERFACE_START_X + 419;	gSMInvPocketXY[24].sY = INV_INTERFACE_START_Y + 164;	// MEDPOCK4
+	gSMInvPocketXY[25].sX = INTERFACE_START_X + 347;	gSMInvPocketXY[25].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK1
+	gSMInvPocketXY[26].sX = INTERFACE_START_X + 383;	gSMInvPocketXY[26].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK2
+	gSMInvPocketXY[27].sX = INTERFACE_START_X + 419;	gSMInvPocketXY[27].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK3
+	gSMInvPocketXY[28].sX = INTERFACE_START_X + 455;	gSMInvPocketXY[28].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK4
+	gSMInvPocketXY[29].sX = INTERFACE_START_X + 491;	gSMInvPocketXY[29].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK5
+	gSMInvPocketXY[30].sX = INTERFACE_START_X + 347;	gSMInvPocketXY[30].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK6
+	gSMInvPocketXY[31].sX = INTERFACE_START_X + 383;	gSMInvPocketXY[31].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK7
+	gSMInvPocketXY[32].sX = INTERFACE_START_X + 419;	gSMInvPocketXY[32].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK8	
+	gSMInvPocketXY[33].sX = INTERFACE_START_X + 455;	gSMInvPocketXY[33].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK9
+	gSMInvPocketXY[34].sX = INTERFACE_START_X + 491;	gSMInvPocketXY[34].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK10
+	gSMInvPocketXY[35].sX = INTERFACE_START_X + 322;	gSMInvPocketXY[35].sY = INV_INTERFACE_START_Y + 116;	// SMALLPOCK11
+	gSMInvPocketXY[36].sX = INTERFACE_START_X + 358;	gSMInvPocketXY[36].sY = INV_INTERFACE_START_Y + 116;	// SMALLPOCK12
+	gSMInvPocketXY[37].sX = INTERFACE_START_X + 322;	gSMInvPocketXY[37].sY = INV_INTERFACE_START_Y + 140;	// SMALLPOCK13
+	gSMInvPocketXY[38].sX = INTERFACE_START_X + 358;	gSMInvPocketXY[38].sY = INV_INTERFACE_START_Y + 140;	// SMALLPOCK14
+	gSMInvPocketXY[39].sX = INTERFACE_START_X + 408;	gSMInvPocketXY[39].sY = INV_INTERFACE_START_Y + 116;	// SMALLPOCK15
+	gSMInvPocketXY[40].sX = INTERFACE_START_X + 444;	gSMInvPocketXY[40].sY = INV_INTERFACE_START_Y + 116;	// SMALLPOCK16
+	gSMInvPocketXY[41].sX = INTERFACE_START_X + 408;	gSMInvPocketXY[41].sY = INV_INTERFACE_START_Y + 140;	// SMALLPOCK17
+	gSMInvPocketXY[42].sX = INTERFACE_START_X + 444;	gSMInvPocketXY[42].sY = INV_INTERFACE_START_Y + 140;	// SMALLPOCK18
+	gSMInvPocketXY[43].sX = INTERFACE_START_X + 494;	gSMInvPocketXY[43].sY = INV_INTERFACE_START_Y + 116;	// SMALLPOCK19
+	gSMInvPocketXY[44].sX = INTERFACE_START_X + 530;	gSMInvPocketXY[44].sY = INV_INTERFACE_START_Y + 116;	// SMALLPOCK20
+	gSMInvPocketXY[45].sX = INTERFACE_START_X + 494;	gSMInvPocketXY[45].sY = INV_INTERFACE_START_Y + 140;	// SMALLPOCK21
+	gSMInvPocketXY[46].sX = INTERFACE_START_X + 530;	gSMInvPocketXY[46].sY = INV_INTERFACE_START_Y + 140;	// SMALLPOCK22
+	gSMInvPocketXY[47].sX = INTERFACE_START_X + 657;	gSMInvPocketXY[47].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK23
+	gSMInvPocketXY[48].sX = INTERFACE_START_X + 657;	gSMInvPocketXY[48].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK24
+	gSMInvPocketXY[49].sX = INTERFACE_START_X + 657;	gSMInvPocketXY[49].sY = INV_INTERFACE_START_Y + 58;		// SMALLPOCK25
+	gSMInvPocketXY[50].sX = INTERFACE_START_X + 657;	gSMInvPocketXY[50].sY = INV_INTERFACE_START_Y + 82;		// SMALLPOCK26
+	gSMInvPocketXY[51].sX = INTERFACE_START_X + 693;	gSMInvPocketXY[51].sY = INV_INTERFACE_START_Y + 10;		// SMALLPOCK27
+	gSMInvPocketXY[52].sX = INTERFACE_START_X + 693;	gSMInvPocketXY[52].sY = INV_INTERFACE_START_Y + 34;		// SMALLPOCK28
+	gSMInvPocketXY[53].sX = INTERFACE_START_X + 693;	gSMInvPocketXY[53].sY = INV_INTERFACE_START_Y + 58;		// SMALLPOCK29
+	gSMInvPocketXY[54].sX = INTERFACE_START_X + 693;	gSMInvPocketXY[54].sY = INV_INTERFACE_START_Y + 82;		// SMALLPOCK30
+
+	SM_ITEMDESC_START_X		= ( 115 + INTERFACE_START_X );
+	SM_ITEMDESC_START_Y		= ( 1 +   INV_INTERFACE_START_Y );
+	SM_ITEMDESC_HEIGHT		= 128;
+	SM_ITEMDESC_WIDTH		= 358;
+
+	SM_SELMERC_AP_X			= ( 71 + INTERFACE_START_X );
+	SM_SELMERC_AP_Y			= ( 53 + INV_INTERFACE_START_Y );
+	SM_SELMERC_AP_HEIGHT	= 12;
+	SM_SELMERC_AP_WIDTH		= 11;
+ 
+	SM_SELMERC_HEALTH_X		= ( 70 + INTERFACE_START_X );
+	SM_SELMERC_HEALTH_Y		= ( 48 + INV_INTERFACE_START_Y );
+	SM_SELMERC_HEALTH_WIDTH = 3;
+	SM_SELMERC_HEALTH_HEIGHT = 42;
+
+	SM_SELMERC_BREATH_X		= ( 76 + INTERFACE_START_X );
+	SM_SELMERC_BREATH_Y		= ( 48 + INV_INTERFACE_START_Y );
+	SM_SELMERC_BREATH_WIDTH = 3;
+	SM_SELMERC_BREATH_HEIGHT = 42;
+
+	SM_SELMERC_MORALE_X		= ( 82 + INTERFACE_START_X );
+	SM_SELMERC_MORALE_Y		= ( 48 + INV_INTERFACE_START_Y );
+	SM_SELMERC_MORALE_WIDTH = 3;
+	SM_SELMERC_MORALE_HEIGHT = 42;
+
+	SM_SELMERC_BARS_TIP_X	= (	SM_SELMERC_HEALTH_X - SM_SELMERC_HEALTH_WIDTH );
+	SM_SELMERC_BARS_TIP_Y	= ( SM_SELMERC_HEALTH_Y - SM_SELMERC_HEALTH_HEIGHT );
+	SM_SELMERC_BARS_TIP_WIDTH = ((SM_SELMERC_BREATH_WIDTH + 4) *3);
+	SM_SELMERC_BARS_TIP_HEIGHT= ( SM_SELMERC_HEALTH_HEIGHT );
+
+	SM_SELMERCNAME_X		= ( 12 + INTERFACE_START_X );
+	SM_SELMERCNAME_Y		= ( 55 + INV_INTERFACE_START_Y );
+	SM_SELMERCNAME_WIDTH	= 53;
+	SM_SELMERCNAME_HEIGHT	= 11;
+
+	SM_SELMERC_FACE_X		= ( 14 + INTERFACE_START_X );
+	SM_SELMERC_FACE_Y		= ( 5 + INV_INTERFACE_START_Y );
+	SM_SELMERC_FACE_HEIGHT	= 42;
+	SM_SELMERC_FACE_WIDTH	= 48;
+
+	SM_SELMERC_PLATE_X		= ( 5 + INTERFACE_START_X );
+	SM_SELMERC_PLATE_Y		= ( 2 + INV_INTERFACE_START_Y );
+	SM_SELMERC_PLATE_HEIGHT = 65;
+	SM_SELMERC_PLATE_WIDTH	= 83;
+
+	SM_BODYINV_X			= ( 151 + INTERFACE_START_X );
+	SM_BODYINV_Y			= ( 68 + INV_INTERFACE_START_Y );
+
+	// Cammo
+	gSMCamoXY.sX = SM_BODYINV_X; gSMCamoXY.sY = SM_BODYINV_Y;
+
+	SM_UPDOWNB_X			= ( 8 + INTERFACE_START_X );
+	SM_UPDOWNB_Y			= ( 70 + INV_INTERFACE_START_Y );
+	SM_HANDCURSORB_X		= ( 33 + INTERFACE_START_X );
+	SM_HANDCURSORB_Y		= ( 70 + INV_INTERFACE_START_Y );
+	SM_CLIMBB_X				= ( 58 + INTERFACE_START_X );
+	SM_CLIMBB_Y				= ( 70 + INV_INTERFACE_START_Y );
+	SM_MUTEB_X				= ( 8 + INTERFACE_START_X );
+	SM_MUTEB_Y				= ( 98 + INV_INTERFACE_START_Y );
+	SM_LOOKB_X				= ( 33 + INTERFACE_START_X );
+	SM_LOOKB_Y				= ( 98 + INV_INTERFACE_START_Y );
+	SM_TALKB_X				= ( 58 + INTERFACE_START_X );
+	SM_TALKB_Y				= ( 98 + INV_INTERFACE_START_Y );
+	SM_STANCEUPB_X			= ( 88 + INTERFACE_START_X );
+	SM_STANCEUPB_Y			= ( 70 + INV_INTERFACE_START_Y );
+	SM_STEALTHMODE_X		= ( 88 + INTERFACE_START_X );
+	SM_STEALTHMODE_Y		= ( 98 + INV_INTERFACE_START_Y );
+	SM_STANCEDOWNB_X		= ( 88 + INTERFACE_START_X );
+	SM_STANCEDOWNB_Y		= ( 126 + INV_INTERFACE_START_Y );
+	SM_BURSTMODEB_X			= ( 88 + INTERFACE_START_X );
+	SM_BURSTMODEB_Y			= ( 167 + INV_INTERFACE_START_Y );
+	SM_PREVMERCB_X			= ( 10 + INTERFACE_START_X );
+	SM_PREVMERCB_Y			= ( 130 + INV_INTERFACE_START_Y );
+	SM_NEXTMERCB_X			= ( 52 + INTERFACE_START_X );
+	SM_NEXTMERCB_Y			= ( 130 + INV_INTERFACE_START_Y );
+	SM_OPTIONSB_X			= ( 10 + INTERFACE_START_X );
+	SM_OPTIONSB_Y			= ( 165 + INV_INTERFACE_START_Y );
+	// CHRISL: Backpack buttons
+	SM_DROPPACK_X			= ( 612 + INTERFACE_START_X );
+	SM_DROPPACK_Y			= ( 39 + INV_INTERFACE_START_Y );
+	SM_ZIPPER_X				= ( 590 + INTERFACE_START_X );
+	SM_ZIPPER_Y				= ( 39 + INV_INTERFACE_START_Y );
+
+	// WANNE 2
+	SM_DONE_X				=  (SCREEN_WIDTH - 152);
+	SM_DONE_Y				= ( 118 + INV_INTERFACE_START_Y );
+	SM_MAPSCREEN_X			=  (SCREEN_WIDTH - 152);
+	SM_MAPSCREEN_Y			= ( 140 + INV_INTERFACE_START_Y );
+
+	SM_POSITIONB_X			= ( 106 + INTERFACE_START_X );
+	SM_POSITIONB_Y			= ( 34 + INV_INTERFACE_START_Y );
+	SM_POSITIONB_WIDTH		= 19;
+	SM_POSITIONB_HEIGHT		= 24;
+
+	SM_PERCENT_WIDTH		= 20;
+	SM_PERCENT_HEIGHT		= 10;
+	SM_ARMOR_X				= ( 264 + INTERFACE_START_X );
+	SM_ARMOR_Y				= ( 141 + INV_INTERFACE_START_Y );
+	SM_ARMOR_LABEL_X		= ( 279 + INTERFACE_START_X );
+	SM_ARMOR_LABEL_Y		= ( 131 + INV_INTERFACE_START_Y );
+	SM_ARMOR_PERCENT_X		= ( 284 + INTERFACE_START_X );
+	SM_ARMOR_PERCENT_Y		= ( 141 + INV_INTERFACE_START_Y );
+
+	SM_WEIGHT_LABEL_X		= ( 220 + INTERFACE_START_X );
+	SM_WEIGHT_LABEL_Y		= ( 34 + INV_INTERFACE_START_Y );
+	SM_WEIGHT_PERCENT_X		= ( 239 + INTERFACE_START_X );
+	SM_WEIGHT_PERCENT_Y		= ( 34 + INV_INTERFACE_START_Y );
+	SM_WEIGHT_X				= ( 218 + INTERFACE_START_X );
+	SM_WEIGHT_Y				= ( 33 + INV_INTERFACE_START_Y );
+
+	SM_CAMMO_LABEL_X		= ( 220 + INTERFACE_START_X );
+	SM_CAMMO_LABEL_Y		= ( 50 + INV_INTERFACE_START_Y );
+	SM_CAMMO_PERCENT_X		= ( 239 + INTERFACE_START_X );
+	SM_CAMMO_PERCENT_Y		= ( 49 + INV_INTERFACE_START_Y );
+	SM_CAMMO_X				= ( 218 + INTERFACE_START_X );
+	SM_CAMMO_Y				= ( 49 + INV_INTERFACE_START_Y );
+
+	SM_STATS_WIDTH			= 30;
+	SM_STATS_HEIGHT			= 8 ;
+	SM_AGI_X				= ( 101 + INTERFACE_START_X );
+	SM_AGI_Y				= ( 7 + INV_INTERFACE_START_Y );
+	SM_DEX_X				= ( 101 + INTERFACE_START_X );
+	SM_DEX_Y				= ( 17 + INV_INTERFACE_START_Y );
+	SM_STR_X				= ( 101 + INTERFACE_START_X );
+	SM_STR_Y				= ( 27 + INV_INTERFACE_START_Y );
+	SM_CHAR_X				= ( 101 + INTERFACE_START_X );
+	SM_CHAR_Y				= ( 37 + INV_INTERFACE_START_Y );
+	SM_WIS_X				= ( 101 + INTERFACE_START_X );
+	SM_WIS_Y				= ( 47 + INV_INTERFACE_START_Y );
+	SM_EXPLVL_X				= ( 150 + INTERFACE_START_X );
+	SM_EXPLVL_Y				= ( 7 + INV_INTERFACE_START_Y );
+	SM_MRKM_X				= ( 150 + INTERFACE_START_X );
+	SM_MRKM_Y				= ( 17 + INV_INTERFACE_START_Y );
+	SM_EXPL_X				= ( 150 + INTERFACE_START_X );
+	SM_EXPL_Y				= ( 27 + INV_INTERFACE_START_Y );
+	SM_MECH_X				= ( 150 + INTERFACE_START_X );
+	SM_MECH_Y				= ( 37 + INV_INTERFACE_START_Y );
+	SM_MED_X				= ( 150 + INTERFACE_START_X );
+	SM_MED_Y				= ( 47 + INV_INTERFACE_START_Y );
+
+	MONEY_X					= ( 185 + INTERFACE_START_X );
+	MONEY_Y					= ( 5 + INV_INTERFACE_START_Y );
+	MONEY_WIDTH				= 30;
+	MONEY_HEIGHT			= 22;
+	
+	// ow ye font color they can also be customizable :P
+	STATS_TITLE_FONT_COLOR	= 6;
+	STATS_TEXT_FONT_COLOR	= 5;
+
+	// ow and te clock and location i will put it here 
+	INTERFACE_CLOCK_X	=  	(SCREEN_WIDTH - 86);
+	INTERFACE_CLOCK_Y	= ( 116	+ INV_INTERFACE_START_Y );
+	LOCATION_NAME_X		=	(SCREEN_WIDTH - 92);
+	LOCATION_NAME_Y		= ( 87	+ INTERFACE_START_Y		);
+
+	//Keyring
+	KEYRING_X			= 209;
+	KEYRING_Y			= (4 + INV_INTERFACE_START_Y);
+
+	// so we got everything "dynamic" now we just return TRUE
+	return ( TRUE );
+}
+
 BOOLEAN InitializeSMPanel(  )
 {
   VOBJECT_DESC    VObjectDesc;
@@ -1523,8 +1914,9 @@
 {
 CHAR8 ubString[48];
 
-	giSMStealthImages = -1;
-	giSMStealthButton = -1;
+	// CHRISL: Reset backpack buttons as well
+	giSMStealthImages = giSMZipperImages = giSMDropPackImages = -1;
+	giSMStealthButton = giSMZipperButton = giSMDropPackButton = -1;
 	gfUIStanceDifferent = TRUE;
 	gfAllDisabled	= FALSE;
 
@@ -1561,6 +1953,9 @@
 	iSMPanelImages[ DONE_IMAGES  ]					= LoadButtonImage(ubString,-1,1,-1,3,-1 );
 	iSMPanelImages[ MAPSCREEN_IMAGES  ]			= UseLoadedButtonImage( iSMPanelImages[ DONE_IMAGES  ] ,-1,0,-1,2,-1 );
 
+	// CHRISL: Needed for new inventory backpack buttons
+	FilenameForBPP("INTERFACE\\backpack_buttons.sti", ubString);
+	iSMPanelImages[ BACKPACK_IMAGES  ]				= LoadButtonImage(ubString,0,0,-1,2,-1 );
 
 	// Create buttons
 
@@ -1753,11 +2148,13 @@
 	{
 		RemoveButton( giSMStealthButton );
 	}
+	RenderBackpackButtons(1);	/* CHRISL: Needed for new inventory backpack buttons */
 
 	if ( giSMStealthImages != -1 )
 	{
 		UnloadButtonImage( giSMStealthImages );
 	}
+	RenderBackpackButtons(4);	/* CHRISL: Needed for new inventory backpack buttons */
 	
 	UnloadButtonImage( iBurstButtonImages[ WM_NORMAL ] );
 	UnloadButtonImage( iBurstButtonImages[ WM_BURST ] );
@@ -1866,7 +2263,8 @@
 
 		if ( InItemDescriptionBox( ) )
 		{
-			BltVideoObjectFromIndex( guiSAVEBUFFER, guiSMPanel, 0, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL );
+			// CHRISL: Changed 3rd parameter so we can display graphic based on inventory system used
+			BltVideoObjectFromIndex( guiSAVEBUFFER, guiSMPanel, gGameOptions.ubInventorySystem, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL );
 			RenderSoldierFace( gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, TRUE );
 
 
@@ -1890,7 +2288,8 @@
 		else
 		{
 
-			BltVideoObjectFromIndex( guiSAVEBUFFER, guiSMPanel, 0, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL );
+			// CHRISL: Changed 3rd parameter so we can display graphic based on inventory system used
+			BltVideoObjectFromIndex( guiSAVEBUFFER, guiSMPanel, gGameOptions.ubInventorySystem, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL );
 
 			RenderInvBodyPanel( gpSMCurrentMerc, SM_BODYINV_X, SM_BODYINV_Y );		
 
@@ -2155,7 +2554,8 @@
 		// Render clock
 		RenderClock( INTERFACE_CLOCK_X, INTERFACE_CLOCK_Y );
 		CreateMouseRegionForPauseOfClock( INTERFACE_CLOCK_X, INTERFACE_CLOCK_Y );
-		RenderTownIDString( );
+		// CHRISL: Change function call to include X,Y coordinates.
+		RenderTownIDString( LOCATION_NAME_X, LOCATION_NAME_Y );
 	}
 	else
 	{
@@ -2178,8 +2578,11 @@
 		UINT32 uiDestPitchBYTES;
 		SGPRect ClipRect;
 
-		ClipRect.iLeft	 = 87;
-		ClipRect.iRight  = 536;
+		// CHRISL: Change hatching area based on inventory system
+		ClipRect.iLeft = (gGameOptions.ubInventorySystem) ? 0 : 87;
+		ClipRect.iRight = (gGameOptions.ubInventorySystem) ? SCREEN_WIDTH : 536;
+		//ClipRect.iLeft	 = 87;
+		//ClipRect.iRight  = 536;
 		ClipRect.iTop		= INV_INTERFACE_START_Y;
 		ClipRect.iBottom = SCREEN_HEIGHT;
 		pDestBuf = LockVideoSurface( FRAME_BUFFER, &uiDestPitchBYTES );
@@ -2570,6 +2973,10 @@
 	//	fLeftDown = TRUE;
 	//}
 	//else if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP && fLeftDown )
+	// CHRISL: Are we in combat, wearing a backpack with the zipper closed?  Don't allow access to backpack items
+	if(gGameOptions.ubInventorySystem)
+		if(icLBE[uiHandPos] == BPACKPOCKPOS && (!(gpSMCurrentMerc->ZipperFlag) || (gpSMCurrentMerc->ZipperFlag && gAnimControl[gpSMCurrentMerc->usAnimState].ubEndHeight == ANIM_STAND)) && (gTacticalStatus.uiFlags & INCOMBAT) && (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN ))
+			iReason = MSYS_CALLBACK_REASON_NONE;
 	if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
 	{
 		fLeftDown = FALSE;
@@ -2599,6 +3006,33 @@
 				return;
 			}
 			
+			/* CHRISL: For New Inventory system.  Are we removing an existing LBE item?  If so, we need to pull
+			all items in the relevant IC Group pockets out of the soldiers inventory and put them into the LBE items
+			inventory. But first, find out if we already have a LBE item inventory for this item and this merc.  If we 
+			do, remove the items from it and place them into the sector the LBE inventory is located in.*/
+			if(gGameOptions.ubInventorySystem)
+			{
+				if(uiHandPos == VESTPOCKPOS || uiHandPos == LTHIGHPOCKPOS || uiHandPos == RTHIGHPOCKPOS || uiHandPos == CPACKPOCKPOS || uiHandPos == BPACKPOCKPOS)
+				{
+					/*if we pick up a backpack without reactivating the drop pack button, and we have a
+					dropkey, reactivate the button*/
+					if(uiHandPos == BPACKPOCKPOS)
+					{
+						// Deal with the zipper before we do anything
+						if(gpSMCurrentMerc->ZipperFlag)
+							if(!ChangeZipperStatus(gpSMCurrentMerc, FALSE))
+								return;
+						// Do we still have a linked backpack?  If so, reset droppackflag
+						if(gpSMCurrentMerc->DropPackKey != ITEM_NOT_FOUND)
+						{
+							gpSMCurrentMerc->DropPackFlag = TRUE;
+							RenderBackpackButtons(0);	/* CHRISL: Needed for new inventory backpack buttons */
+						}
+					}
+					MoveItemToLBEItem( gpSMCurrentMerc, uiHandPos, gpItemPointer );
+				}
+			}
+			
 			// Turn off new item glow!
 			gpSMCurrentMerc->bNewItemCount[ uiHandPos ] = 0;
 
@@ -2713,6 +3147,34 @@
 					}
 					// else handle normally
 				}
+				/* CHRISL: For New Inventory system.  Are we swapping LBE Items?  We'll need to move any
+				items in the associated IC group pockets into a new LBENODE.  We'll have to check
+				whether we already have an LBENODE for this type of LBE item and, if so, remove
+				the items from it, place them in the LBE Items current sector, and delete the existing
+				LBENODE.  Then we need to know if the LBE Item in the cursor is an LBENODE
+				or just a normal OBJECTTYPE.  If it's an LBENODE, we need to move it's items into
+				the appropriate pockets for the soldier and then delete the LBENODE.*/
+				if(gGameOptions.ubInventorySystem)
+				{
+					if((uiHandPos == VESTPOCKPOS || uiHandPos == LTHIGHPOCKPOS || uiHandPos == RTHIGHPOCKPOS || uiHandPos == CPACKPOCKPOS || uiHandPos == BPACKPOCKPOS) && CanItemFitInPosition(gpSMCurrentMerc, gpItemPointer, uiHandPos, FALSE))
+					{
+						//If we put a new pack in the backpack pocket, turn off the droppack button
+						if(uiHandPos == BPACKPOCKPOS)
+						{
+							// First, deal with the zipper
+							if(gpSMCurrentMerc->ZipperFlag)
+								if(!ChangeZipperStatus(gpSMCurrentMerc, FALSE))
+									return;
+							if(gpSMCurrentMerc->DropPackFlag)
+								gpSMCurrentMerc->DropPackFlag = FALSE;
+							RenderBackpackButtons(0);	/* CHRISL: Needed for new inventory backpack buttons */
+						}
+						// Are we swaping LBE items?
+						if(gpSMCurrentMerc->inv[uiHandPos].usItem != NONE)	// Item already exists in this pocket
+							MoveItemToLBEItem( gpSMCurrentMerc, uiHandPos, gpItemPointer );
+						MoveItemFromLBEItem( gpSMCurrentMerc, uiHandPos, gpItemPointer );
+					}
+				}
 
 
 				// remember the item type currently in the item pointer
@@ -2825,14 +3287,17 @@
 
 		// Some global stuff here - for esc, etc
 		// Check for # of slots in item
-		if( ( gpSMCurrentMerc->inv[ uiHandPos ].ubNumberOfObjects > 1 && ItemSlotLimit( gpSMCurrentMerc->inv[ uiHandPos ].usItem, (UINT8)uiHandPos ) > 0 ) && ( guiCurrentScreen != MAP_SCREEN ) )
+		// CHRISL: Use new ItemSlotLimit function if we're using the new inventory system
+		UINT8 isLimit = (!gGameOptions.ubInventorySystem) ? ItemSlotLimit( gpSMCurrentMerc->inv[ uiHandPos ].usItem, (UINT16)uiHandPos ) : ItemSlotLimit( &gpSMCurrentMerc->inv[ uiHandPos ], (UINT16)uiHandPos, gpSMCurrentMerc );
+		if( ( gpSMCurrentMerc->inv[ uiHandPos ].ubNumberOfObjects > 1 && isLimit > 0 ) && ( guiCurrentScreen != MAP_SCREEN ) )
 		{
 			if ( !InItemStackPopup( )  )
 			{
+				// CHRISL:
+				InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, 261, SM_ITEMDESC_START_Y, (SCREEN_WIDTH - (214+261)), SM_ITEMDESC_HEIGHT );
+				//InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, (SCREEN_WIDTH - SM_ITEMDESC_WIDTH), (SCREEN_HEIGHT - SM_ITEMDESC_HEIGHT) );
+				//InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, 216, INV_INTERFACE_START_Y, 314, ( SCREEN_HEIGHT - INV_INTERFACE_START_Y ) );
 
-				//InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, SM_ITEMDESC_WIDTH, SM_ITEMDESC_HEIGHT );
-				InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, 216, INV_INTERFACE_START_Y, 314, ( SCREEN_HEIGHT - INV_INTERFACE_START_Y ) );
-
 			}
 		}
 		else
@@ -2851,6 +3316,145 @@
 
 }
 
+// CHRISL: Function to adjust zipper backpack button status
+BOOLEAN  ChangeZipperStatus(SOLDIERTYPE *pSoldier, BOOLEAN newStatus)
+{
+	INT16	sAPCost;
+	INT32	iBPCost = 0;
+	INT8	bNewStance;
+
+	//Set AP cost based on what we're doing
+	sAPCost = (newStatus) ? 7 : 6;
+	//Are we currently in combat?
+	if(gTacticalStatus.uiFlags & INCOMBAT)
+	{
+		// If we have fewer base points then the default cost to unzip a pack, use all remaining points instead
+		if(pSoldier->bInitialActionPoints < sAPCost)
+			sAPCost = pSoldier->bInitialActionPoints;
+		if(EnoughPoints(pSoldier, sAPCost, iBPCost, TRUE))
+			DeductPoints(pSoldier, sAPCost, iBPCost);
+		else
+			return FALSE;
+	}
+
+	//Opening a pack?
+	if(newStatus)
+	{
+		// Are we standing?
+		bNewStance = gAnimControl[ pSoldier->usAnimState ].ubEndHeight;
+		if(bNewStance == ANIM_STAND)
+		{
+			bNewStance = ANIM_CROUCH;
+			UIHandleSoldierStanceChange( pSoldier->ubID, bNewStance );
+		}
+		pSoldier->ZipperFlag = newStatus;
+		gfUIStanceDifferent = TRUE;
+	}
+	// Closing a pack?
+	else
+	{
+		pSoldier->ZipperFlag = newStatus;
+		gfUIStanceDifferent = TRUE;
+	}
+
+	return TRUE;
+}
+
+// CHRISL: Function to adjust droppack packpack button status
+BOOLEAN ChangeDropPackStatus(SOLDIERTYPE *pSoldier, BOOLEAN newStatus)
+{
+	INT16	sAPCost = 3;
+	INT32	iBPCost = 0;
+	INT32	worldKey=1;
+
+	// Are we dropping a pack that has the zipper open?
+	if(newStatus && pSoldier->ZipperFlag)
+	{
+		sAPCost = 0;
+		if(!ChangeZipperStatus(pSoldier, FALSE))
+			return FALSE;
+	}
+	
+	// Are we currently in combat?
+	if(gTacticalStatus.uiFlags & INCOMBAT)
+	{
+		// If we're standing over the backpack that we're trying to pick up, reset the ap cost to 0
+		if(!newStatus)
+			if(gWorldItems[pSoldier->DropPackKey].o.ItemData.Trigger.bDetonatorType == -1)
+				if(LBEptr[gWorldItems[pSoldier->DropPackKey].o.ItemData.Trigger.usBombItem].lbeIndex != NONE)
+					if(gWorldItems[pSoldier->DropPackKey].sGridNo == pSoldier->sGridNo)
+					{
+						sAPCost = 0;
+					}
+					// If not, we can't pick up the item
+					else
+					{
+						CHAR16 dropMSG[] = L"Cannot pickup backpack at this time";
+						ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, dropMSG );
+						return FALSE;
+					}
+		// Do we have enough APs to complete this action?
+		if(EnoughPoints(pSoldier, sAPCost, iBPCost, TRUE))
+			DeductPoints(pSoldier, sAPCost, iBPCost);
+		else
+			return FALSE;
+	}
+
+	// Dropping a pack?
+	if(newStatus)
+	{
+		if(!MoveItemToLBEItem( pSoldier, BPACKPOCKPOS, NULL ))
+			newStatus = FALSE;
+		InternalAddItemToPool(&pSoldier->sGridNo, &pSoldier->inv[BPACKPOCKPOS], 1, pSoldier->bExpLevel, 0 , -1, &worldKey );
+		// Item successfully added to world
+		if(worldKey != ITEM_NOT_FOUND)
+		{
+			gpSMCurrentMerc->DropPackKey = worldKey;
+			NotifySoldiersToLookforItems( );
+			RemoveObjectFromSlot( pSoldier, BPACKPOCKPOS, &(pSoldier->inv[BPACKPOCKPOS]) );
+			gpSMCurrentMerc->DropPackFlag = newStatus;
+			gfUIStanceDifferent = TRUE;
+		}
+	}
+	// Picking up a pack?
+	else
+	{
+		// Is the item we dropped in this sector and does it have an active LBENODE flag?
+		if(gWorldItems[pSoldier->DropPackKey].o.ItemData.Trigger.bDetonatorType == -1)
+		{
+			// Is the LBENODE we're trying to pick up actually in use?
+			if(LBEptr[gWorldItems[pSoldier->DropPackKey].o.ItemData.Trigger.usBombItem].lbeIndex != NONE)
+			{
+				// Try to pickup the LBENODE
+				if(AutoPlaceObject(pSoldier, &(gWorldItems[ pSoldier->DropPackKey ].o ), TRUE ))
+				{
+					RemoveItemFromPool(gWorldItems[pSoldier->DropPackKey].sGridNo, pSoldier->DropPackKey, gWorldItems[pSoldier->DropPackKey].ubLevel);
+					gpSMCurrentMerc->DropPackKey = -1;
+					gpSMCurrentMerc->DropPackFlag = newStatus;
+					gfUIStanceDifferent = TRUE;
+				}
+				else
+				{
+					CHAR16 dropMSG[] = L"No place to put backpack";
+					ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, dropMSG );
+				}
+			}
+			else
+			{
+				CHAR16 dropMSG[] = L"Backpack not found";
+				ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, dropMSG );
+			}
+		}
+		else
+		{
+			CHAR16 dropMSG[] = L"Backpack not found";
+			ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, dropMSG );
+		}
+	}
+
+	return TRUE;
+}
+
 void MergeMessageBoxCallBack( UINT8 ubExitValue )
 {
 	if ( ubExitValue == MSG_BOX_RETURN_YES )
@@ -3083,7 +3687,106 @@
 	
 }
 
+// CHRISL: Callback functions for backpack buttons
+void BtnDropPackCallback(GUI_BUTTON *btn,INT32 reason)
+{
+	if (!(btn->uiFlags & BUTTON_ENABLED))
+		return;
 
+	if(reason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
+	{
+		btn->uiFlags |= BUTTON_CLICKED_ON;
+	}
+	else if(reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
+	{
+		btn->uiFlags &= (~BUTTON_CLICKED_ON );
+		/* Is DropPackFlag currently false and is there something in the backpack pocket?  If so, we haven't
+		dropped a pack yet and apparently want to*/
+		if(gpSMCurrentMerc->inv[BPACKPOCKPOS].usItem != NONE && !gpSMCurrentMerc->DropPackFlag)
+		{
+			ChangeDropPackStatus(gpSMCurrentMerc, TRUE);
+		}
+		/* Is DropPackFlag currently true, is nothing in the backpack pocket and have we dropped a pack?  If so, we
+		must want to retreive a backpack we previously dropped.*/
+		else if(gpSMCurrentMerc->inv[BPACKPOCKPOS].usItem == NONE && gpSMCurrentMerc->DropPackFlag && gpSMCurrentMerc->DropPackKey != ITEM_NOT_FOUND)
+		{
+			ChangeDropPackStatus(gpSMCurrentMerc, FALSE);
+		}
+	}
+	else if(reason & MSYS_CALLBACK_REASON_LOST_MOUSE )
+	{
+		btn->uiFlags &= (~BUTTON_CLICKED_ON );
+	}
+}
+
+void BtnZipperCallback(GUI_BUTTON *btn,INT32 reason)
+{
+	if (!(btn->uiFlags & BUTTON_ENABLED))
+		return;
+
+	if(reason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
+	{
+		btn->uiFlags |= BUTTON_CLICKED_ON;
+	}
+	else if(reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
+	{
+		btn->uiFlags &= (~BUTTON_CLICKED_ON );
+		//Are we in combat, do we have a backpack on and is the pack closed? Open it
+		if((gTacticalStatus.uiFlags & INCOMBAT) && gpSMCurrentMerc->inv[BPACKPOCKPOS].usItem != NONE && !gpSMCurrentMerc->ZipperFlag)
+		{
+			ChangeZipperStatus(gpSMCurrentMerc, TRUE);
+		}
+		//Is the pack open?
+		else if(gpSMCurrentMerc->ZipperFlag)
+		{
+			ChangeZipperStatus(gpSMCurrentMerc, FALSE);
+		}
+		//Are we not in combat?
+		else if(!(gTacticalStatus.uiFlags & INCOMBAT))
+		{
+			CHAR16 zipperMSG[] = L"Zipper only works in combat";
+			ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, zipperMSG );
+		}
+	}
+	else if(reason & MSYS_CALLBACK_REASON_LOST_MOUSE )
+	{
+		btn->uiFlags &= (~BUTTON_CLICKED_ON );
+	}
+}
+
+//CHRISL: Drop Backpack mouse callback function
+void BtnMapDropPackCallback( GUI_BUTTON *btn, INT32 reason )
+{
+	if (!(btn->uiFlags & BUTTON_ENABLED))
+		return;
+
+	if(reason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
+	{
+		btn->uiFlags |= BUTTON_CLICKED_ON;
+	}
+	else if(reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
+	{
+		btn->uiFlags &= (~BUTTON_CLICKED_ON );
+		/* Is DropPackFlag currently false and is there something in the backpack pocket?  If so, we haven't
+		dropped a pack yet and apparently want to*/
+		if(gpSMCurrentMerc->inv[BPACKPOCKPOS].usItem != NONE && !gpSMCurrentMerc->DropPackFlag)
+		{
+			// Drop the pack into sector inventory
+		}
+		/* Is DropPackFlag currently true, is nothing in the backpack pocket and have we dropped a pack?  If so, we
+		must want to retreive a backpack we previously dropped.*/
+		else if(gpSMCurrentMerc->inv[BPACKPOCKPOS].usItem == NONE && gpSMCurrentMerc->DropPackFlag && gpSMCurrentMerc->DropPackKey != ITEM_NOT_FOUND)
+		{
+			// Pickup pack from sector inventory
+		}
+	}
+	else if(reason & MSYS_CALLBACK_REASON_LOST_MOUSE )
+	{
+		btn->uiFlags &= (~BUTTON_CLICKED_ON );
+	}
+}
+
+
 void BtnUpdownCallback(GUI_BUTTON *btn,INT32 reason)
 {
 	if (!(btn->uiFlags & BUTTON_ENABLED))
@@ -3600,6 +4303,12 @@
 	sTEAMHandInvXY[10] = ( TM_INV_HAND1STARTX + ( 5 * TM_INV_HAND_SEP ));	sTEAMHandInvXY[11] = TM_INV_HAND1STARTY;
 	// ufff to much copy&paste :D
 
+	// CHRISL: New definitions for the team panel clock and location coordinates
+	INTERFACE_CLOCK_TM_X	= ( SCREEN_WIDTH - 86 );
+	INTERFACE_CLOCK_TM_Y	= ( 98	+ INTERFACE_START_Y );
+	LOCATION_NAME_TM_X		= ( SCREEN_WIDTH - 92 );
+	LOCATION_NAME_TM_Y		= ( 65	+ INTERFACE_START_Y	);
+
 	return ( TRUE );
 }
 // TEAM PANEL!!!!!!!!!!!!!!
@@ -3610,6 +4319,8 @@
 	UINT32					cnt, posIndex;
 	static BOOLEAN	fFirstTime = TRUE;
 
+	/* CHRISL: Add something here to reset the cursor to a pointer so we don't inadvertantly activate
+	context sensitive cursor when closing the inventory panel*/
 	fDisplayOverheadMap = TRUE;
 
 /*  OK i need to initialize coords here
@@ -4050,9 +4761,10 @@
 	if( fRenderRadarScreen == TRUE )
 	{
 		// Render clock
-		RenderClock( INTERFACE_CLOCK_X, INTERFACE_CLOCK_Y );
-		CreateMouseRegionForPauseOfClock( INTERFACE_CLOCK_X, INTERFACE_CLOCK_Y );
-		RenderTownIDString( );
+		// CHRISL: Change coords to base off of right side of screen and use new paramters in RenderTownIDString
+		RenderClock( INTERFACE_CLOCK_TM_X, INTERFACE_CLOCK_TM_Y );
+		CreateMouseRegionForPauseOfClock( INTERFACE_CLOCK_TM_Y, INTERFACE_CLOCK_TM_Y );
+		RenderTownIDString( LOCATION_NAME_TM_X, LOCATION_NAME_TM_Y);
 	}
 	else
 	{
@@ -5214,7 +5926,9 @@
 }
 
 
-void RenderTownIDString( )
+/* CHRISL: Adjust function to allow X,Y coordinates to be passed so that we can render the TownID string
+seperately between the team and inventory windows. */
+void RenderTownIDString( INT16 sX, INT16 sY )
 {
 	CHAR16	zTownIDString[80];
 	INT16 sFontX, sFontY;
@@ -5226,7 +5940,7 @@
 
 	GetSectorIDString( gWorldSectorX, gWorldSectorY, gbWorldSectorZ, zTownIDString, TRUE );
 	ReduceStringLength( zTownIDString, 80, COMPFONT );
-	VarFindFontCenterCoordinates( LOCATION_NAME_X , LOCATION_NAME_Y, 80, 16, COMPFONT, &sFontX, &sFontY, zTownIDString );
+	VarFindFontCenterCoordinates( sX , sY, 80, 16, COMPFONT, &sFontX, &sFontY, zTownIDString );
 	mprintf( sFontX, sFontY, L"%s", zTownIDString );
 }
 
@@ -5797,6 +6511,7 @@
 	DisableButton( iSMPanelButtons[ MUTE_BUTTON ] );
 
 	DisableButton( giSMStealthButton );
+	RenderBackpackButtons(3);	/* CHRISL: Needed for new inventory backpack buttons */
 
 
 
@@ -5817,6 +6532,12 @@
 		ButtonList[ iSMPanelButtons[ MUTE_BUTTON ] ]->uiFlags &= ~BUTTON_DIRTY;
 
 		ButtonList[ giSMStealthButton ]->uiFlags &= ~BUTTON_DIRTY;
+		// CHRISL: Backpack buttons for new inventory system
+		if(gGameOptions.ubInventorySystem)
+		{
+			ButtonList[ giSMZipperButton ]->uiFlags &= ~BUTTON_DIRTY;
+			ButtonList[ giSMDropPackButton ]->uiFlags &= ~BUTTON_DIRTY;
+		}
 
 		//Make sure the options button is disabled
 		ButtonList[ iSMPanelButtons[ OPTIONS_BUTTON ] ]->uiFlags &= ~BUTTON_ENABLED;
@@ -5835,6 +6556,12 @@
 		ButtonList[ iSMPanelButtons[ MUTE_BUTTON ] ]->uiFlags |= BUTTON_FORCE_UNDIRTY;
 
 		ButtonList[ giSMStealthButton ]->uiFlags |= BUTTON_FORCE_UNDIRTY;
+		// CHRISL: Backpack buttons for new inventory system
+		if(gGameOptions.ubInventorySystem)
+		{
+			ButtonList[ giSMZipperButton ]->uiFlags |= BUTTON_FORCE_UNDIRTY;
+			ButtonList[ giSMDropPackButton ]->uiFlags |= BUTTON_FORCE_UNDIRTY;
+		}
 	}
 }
 
@@ -6058,3 +6785,324 @@
 		}
 	}
 }
+
+// CHRISL: New function to move items from default pockets to usable pockets
+BOOLEAN MoveItemsToActivePockets( SOLDIERTYPE *pSoldier, INT8 LBESlots[], UINT32 uiHandPos, OBJECTTYPE *pObj )
+{
+	INT16	lbeIndex=ITEM_NOT_FOUND;
+	UINT16	dSize;
+	BOOLEAN	flag=FALSE;
+
+	if(pObj->ItemData.Trigger.bDetonatorType == ITEM_NOT_FOUND)
+		lbeIndex = pObj->ItemData.Trigger.usBombItem;
+	else
+		lbeIndex = GetFreeLBEPackIndex();
+
+	for(int i=0; i<12; i++)	// Go through default pockets one by one
+	{
+		if(LBESlots[i] == ITEM_NOT_FOUND)	// Pocket not valid for this class of LBE
+			continue;
+		if(pSoldier->inv[LBESlots[i]].usItem == NOTHING)	// No item in this pocket
+			continue;
+		// Found an item in a default pocket so get it's ItemSize
+		//dSize=Item[pSoldier->inv[LBESlots[i]].usItem].ItemSize;
+		dSize = CalculateItemSize(&pSoldier->inv[LBESlots[i]]);
+		for(int j=0; j<12; j++)	// Search through LBE and see if item fits anywhere
+		{
+			if(LBEptr[lbeIndex].inv[j].usItem != NOTHING)	// Item already stored in LBENODE pocket
+				continue;
+			// No item in this LBENODE pocket, is pocket active?
+			if(LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbePocketIndex[j] == NONE)	// Pocket is inactive
+				continue;
+			// Pocket is active, can default item fit in this pocket?
+			if(LBEPocketType[LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbePocketIndex[j]].ItemCapacityPerSize[dSize] == NONE)	// Pocket can't hold this item size
+				continue;
+			// Default item will fit in this pocket.  Setup the LBENODE if necessary
+			if(LBEptr[lbeIndex].ubID != pSoldier->ubID)
+				LBEptr[lbeIndex].ubID = pSoldier->ubID;
+			if(LBEptr[lbeIndex].lbeIndex != Item[pObj->usItem].ubClassIndex)
+				LBEptr[lbeIndex].lbeIndex = Item[pObj->usItem].ubClassIndex;
+			if(LBEptr[lbeIndex].lbeClass != LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass)
+				LBEptr[lbeIndex].lbeClass = LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass;
+			LBEptr[lbeIndex].inv[j] = pSoldier->inv[LBESlots[i]];
+			RemoveObjectFromSlot( pSoldier, LBESlots[i], &(pSoldier->inv[LBESlots[i]]) );
+			pObj->ItemData.Trigger.bDetonatorType = -1;
+			pObj->ItemData.Trigger.usBombItem = lbeIndex;
+			break;
+		}
+	}
+	// We've put everything into the LBENODE that we could, now search other pockets for openings
+	for(int x=0; x<12; x++)
+	{
+		if(LBESlots[x] == ITEM_NOT_FOUND)
+			continue;
+		if(pSoldier->inv[LBESlots[x]].usItem == NOTHING)
+			continue;
+		for(int i=BODYPOSFINAL; i<NUM_INV_SLOTS; i++)
+		{
+			if(pSoldier->inv[i].usItem != NOTHING)	// Item already in that location
+				continue;
+			for(int j=0; j<12; j++)
+			{
+				flag = FALSE;
+				if(i==LBESlots[j])
+				{
+					flag=true;
+					break;
+				}
+			}
+			if(flag)
+				continue;
+			if(CanItemFitInPosition(pSoldier, &(pSoldier->inv[LBESlots[x]]), i, FALSE))
+			{
+				pSoldier->inv[i]=pSoldier->inv[LBESlots[x]];
+				RemoveObjectFromSlot( pSoldier, LBESlots[x], &(pSoldier->inv[LBESlots[x]]) );
+				break;
+			}
+		}
+	}
+	// now drop everything that wouldn't fit anywhere else
+	for(int i=0; i<12 ;i++)
+	{
+		if(LBESlots[i] == ITEM_NOT_FOUND)	// Pocket not valid for this class of LBE
+			continue;
+		if(pSoldier->inv[LBESlots[i]].usItem == NOTHING)	// No item in pocket
+			continue;
+		//AddItemToWorld(pSoldier->sGridNo,&pSoldier->inv[LBESlots[i]],pSoldier->bExpLevel,0,0,TRUE);
+		//RemoveObjectFromSlot( pSoldier, LBESlots[i], &(pSoldier->inv[LBESlots[i]]) );
+
+		AddItemToPool( pSoldier->sGridNo, &pSoldier->inv[LBESlots[i]], 1, pSoldier->bExpLevel, 0 , -1 );
+		NotifySoldiersToLookforItems( );
+
+		//MemFree( &pSoldier->inv[LBESlots[i]] );
+		//pSoldier->inv[LBESlots[i]] = NULL;
+		RemoveObjectFromSlot( pSoldier, LBESlots[i], &(pSoldier->inv[LBESlots[i]]) );
+	}
+
+	return(TRUE);
+}
+
+// CHRISL: New function to handle moving soldier items to lbe items
+BOOLEAN MoveItemToLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj )
+{
+	BOOLEAN newLBEitem = FALSE;
+	INT8	LBESlots[12]={-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
+	INT16	lbeIndex=ITEM_NOT_FOUND;
+
+	// Determine which LBE item we're removing so we can associate the correct pockets with it.
+	switch (uiHandPos)
+	{
+		case VESTPOCKPOS:
+			LBESlots[0]=SMALLPOCK1POS;
+			LBESlots[1]=SMALLPOCK2POS;
+			LBESlots[2]=SMALLPOCK3POS;
+			LBESlots[3]=SMALLPOCK4POS;
+			LBESlots[4]=SMALLPOCK5POS;
+			LBESlots[5]=SMALLPOCK6POS;
+			LBESlots[6]=SMALLPOCK7POS;
+			LBESlots[7]=SMALLPOCK8POS;
+			LBESlots[8]=SMALLPOCK9POS;
+			LBESlots[9]=SMALLPOCK10POS;
+			LBESlots[10]=MEDPOCK1POS;
+			LBESlots[11]=MEDPOCK2POS;
+			break;
+		case LTHIGHPOCKPOS:
+			LBESlots[0]=SMALLPOCK11POS;
+			LBESlots[1]=SMALLPOCK12POS;
+			LBESlots[2]=SMALLPOCK13POS;
+			LBESlots[3]=SMALLPOCK14POS;
+			LBESlots[4]=MEDPOCK3POS;
+			break;
+		case RTHIGHPOCKPOS:
+			LBESlots[0]=SMALLPOCK15POS;
+			LBESlots[1]=SMALLPOCK16POS;
+			LBESlots[2]=SMALLPOCK17POS;
+			LBESlots[3]=SMALLPOCK18POS;
+			LBESlots[4]=MEDPOCK4POS;
+			break;
+		case CPACKPOCKPOS:
+			LBESlots[0]=SMALLPOCK19POS;
+			LBESlots[1]=SMALLPOCK20POS;
+			LBESlots[2]=SMALLPOCK21POS;
+			LBESlots[3]=SMALLPOCK22POS;
+			LBESlots[4]=BIGPOCK1POS;
+			LBESlots[5]=BIGPOCK2POS;
+			LBESlots[6]=BIGPOCK3POS;
+			break;
+		case BPACKPOCKPOS:
+			LBESlots[0]=SMALLPOCK23POS;
+			LBESlots[1]=SMALLPOCK24POS;
+			LBESlots[2]=SMALLPOCK25POS;
+			LBESlots[3]=SMALLPOCK26POS;
+			LBESlots[4]=SMALLPOCK27POS;
+			LBESlots[5]=SMALLPOCK28POS;
+			LBESlots[6]=SMALLPOCK29POS;
+			LBESlots[7]=SMALLPOCK30POS;
+			LBESlots[8]=BIGPOCK4POS;
+			LBESlots[9]=BIGPOCK5POS;
+			LBESlots[10]=BIGPOCK6POS;
+			LBESlots[11]=BIGPOCK7POS;
+			break;
+		default:
+			return(FALSE);
+	}
+
+	lbeIndex = GetFreeLBEPackIndex();
+	for(int i=0; i<12; i++)
+	{
+		// If we hit a -1, we're done
+		if(LBESlots[i] == ITEM_NOT_FOUND)
+			break;
+		// Is there an item in this pocket?
+		LBEptr[lbeIndex].inv[i] = pSoldier->inv[LBESlots[i]];
+		if(pSoldier->inv[LBESlots[i]].usItem != NOTHING)
+		{
+			RemoveObjectFromSlot( pSoldier, LBESlots[i], &(pSoldier->inv[LBESlots[i]]) );
+			newLBEitem = TRUE;
+		}
+	}
+
+	if(newLBEitem)
+	{
+		LBEptr[lbeIndex].ubID = pSoldier->ubID;
+		LBEptr[lbeIndex].lbeIndex = Item[pSoldier->inv[uiHandPos].usItem].ubClassIndex;
+		LBEptr[lbeIndex].lbeClass = LoadBearingEquipment[Item[pSoldier->inv[uiHandPos].usItem].ubClassIndex].lbeClass;
+		LBEptr[lbeIndex].ZipperFlag = FALSE;
+		// usBombItem can be used to track the index for LBE Items if we don't want to alter the OBJECTTYPE structure
+		pSoldier->inv[uiHandPos].ItemData.Trigger.usBombItem = lbeIndex;
+		pSoldier->inv[uiHandPos].ItemData.Trigger.bDetonatorType = -1;
+	}
+	else
+	{
+		pSoldier->inv[uiHandPos].ItemData.Trigger.usBombItem = 0;
+		pSoldier->inv[uiHandPos].ItemData.Trigger.bDetonatorType = 0;
+		return(FALSE);
+	}
+
+	return (TRUE);
+}
+
+// CHRISL: New function to handle moving lbe items to soldier items
+BOOLEAN MoveItemFromLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj )
+{
+	BOOLEAN newLBEitem = FALSE;
+	INT8	LBESlots[12]={-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
+	INT16	lbeIndex=ITEM_NOT_FOUND;
+
+	// Determine which LBE item we're adding so we can associate the correct pockets with it.
+	switch (uiHandPos)
+	{
+		case VESTPOCKPOS:
+			LBESlots[0]=SMALLPOCK1POS;
+			LBESlots[1]=SMALLPOCK2POS;
+			LBESlots[2]=SMALLPOCK3POS;
+			LBESlots[3]=SMALLPOCK4POS;
+			LBESlots[4]=SMALLPOCK5POS;
+			LBESlots[5]=SMALLPOCK6POS;
+			LBESlots[6]=SMALLPOCK7POS;
+			LBESlots[7]=SMALLPOCK8POS;
+			LBESlots[8]=SMALLPOCK9POS;
+			LBESlots[9]=SMALLPOCK10POS;
+			LBESlots[10]=MEDPOCK1POS;
+			LBESlots[11]=MEDPOCK2POS;
+			break;
+		case LTHIGHPOCKPOS:
+			LBESlots[0]=SMALLPOCK11POS;
+			LBESlots[1]=SMALLPOCK12POS;
+			LBESlots[2]=SMALLPOCK13POS;
+			LBESlots[3]=SMALLPOCK14POS;
+			LBESlots[4]=MEDPOCK3POS;
+			break;
+		case RTHIGHPOCKPOS:
+			LBESlots[0]=SMALLPOCK15POS;
+			LBESlots[1]=SMALLPOCK16POS;
+			LBESlots[2]=SMALLPOCK17POS;
+			LBESlots[3]=SMALLPOCK18POS;
+			LBESlots[4]=MEDPOCK4POS;
+			break;
+		case CPACKPOCKPOS:
+			LBESlots[0]=SMALLPOCK19POS;
+			LBESlots[1]=SMALLPOCK20POS;
+			LBESlots[2]=SMALLPOCK21POS;
+			LBESlots[3]=SMALLPOCK22POS;
+			LBESlots[4]=BIGPOCK1POS;
+			LBESlots[5]=BIGPOCK2POS;
+			LBESlots[6]=BIGPOCK3POS;
+			break;
+		case BPACKPOCKPOS:
+			LBESlots[0]=SMALLPOCK23POS;
+			LBESlots[1]=SMALLPOCK24POS;
+			LBESlots[2]=SMALLPOCK25POS;
+			LBESlots[3]=SMALLPOCK26POS;
+			LBESlots[4]=SMALLPOCK27POS;
+			LBESlots[5]=SMALLPOCK28POS;
+			LBESlots[6]=SMALLPOCK29POS;
+			LBESlots[7]=SMALLPOCK30POS;
+			LBESlots[8]=BIGPOCK4POS;
+			LBESlots[9]=BIGPOCK5POS;
+			LBESlots[10]=BIGPOCK6POS;
+			LBESlots[11]=BIGPOCK7POS;
+			break;
+		default:
+			return(FALSE);
+	}
+
+	if(pSoldier->inv[uiHandPos].usItem == NOTHING)
+		MoveItemsToActivePockets(pSoldier, LBESlots, uiHandPos, pObj);
+	if(pObj->ItemData.Trigger.bDetonatorType == -1)
+		lbeIndex = pObj->ItemData.Trigger.usBombItem;
+	if(lbeIndex == ITEM_NOT_FOUND)
+		return (FALSE);
+
+	for(int i=0; i<12; i++)
+	{
+		// If we hit a -1, we're done
+		if(LBESlots[i] == ITEM_NOT_FOUND)
+			break;
+		// Is there an item in this LBE pocket?
+		if(LBEptr[lbeIndex].inv[i].usItem != NOTHING)
+		{
+			pSoldier->inv[LBESlots[i]] = LBEptr[lbeIndex].inv[i];
+			newLBEitem = TRUE;
+		}
+	}
+	if(newLBEitem)
+	{
+		LBEptr[lbeIndex].ubID = 0;
+		LBEptr[lbeIndex].lbeIndex = 0;
+		LBEptr[lbeIndex].lbeClass = 0;
+		LBEptr[lbeIndex].ZipperFlag = FALSE;
+		for (int idx=0; idx < 12; ++idx) {
+			memset(&(LBEptr[lbeIndex].inv[idx]), 0, sizeof(OBJECTTYPE));
+		}
+		pObj->ItemData.Trigger.usBombItem = 0;
+		pObj->ItemData.Trigger.bDetonatorType = 0;
+	}
+
+	return (TRUE);
+}
+
+// CHRISL: Find an unused LBE Pack index
+INT16 GetFreeLBEPackIndex( void )
+{
+	UINT16 uiCount;
+//	LBENODE *newLBEptr;
+	UINT16	uiOldLBEptrNum;
+
+	for(uiCount=0; uiCount < LBEptrNum; uiCount++)
+	{
+		if ( LBEptr[ uiCount ].lbeIndex == 0)
+			return( (INT16)uiCount );
+	}
+
+	uiOldLBEptrNum = LBEptrNum;
+	LBEptrNum ++;
+	LBENODE *filler = new LBENODE;
+	LBEptr.push_back(*filler);
+	LBEptr[uiCount].ubID = 0;
+	LBEptr[uiCount].lbeClass = 0;
+	LBEptr[uiCount].lbeIndex = 0;
+	for(int i=0; i<12; i++)
+		LBEptr[uiCount].inv[i].usItem = 0;
+	return(uiCount);
+}
Index: Tactical/Interface Panels.h
===================================================================
--- Tactical/Interface Panels.h	(revision 1299)
+++ Tactical/Interface Panels.h	(working copy)
@@ -18,6 +18,8 @@
 	MUTE_BUTTON,
 	SM_DONE_BUTTON,
 	SM_MAP_SCREEN_BUTTON,
+	BACKPACK_BUTTON,
+	ZIPPER_BUTTON,
 	NUM_SM_BUTTONS
 };
 
@@ -56,7 +58,8 @@
  * and when we will read all values we return TRUE if not we will retunf FALSE
  * any questions? joker
  */
-BOOLEAN InitializeSMPanelCoords( ); 
+BOOLEAN InitializeSMPanelCoordsNew();
+BOOLEAN InitializeSMPanelCoordsOld(); 
 
 BOOLEAN CreateTEAMPanelButtons( );
 void    RemoveTEAMPanelButtons( );
@@ -85,8 +88,12 @@
 void CheckForAndAddMercToTeamPanel( SOLDIERTYPE *pSoldier );
 
 void DisableTacticalTeamPanelButtons( BOOLEAN fDisable );
-void RenderTownIDString( );
+// CHRISL: Add X,Y coords as parameters so we can control the placement of TownID string on the team and inventory panels seperately
+void RenderTownIDString( INT16 sX, INT16 sY );
 void KeyRingSlotInvClickCallback( MOUSE_REGION * pRegion, INT32 iReason );
+// CHRISL: New functions to handle initialization of inventory systems
+void InitNewInventorySystem( );
+void InitOldInventorySystem( );
 
 
 // ATE TO BE MOVED TO INTERFACE_ITEMS.C
@@ -124,6 +131,8 @@
 
 void CheckForDisabledForGiveItem( );
 void ReevaluateItemHatches( SOLDIERTYPE *pSoldier, BOOLEAN fEnable );
+//CHRISL: New function to deal with rendering backpack buttons
+void RenderBackpackButtons(int bpAction);
 
 void HandlePanelFaceAnimations( SOLDIERTYPE *pSoldier );
 
@@ -135,4 +144,4 @@
 
 UINT8 FindNextMercInTeamPanel( SOLDIERTYPE *pSoldier, BOOLEAN fGoodForLessOKLife, BOOLEAN fOnlyRegularMercs );
 
-#endif
\ No newline at end of file
+#endif
Index: Tactical/Interface.cpp
===================================================================
--- Tactical/Interface.cpp	(revision 1299)
+++ Tactical/Interface.cpp	(working copy)
@@ -224,6 +224,7 @@
 UINT32					guiP1ITEMS;
 UINT32					guiP2ITEMS;
 UINT32					guiP3ITEMS;
+UINT32					guiSILHOUETTE;
 UINT32					guiBUTTONBORDER;
 UINT32					guiRADIO;
 UINT32					guiRADIO2;
@@ -276,20 +277,17 @@
 	VSURFACE_DESC		vs_desc;
 	VOBJECT_DESC    VObjectDesc;
 
-	INTERFACE_WIDTH			= 640;
-	INTERFACE_HEIGHT		= 120;
-	INV_INTERFACE_HEIGHT	= 140;
-
-	// centering panel disabled becouse keyring squad change and radar 
-	// are not finished (no time) sorry 
-	/* 
-	if ( SCREEN_WIDTH > INTERFACE_WIDTH)
-		INTERFACE_START_X		= (SCREEN_WIDTH - INTERFACE_WIDTH) / 2;
+	// CHRISL: Setup default interface coords based on inventory system in use
+	if(gGameOptions.ubInventorySystem)
+	{
+		InitNewInventorySystem();
+		InitializeSMPanelCoordsNew();
+	}
 	else
-	*/
-		INTERFACE_START_X		= 0;
-	INTERFACE_START_Y		= ( SCREEN_HEIGHT - INTERFACE_HEIGHT );
-	INV_INTERFACE_START_Y	= ( SCREEN_HEIGHT - INV_INTERFACE_HEIGHT );
+	{
+		InitOldInventorySystem();
+		InitializeSMPanelCoordsOld();
+	}
 
 /*  OK i need to initialize coords here
  *  Isnt it cool
@@ -297,7 +295,6 @@
  */
 	InitializeViewPort( );
 	InitializeTEAMPanelCoords( );
-	InitializeSMPanelCoords( );
 	
 	// Load button Interfaces
 	iIconImages[ WALK_IMAGES  ]			= LoadButtonImage("INTERFACE\\newicons3.sti", -1,3,4,5,-1 );
@@ -387,6 +384,13 @@
 	if( !AddVideoObject( &VObjectDesc, &guiP3ITEMS ) )
 		AssertMsg(0, "Missing INTERFACE\\mdp3items.sti" );
 
+	// CHRISL:
+	// LOAD INTERFACE POCKET SILHOUETTES
+	VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
+	FilenameForBPP("INTERFACE\\Silhouettes.sti", VObjectDesc.ImageFile);
+	if( !AddVideoObject( &VObjectDesc, &guiSILHOUETTE ) )
+		AssertMsg(0, "Missing INTERFACE\\Silhouettes.sti" );
+
 	// LOAD INTERFACE BUTTON BORDER
 	VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
 	FilenameForBPP("INTERFACE\\button_frame.sti", VObjectDesc.ImageFile);
Index: Tactical/Interface.h
===================================================================
--- Tactical/Interface.h	(revision 1299)
+++ Tactical/Interface.h	(working copy)
@@ -84,6 +84,7 @@
 extern UINT32		guiP1ITEMS;
 extern UINT32		guiP2ITEMS;
 extern UINT32		guiP3ITEMS;
+extern UINT32		guiSILHOUETTE;
 extern UINT32		guiCOMPANEL;
 extern UINT32		guiCOMPANELB;
 extern UINT32		guiRADIO;
@@ -243,4 +244,4 @@
 
 
 
-#endif
\ No newline at end of file
+#endif
Index: Tactical/Inventory Choosing.cpp
===================================================================
--- Tactical/Inventory Choosing.cpp	(revision 1299)
+++ Tactical/Inventory Choosing.cpp	(working copy)
@@ -88,6 +88,8 @@
 void ChooseKitsForSoldierCreateStruct( SOLDIERCREATE_STRUCT *pp, INT8 bKitClass );
 void ChooseMiscGearForSoldierCreateStruct( SOLDIERCREATE_STRUCT *pp, INT8 bMiscClass );
 void ChooseBombsForSoldierCreateStruct( SOLDIERCREATE_STRUCT *pp, INT8 bBombClass );
+// Headrock: Added function definition for LBE chooser
+void ChooseLBEsForSoldierCreateStruct( SOLDIERCREATE_STRUCT *pp, INT8 bLBEClass );
 UINT16 PickARandomItem(UINT8 typeIndex);
 UINT16 PickARandomItem(UINT8 typeIndex, UINT8 maxCoolness);
 UINT16 PickARandomItem(UINT8 typeIndex, UINT8 maxCoolness, BOOLEAN getMatchingCoolness);
@@ -222,6 +224,8 @@
 	INT8 bKitClass = 0;
 	INT8 bMiscClass = 0;
 	INT8 bBombClass = 0;
+	// Headrock: Added Zeroed LBE integer
+	INT8 bLBEClass = 0;
 	//special weapons
 	BOOLEAN fMortar = FALSE;
 	BOOLEAN fGrenadeLauncher = FALSE;
@@ -289,6 +293,8 @@
 			bRating = (INT8)max( MIN_EQUIPMENT_CLASS, min( MAX_EQUIPMENT_CLASS, bRating ) );
 
 			bWeaponClass = bRating;
+			//Headrocktest, remove for release
+			bLBEClass = bRating;
 
 			//Note:  in some cases the class of armour and/or helmet won't be high enough to make 
 			//			 the lowest level.
@@ -307,6 +313,8 @@
 
 				bKitClass = bRating;
 				bMiscClass = bRating;
+				// Headrock: Low Level LBEs possible on Administrators:
+				bLBEClass = bRating;
 			}
 
 			if( bRating >= GREAT_ADMINISTRATOR_EQUIPMENT_RATING )
@@ -337,6 +345,8 @@
 			bVestClass = bRating;
 			bHelmetClass = bRating;
 			bGrenadeClass = bRating;
+			// Headrock: Added LBE set to Coolness Rating
+			bLBEClass = bRating;
 
 			if( ( bRating >= GOOD_ARMY_EQUIPMENT_RATING ) && ( Random( 100 ) < 33 ) )
 			{
@@ -373,6 +383,10 @@
 			if( Random( 2 ) )
 				bKnifeClass = bRating;
 
+			// Headrock: Chance for soldier to carry better LBE
+			if( Chance( 50 ) )
+				bLBEClass++;
+
 			if( ( bRating > MIN_EQUIPMENT_CLASS ) && bRating < MAX_EQUIPMENT_CLASS )
 			{
 				switch( Random( 7 ) )
@@ -453,6 +467,8 @@
 			bGrenadeClass = bRating;
 			bKitClass = bRating;
 			bMiscClass = bRating;
+			// Headrock: Elite LBEs
+			bLBEClass = bRating;
 
 			if ( Chance( 25 ) )
 			{
@@ -473,15 +489,18 @@
 
 			if( ( bRating > MIN_EQUIPMENT_CLASS ) && bRating < MAX_EQUIPMENT_CLASS )
 			{
-				switch( Random( 11 ) )
+				// CHRISL:
+				UINT32 uiRange = (!gGameOptions.ubInventorySystem) ? Random(11) : Random(12);
+				switch( uiRange )
 				{
 					case 4:		bWeaponClass++, bVestClass--;		break;
 					case 5:		bWeaponClass--, bVestClass--;		break;
 					case 6:		bVestClass++, bHelmetClass--;		break;
-					case 7:		bGrenades += 2;									break;
-					case 8:		bHelmetClass++;									break;
-					case 9:		bVestClass++;										break;
-					case 10:	bWeaponClass++;									break;
+					case 7:		bGrenades += 2;						break;
+					case 8:		bHelmetClass++;						break;
+					case 9:		bVestClass++;						break;
+					case 10:	bWeaponClass++;						break;
+					case 11:	bLBEClass++;						break;	/* CHRISL */
 				}
 			}
 
@@ -593,6 +612,9 @@
 					bMiscClass = 0;
 				case IC_BOMB:
 					bBombClass = 0;
+				// Headrock: Added failsafe for LBEs
+				case IC_LBEGEAR:
+					bLBEClass = 0;
 					break;
 			}
 		}
@@ -609,6 +631,8 @@
 
 	//Now actually choose the equipment!
 	ChooseWeaponForSoldierCreateStruct( pp, bWeaponClass, bAmmoClips, bAttachClass, fAttachment );
+	// Headrock: This is where the program calls LBE choosing
+	ChooseLBEsForSoldierCreateStruct( pp, bLBEClass );
 	ChooseSpecialWeaponsForSoldierCreateStruct( pp, bKnifeClass, fGrenadeLauncher, fLAW, fMortar, fRPG );
 	ChooseGrenadesForSoldierCreateStruct( pp, bGrenades, bGrenadeClass, fGrenadeLauncher );
 	ChooseArmourForSoldierCreateStruct( pp, bHelmetClass, bVestClass, bLeggingClass );
@@ -616,6 +640,8 @@
 	ChooseKitsForSoldierCreateStruct( pp, bKitClass );
 	ChooseMiscGearForSoldierCreateStruct( pp, bMiscClass );
 	ChooseBombsForSoldierCreateStruct( pp, bBombClass );
+	// Headrock: This is where the program calls LBE choosing
+	ChooseLBEsForSoldierCreateStruct( pp, bLBEClass );
 	ChooseLocationSpecificGearForSoldierCreateStruct( pp );
 	RandomlyChooseWhichItemsAreDroppable( pp, bSoldierClass );
 
@@ -1652,7 +1678,8 @@
 
 	//Look for any face item in the big pocket positions (the only place they can be added in the editor)
 	//If any are found, then don't assign any
-	for( i = BIGPOCK1POS; i < BIGPOCK4POS; i++ )
+	// CHRISL: Change static inventory pocket definition to dynamic
+	for( i = BIGPOCK1POS; i < BIGPOCKFINAL; i++ )
 	{
 		if( Item[ pp->Inv[ i ].usItem ].usItemClass == IC_FACE ) 
 		{
@@ -1984,6 +2011,28 @@
 
 
 
+// Headrock: Added a function to randomly create LBEs
+void ChooseLBEsForSoldierCreateStruct( SOLDIERCREATE_STRUCT *pp, INT8 bLBEClass )
+{
+	DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"ChooseLBEsForSoldierCreateStruct");
+	//UINT16 i;
+	//INVTYPE *pItem;
+	//UINT16 usRandom;
+	UINT16 usItem = 0;
+	OBJECTTYPE Object;
+
+	// CHRISL: If we're using the old inventory system, just return
+	if(!gGameOptions.ubInventorySystem)
+		return;
+
+	usItem = PickARandomItem( LBE , bLBEClass, FALSE );
+	if ( usItem > 0 )
+	{
+		CreateItem( usItem, (INT8)(80 + Random( 21 )), &Object );
+		Object.fFlags |= OBJECT_UNDROPPABLE;
+		PlaceObjectInSoldierCreateStruct( pp, &Object );
+	}
+}
 void ChooseLocationSpecificGearForSoldierCreateStruct( SOLDIERCREATE_STRUCT *pp )
 {
 	DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"ChooseLocationSpecificGearForSoldierCreateStruct");
@@ -2010,7 +2059,8 @@
 	if( !Item[ pObject->usItem ].ubPerPocket )
 	{ //ubPerPocket == 0 will only fit in large pockets.
 		pObject->ubNumberOfObjects = 1;
-		for( i = BIGPOCK1POS; i <= BIGPOCK4POS; i++ )
+		// CHRISL: Change static inventory pocket definition to dynamic
+		for( i = BIGPOCK1POS; i < BIGPOCKFINAL; i++ )
 		{
 			if( !(pp->Inv[ i ].usItem) && !(pp->Inv[ i ].fFlags & OBJECT_NO_OVERWRITE) )
 			{
@@ -2024,7 +2074,8 @@
 	{
 		pObject->ubNumberOfObjects = (UINT8)min( Item[ pObject->usItem ].ubPerPocket, pObject->ubNumberOfObjects );
 		//try to get it into a small pocket first
-		for( i = SMALLPOCK1POS; i <= SMALLPOCK8POS; i++ )
+		// CHRISL: Change static inventory pocket definition to dynamic
+		for( i = BIGPOCKFINAL; i < NUM_INV_SLOTS; i++ )
 		{
 			if( !(pp->Inv[ i ].usItem) && !(pp->Inv[ i ].fFlags & OBJECT_NO_OVERWRITE) )
 			{
@@ -2032,7 +2083,8 @@
 				return TRUE;
 			}
 		}
-		for( i = BIGPOCK1POS; i <= BIGPOCK4POS; i++ )
+		// CHRISL: Change static inventory pocket definition to dynamic
+		for( i = BIGPOCK1POS; i < BIGPOCKFINAL; i++ )
 		{ //no space free in small pockets, so put it into a large pocket.
 			if( !(pp->Inv[ i ].usItem) && !(pp->Inv[ i ].fFlags & OBJECT_NO_OVERWRITE) )
 			{
Index: Tactical/Inventory Choosing.h
===================================================================
--- Tactical/Inventory Choosing.h	(revision 1299)
+++ Tactical/Inventory Choosing.h	(working copy)
@@ -88,6 +88,7 @@
 
 extern ARMY_GUN_CHOICE_TYPE gExtendedArmyGunChoices[ARMY_GUN_LEVELS];
 
+// Headrock: Added LBE enumeration
 enum
 {
 	HELMET = 0,
@@ -110,10 +111,11 @@
 	ATTACHMENTS,
 	KNIVES,
 	ENEMYAMMOTYPES,
+	LBE,
 	MAX_ITEM_TYPES
 };
 
 extern ARMY_GUN_CHOICE_TYPE gArmyItemChoices[MAX_ITEM_TYPES];
 
 
-#endif
\ No newline at end of file
+#endif
Index: Tactical/Item Types.h
===================================================================
--- Tactical/Item Types.h	(revision 1299)
+++ Tactical/Item Types.h	(working copy)
@@ -2,7 +2,10 @@
 #define ITEM_TYPES_H
 
 #include "types.h"
+#include <vector>
 
+using namespace std;
+
 #define INVALIDCURS 0
 #define QUESTCURS 1
 #define PUNCHCURS 2
@@ -150,7 +153,7 @@
 	UINT8		ubMission;
 	INT8		bTrap;        // 1-10 exp_lvl to detect
 	UINT8		ubImprintID;	// ID of merc that item is imprinted on
-	UINT8		ubWeight;
+	UINT16		ubWeight;	// CHRISL:
 	UINT8		fUsed;				// flags for whether the item is used or not
 } OBJECTTYPE;
 
@@ -204,6 +207,7 @@
 #define IC_FACE           0x00008000
 
 #define IC_KEY						0x00010000
+#define IC_LBEGEAR					0x00020000	// Added for LBE items as part of the new inventory system
 
 #define IC_MISC						0x10000000
 #define IC_MONEY					0x20000000
@@ -213,7 +217,7 @@
 #define IC_EXPLOSV				( IC_GRENADE | IC_BOMB )
 
 #define IC_BOBBY_GUN			( IC_GUN | IC_LAUNCHER )
-#define IC_BOBBY_MISC			( IC_GRENADE | IC_BOMB | IC_MISC | IC_MEDKIT | IC_KIT | IC_BLADE | IC_THROWING_KNIFE | IC_PUNCH | IC_FACE )
+#define IC_BOBBY_MISC			( IC_GRENADE | IC_BOMB | IC_MISC | IC_MEDKIT | IC_KIT | IC_BLADE | IC_THROWING_KNIFE | IC_PUNCH | IC_FACE | IC_LBEGEAR )
 
 
 // replaces candamage
@@ -270,6 +274,7 @@
 	UINT16			ubGraphicNum;
 	UINT8			ubWeight; //2 units per kilogram; roughly 1 unit per pound
 	UINT8			ubPerPocket;
+	UINT8			ItemSize;
 	UINT16		usPrice;
 	UINT8			ubCoolness;
 	INT8			bReliability;
@@ -341,6 +346,7 @@
 	INT16	dayvisionrangebonus;
 	INT16	cavevisionrangebonus;
 	INT16	brightlightvisionrangebonus;
+	INT16	itemsizebonus;
 	BOOLEAN leatherjacket;
 	BOOLEAN batteries;
 	BOOLEAN needsbatteries;
@@ -394,6 +400,50 @@
 	UINT16 defaultattachment;
 } INVTYPE;
 
+// CHRISL: Added new structures to handle LBE gear and the two new XML files that will be needed to deal
+// with the IC pockets and the new inventory system.
+class LBETYPE{
+public:
+	LBETYPE();
+	LBETYPE(const LBETYPE&);
+	LBETYPE& operator=(const LBETYPE&);
+	~LBETYPE();
+	UINT16			lbeIndex;
+	UINT32			lbeClass;
+	UINT8			lbeCombo;
+	char			POD;
+	vector<UINT8>	lbePocketIndex;
+};
+#define SIZEOF_LBETYPE offsetof( LBETYPE, POD )
+extern vector<LBETYPE> LoadBearingEquipment;
+
+class POCKETTYPE{
+public:
+	POCKETTYPE();
+	POCKETTYPE(const POCKETTYPE&);
+	POCKETTYPE& operator=(const POCKETTYPE&);
+	~POCKETTYPE();
+	UINT16			pIndex;
+	CHAR8			pName[80];
+	UINT8			pSilhouette;
+	UINT16			pType;
+	UINT32			pRestriction;
+	char			POD;
+	vector<UINT8>	ItemCapacityPerSize;
+};
+#define SIZEOF_POCKETTYPE offsetof( POCKETTYPE, POD )
+extern vector<POCKETTYPE> LBEPocketType;
+
+enum	// Designation of lbeClass
+{
+	THIGH_PACK=1,
+	VEST_PACK,
+	COMBAT_PACK,
+	BACKPACK,
+	LBE_POCKET,
+	OTHER_POCKET
+};
+
 #define FIRST_WEAPON 1
 #define FIRST_AMMO 71
 #define FIRST_EXPLOSIVE 131
@@ -903,4 +953,4 @@
 
 extern IMP_ITEM_CHOICE_TYPE gIMPItemChoices[MAX_IMP_ITEM_TYPES];
 
-#endif
\ No newline at end of file
+#endif
Index: Tactical/Items.cpp
===================================================================
--- Tactical/Items.cpp	(revision 1299)
+++ Tactical/Items.cpp	(working copy)
@@ -1183,6 +1183,69 @@
 	{ 0,								0							 }
 };
 
+// CHRISL: Structure Definitions for new inventory system items.
+vector<LBETYPE> LoadBearingEquipment;
+//LBETYPE LoadBearingEquipment[MAXITEMS+1];
+//LBETYPE LoadBearingEquipment[] =
+//{
+//	//	Index	Class						Pocket Types---------------------------------
+//	{	0,		/*Blank Entry*/			0,	{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	1,		/*Default Thigh Pack*/	0,	{1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	2,		/*Default Vest Pack*/	1,	{1,	1,	0,	0,	0,	0,	0,	0,	2,	0,	0,	0} },
+//	{	3,		/*Default Combat Pack*/	2,	{1,	1,	0,	0,	2,	0,	0,	0,	0,	0,	0,	0} },
+//	{	4,		/*Default Back Pack*/	3,	{1,	1,	0,	0,	0,	0,	0,	0,	3,	3,	0,	0} },
+//	{	5,		/*6P Backpack*/			3,	{1,	1,	1,	1,	0,	0,	0,	0,	3,	3,	0,	0} },
+//	{	6,		/*6P Combat Pack*/		2,	{1,	1,	1,	1,	2,	2,	0,	0,	0,	0,	0,	0} }
+//};
+
+vector<POCKETTYPE> LBEPocketType;
+//POCKETTYPE LBEPocketType[MAXITEMS+1]; //= 
+//{
+//	{	/* Blank Entry */			0,	0,	0,	{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	/* Small General Pocket */	1,	0,	0,	{4,	3,	2,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	/* Med General Pocket */	2,	0,	0,	{7,	6,	5,	4,	3,	2,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	/* Lg General Pocket */		3,	0,	0,	{10,9,	8,	7,	6,	5,	4,	3,	2,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	/* Gun Sling */				4,	0,	1,	{0,	0,	0,	0,	0,	1,	1,	1,	1,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} },
+//	{	/* Knife Pocket */			5,	0,	1,	{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0} }
+//};
+
+LBETYPE::LBETYPE(){
+	memset(this, 0, SIZEOF_LBETYPE);
+	lbePocketIndex.resize(12);
+}
+LBETYPE::LBETYPE(const LBETYPE& src) {
+	memcpy(this, &src, SIZEOF_LBETYPE);
+	lbePocketIndex.resize(12);
+	lbePocketIndex = src.lbePocketIndex;
+}
+LBETYPE& LBETYPE::operator=(const LBETYPE& src){
+    if (this != &src) {
+		memcpy(this, &src, SIZEOF_LBETYPE);
+		lbePocketIndex = src.lbePocketIndex;
+    }
+    return *this;
+}
+LBETYPE::~LBETYPE(){
+}
+POCKETTYPE::POCKETTYPE(){
+	memset(this, 0, SIZEOF_POCKETTYPE);
+	ItemCapacityPerSize.resize(35);
+}
+POCKETTYPE::POCKETTYPE(const POCKETTYPE& src){
+	memcpy(this, &src, SIZEOF_POCKETTYPE);
+	ItemCapacityPerSize.resize(35);
+	ItemCapacityPerSize = src.ItemCapacityPerSize;
+}
+POCKETTYPE& POCKETTYPE::operator=(const POCKETTYPE& src){
+    if (this != &src) {
+		memcpy(this, &src, SIZEOF_POCKETTYPE);
+		ItemCapacityPerSize = src.ItemCapacityPerSize;
+    }
+    return *this;
+}
+POCKETTYPE::~POCKETTYPE(){
+}
+
 BOOLEAN ItemIsLegal( UINT16 usItemIndex )
 {
 	//if the user has selected the reduced gun list
@@ -1207,7 +1270,19 @@
 		return FALSE;
 	}
 
+	// CHRISL: Restrict system specific items
+	if( gGameOptions.ubInventorySystem )
+	{
+		if(Item[usItemIndex].ItemSize == 99)
+			return FALSE;
+	}
+	else
+	{
+		if(Item[usItemIndex].usItemClass == IC_LBEGEAR)
+			return FALSE;
+	}
 
+
 	return(TRUE);
 } 
 
@@ -1301,18 +1376,19 @@
 	return( FALSE );
 }
 
-UINT8 ItemSlotLimit( UINT16 usItem, INT8 bSlot )
+// CHRISL:
+UINT8 ItemSlotLimit( UINT16 usItem, INT16 bSlot )
 {
 	UINT8 ubSlotLimit;
 
-	if ( bSlot < BIGPOCK1POS )
+	if ( bSlot < BODYPOSFINAL )
 	{
 		return( 1 );
 	}
 	else
 	{
 		ubSlotLimit = Item[usItem].ubPerPocket;
-		if (bSlot >= SMALLPOCK1POS && ubSlotLimit > 1)
+		if (bSlot >= BIGPOCKFINAL && ubSlotLimit > 1)
 		{
 			ubSlotLimit /= 2;
 		}
@@ -1320,9 +1396,58 @@
 	}
 }
 
+// CHRISL: New definition for this function so that we can look at soldiers LBE pockets.
+UINT8 ItemSlotLimit( OBJECTTYPE * pObject, INT16 bSlot, SOLDIERTYPE *pSoldier )
+{
+	UINT8	ubSlotLimit;
+	UINT8	pIndex;
+	UINT16	usItem, iSize;
+	UINT32	iClass, pRestrict;
+
+	usItem = pObject->usItem;
+	if(gGameOptions.ubInventorySystem && (pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+	{
+		ubSlotLimit = Item[usItem].ubPerPocket;
+		if ( ubSlotLimit > MAX_OBJECTS_PER_SLOT )
+			ubSlotLimit = MAX_OBJECTS_PER_SLOT;
+		return( ubSlotLimit );
+	}
+	else if ( bSlot < BODYPOSFINAL && bSlot != KNIFEPOCKPOS && bSlot != GUNSLINGPOCKPOS )
+	{
+		return( 1 );
+	}
+	else
+	{
+		// IC Group Slots
+		if(bSlot == GUNSLINGPOCKPOS)
+			pIndex = 1;
+		else if(bSlot == KNIFEPOCKPOS)
+			pIndex = 2;
+		else
+			pIndex = (pSoldier->inv[icLBE[bSlot]].usItem == NOTHING) ? LoadBearingEquipment[icClass[bSlot]].lbePocketIndex[icPocket[bSlot]] : LoadBearingEquipment[Item[pSoldier->inv[icLBE[bSlot]].usItem].ubClassIndex].lbePocketIndex[icPocket[bSlot]];
+		
+		//ubSlotLimit = LBEPocketType[pIndex].ItemCapacityPerSize[Item[usItem].ItemSize];
+		iSize = CalculateItemSize(pObject);
+		ubSlotLimit = LBEPocketType[pIndex].ItemCapacityPerSize[iSize];
+		pRestrict = LBEPocketType[pIndex].pRestriction;
+		iClass = Item[usItem].usItemClass;
+		// CHRISL: Include maximum capacity limits to keep game from crashing
+		if ( ubSlotLimit > MAX_OBJECTS_PER_SLOT )
+			ubSlotLimit = MAX_OBJECTS_PER_SLOT;
+		//if ( Item[usItem].ItemSize < 10 && ubSlotLimit > 1)	// Item is a gun
+		if ( iSize < 10 && ubSlotLimit > 1)
+			ubSlotLimit = 1;
+		if(pRestrict != 0)
+			if(pRestrict != iClass)
+				ubSlotLimit = 0;
+		
+		return( ubSlotLimit );
+	}
+}
+
 UINT32 MoneySlotLimit( INT8 bSlot )
 {
-	if ( bSlot >= SMALLPOCK1POS )
+	if ( bSlot >= BIGPOCKFINAL )	/* CHRISL */
 	{
 		return( MAX_MONEY_PER_SLOT / 2 );
 	}
@@ -1544,6 +1669,11 @@
 
 	for (bLoop = bLower; bLoop <= bUpper; bLoop++)
 	{
+		// CHRISL: Only look at valid pockets
+		if(!gGameOptions.ubInventorySystem && !oldInv[bLoop])
+			continue;
+		if((pSoldier->uiStatusFlags & SOLDIER_VEHICLE) && !vehicleInv[bLoop])
+			continue;
 		if (pSoldier->inv[bLoop].usItem == 0)
 		{
 //			if (bLoop == SECONDHANDPOS && Item[pSoldier->inv[HANDPOS].usItem].fFlags & ITEM_TWO_HANDED)
@@ -2212,10 +2342,106 @@
 	return( EvaluateValidMerge( usMerge, usItem, &usIgnoreResult, &usIgnoreResult2, &ubIgnoreType, &ubIgnoreAPCost ) );
 }
 
-UINT8 CalculateObjectWeight( OBJECTTYPE *pObject )
+// CHRISL: New function to dynamically modify ItemSize based on attachments
+UINT16 CalculateItemSize( OBJECTTYPE *pObject )
 {
+	UINT16		iSize, newSize, testSize;
+	UINT32		cisIndex;
+	BOOLEAN		psFound = FALSE;
+	UINT8		cisPocketSize[6][4] =
+	{
+		11, 12, 13, 14,
+		15, 16, 17, 18,
+		19, 20, 21, 22,
+		23, 24, 25, 26,
+		27, 28, 29, 30,
+		31, 32, 33, 34
+	};
+	int			cnt, cnt1, cnt2;
+	int			nCnt1, nCnt2;
+
+	// Determine default ItemSize based on item and attachments
+	cisIndex = pObject->usItem;
+	iSize = Item[cisIndex].ItemSize;
+	if(iSize>34)
+		iSize = 34;
+	for(cnt1=0; cnt1<6; cnt1++)
+	{
+		for(cnt2=0; cnt2<4; cnt2++)
+		{
+			if(iSize == cisPocketSize[cnt1][cnt2])
+			{
+				psFound = TRUE;
+				break;
+			}
+		}
+		if(psFound)
+			break;
+	}
+	for (cnt=0; cnt<MAX_ATTACHMENTS; cnt++)
+	{
+		if(pObject->usAttachItem[cnt] != NOTHING)
+		{
+			iSize += Item[pObject->usAttachItem[cnt]].itemsizebonus;
+		}
+	}
+	// Check if we're looking at a LBENODE or not
+	if(pObject->ItemData.Trigger.bDetonatorType == -1)
+	{
+		if(LBEptr[pObject->ItemData.Trigger.usBombItem].lbeIndex != NULL)
+		{
+			newSize = 0;
+			for(cnt=0; cnt<12; cnt++)
+			{
+				if(LBEptr[pObject->ItemData.Trigger.usBombItem].inv[cnt].usItem != NOTHING)
+				{
+					testSize = CalculateItemSize(&LBEptr[pObject->ItemData.Trigger.usBombItem].inv[cnt]);
+					newSize = (testSize > newSize) ? testSize : newSize;
+				}
+			}
+		}
+		// Resize based on contents
+		if(newSize > 0)
+		{
+			psFound = FALSE;
+			for(nCnt1=0; nCnt1<6; nCnt1++)
+			{
+				for(nCnt2=0; nCnt2<4; nCnt2++)
+				{
+					if(newSize == cisPocketSize[nCnt1][nCnt2])
+					{
+						psFound = TRUE;
+						break;
+					}
+				}
+				if(psFound)
+					break;
+			}
+			if((cnt1-2)>=nCnt1)	// Stored item is much smaller then an empty LBE item.  Don't change size
+				iSize = iSize;
+			else if((cnt1-1)==nCnt1)	// Stored item is large enough to increase LBE item size.
+			{
+				if(nCnt2 > cnt2)
+					cnt2 = nCnt2;
+				iSize = cisPocketSize[cnt1][cnt2];
+			}
+			else	// Stored item is very large compared to the LBE item.
+			{
+				cnt2 = 3;
+				iSize = cisPocketSize[cnt1][cnt2];
+			}
+		}
+	}
+
+	return(iSize);
+}
+
+/*CHRISL: Change to a 16bit integer for a max weight of 6553.5kg.  Also changed to account for
+new inventory system. */
+UINT16 CalculateObjectWeight( OBJECTTYPE *pObject )
+{
 	INT32 cnt;
-	UINT16 usWeight;
+	UINT16 usWeight, tWeight;
 	INVTYPE * pItem;
 
 	pItem = &(Item[ pObject->usItem ]);
@@ -2223,8 +2449,23 @@
 	// Start with base weight
 	usWeight = pItem->ubWeight;
 
-	if ( pItem->ubPerPocket < 2 && pItem->usItemClass != IC_AMMO )
+	// Are we looking at an LBENODE item?  New inventory only.
+	if(pItem->usItemClass == IC_LBEGEAR && pObject->ItemData.Trigger.bDetonatorType == ITEM_NOT_FOUND && gGameOptions.ubInventorySystem)
 	{
+		for ( cnt = 0; cnt < 12; cnt++)
+		{
+			if (LBEptr[pObject->ItemData.Trigger.usBombItem].inv[cnt].usItem != NOTHING)
+			{
+				tWeight = CalculateObjectWeight(&(LBEptr[pObject->ItemData.Trigger.usBombItem].inv[cnt]));
+				if(Item[LBEptr[pObject->ItemData.Trigger.usBombItem].inv[cnt].usItem].usItemClass != IC_AMMO)
+					tWeight *= LBEptr[pObject->ItemData.Trigger.usBombItem].inv[cnt].ubNumberOfObjects;
+				usWeight += tWeight;
+			}
+		}
+	}
+	// Are we looking at an item that can have attachments?
+	else if ( pItem->ubPerPocket < 2 && pItem->usItemClass != IC_AMMO )
+	{
 
 		// account for any attachments
 		for ( cnt = 0; cnt < MAX_ATTACHMENTS; cnt++ )
@@ -2238,12 +2479,12 @@
 		// add in weight of ammo
 		if (Item[ pObject->usItem ].usItemClass == IC_GUN && pObject->ItemData.Gun.ubGunShotsLeft > 0)
 		{
-      if( 0==pObject->ItemData.Gun.usGunAmmoItem ) /* Sergeant_Kolja: 2007-06-11, Fix for Creature Spit. This has no Ammo, so the old code calculated accidentally -1.6 resulting in 0xFFFF */
-        {
-        	DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "'no ammo weight' FIX for Creatures\r\n" );
-        }
-      else if( gGameExternalOptions.fAmmoDynamicWeight == TRUE )
+			if( 0==pObject->ItemData.Gun.usGunAmmoItem ) /* Sergeant_Kolja: 2007-06-11, Fix for Creature Spit. This has no Ammo, so the old code calculated accidentally -1.6 resulting in 0xFFFF */
 			{
+				DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "'no ammo weight' FIX for Creatures\r\n" );
+			}
+			else if( gGameExternalOptions.fAmmoDynamicWeight == TRUE )
+			{
 				//Pulmu:
 				//Temporary calculation for minWeight
 				UINT32 uiMinWeight = (UINT32)((Item[ pObject->ItemData.Gun.usGunAmmoItem].ubWeight / 5.0) + 0.5);
@@ -2302,14 +2543,18 @@
 
 
 	// make sure it really fits into that UINT8, in case we ever add anything real heavy with attachments/ammo
-	Assert(usWeight <= 255);
+	// CHRISL: Remove this assertion since the next line resets usWeight to the max value
+	//Assert(usWeight <= 255);
 
-	if ( usWeight > 255 )
-		usWeight = 255; //Madd: limit to 255 to prevent negative weights, at least until we can change the OBJECTTYPE structure
+	// CHRISL: Change max value from 8bit (255) to 16bit (65535)
+	if ( usWeight > 65535 )
+		usWeight = 65535; //Madd: limit to 255 to prevent negative weights, at least until we can change the OBJECTTYPE structure
 
-	return( (UINT8) usWeight );
+	// CHRISL: Return a 16bit value
+	return (usWeight);
 }
 
+// CHRISL: Calculate weight of item stacks for large items in new inventory system
 UINT32 CalculateCarriedWeight( SOLDIERTYPE * pSoldier )
 {
 	UINT32	uiTotalWeight = 0;
@@ -2322,10 +2567,13 @@
 	for( ubLoop = 0; ubLoop < NUM_INV_SLOTS; ubLoop++)
 	{
 		usWeight = pSoldier->inv[ubLoop].ubWeight;
-		if (Item[ pSoldier->inv[ubLoop].usItem ].ubPerPocket > 1 && (Item[ pSoldier->inv[ubLoop].usItem].usItemClass != IC_AMMO || gGameExternalOptions.fAmmoDynamicWeight == FALSE))
+		if(Item[ pSoldier->inv[ubLoop].usItem].usItemClass != IC_AMMO || gGameExternalOptions.fAmmoDynamicWeight == FALSE)
 		{
-			// account for # of items
-			usWeight *= pSoldier->inv[ubLoop].ubNumberOfObjects;
+			if(gGameOptions.ubInventorySystem || Item[ pSoldier->inv[ubLoop].usItem ].ubPerPocket > 1)
+			{
+				// account for # of items
+				usWeight *= pSoldier->inv[ubLoop].ubNumberOfObjects;
+			}
 		}
 		uiTotalWeight += usWeight;
 
@@ -3687,11 +3935,43 @@
 }
 
 
+/* CHRISL: This function is edited to handle the new inventory system when we have an item in our cursor.
+Not only do we have to hatch out pockets that the item won't fit in, we also have to hatch out pockets that
+our current LBE gear haven't activated.  We'll also need to display the number of items of the type currently
+held in the cursor that each active pocket can hold.*/
+extern BOOLEAN CompatibleAmmoForGun( OBJECTTYPE *pTryObject, OBJECTTYPE *pTestObject );
+BOOLEAN CanItemFitInVehicle( SOLDIERTYPE *pSoldier, OBJECTTYPE *pObj, INT8 bPos, BOOLEAN fDoingPlacement )
+{
+	UINT8					ubSlotLimit, lbePocket=1;
+	INT8					bNewPos=ITEM_NOT_FOUND;
+	UINT32					pRestrict=0;
+
+	if(!gGameOptions.ubInventorySystem || !(pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+		return(FALSE);
+	if(!vehicleInv[bPos])
+		return(FALSE);
+
+	ubSlotLimit = ItemSlotLimit( pObj, bPos, pSoldier );
+
+	if ( ubSlotLimit == 0 )
+		return ( CompatibleAmmoForGun(pObj, &pSoldier->inv[bPos]) );
+
+	return( TRUE );
+}
 BOOLEAN CanItemFitInPosition( SOLDIERTYPE *pSoldier, OBJECTTYPE *pObj, INT8 bPos, BOOLEAN fDoingPlacement )
 {
-	UINT8					ubSlotLimit;
-	INT8					bNewPos;
+	UINT8					ubSlotLimit, lbePocket=1;
+	INT8					bNewPos=ITEM_NOT_FOUND;
+	UINT32					pRestrict=0;
 
+	// CHRISL: Only check valid pockets
+	if(!gGameOptions.ubInventorySystem && !oldInv[bPos])
+		return(FALSE);
+	if((pSoldier->uiStatusFlags & SOLDIER_VEHICLE))
+		return(CanItemFitInVehicle(pSoldier, pObj, bPos, fDoingPlacement));
+
+	ubSlotLimit = (!gGameOptions.ubInventorySystem) ? ItemSlotLimit( pObj->usItem, bPos ) : ItemSlotLimit( pObj, bPos, pSoldier );
+
 	switch( bPos )
 	{
 		case SECONDHANDPOS:
@@ -3708,13 +3988,14 @@
 				if (pSoldier->inv[HANDPOS].usItem != NOTHING && pSoldier->inv[SECONDHANDPOS].usItem != NOTHING)
 				{
 					// two items in hands; try moving the second one so we can swap 
+					// CHRISL: Adjust parameters to include the new inventory system
 					if (Item[pSoldier->inv[SECONDHANDPOS].usItem].ubPerPocket == 0)
 					{
-						bNewPos = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, BIGPOCK4POS );
+						bNewPos = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, (BIGPOCKFINAL-1) );
 					}
 					else
 					{
-						bNewPos = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, SMALLPOCK8POS );
+						bNewPos = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, (NUM_INV_SLOTS-1) );
 					}
 					if (bNewPos == NO_SLOT)
 					{
@@ -3768,17 +4049,143 @@
 			{
 				return( FALSE );
 			}
+			break;
+		case VESTPOCKPOS:
+			if (Item[pObj->usItem].usItemClass != IC_LBEGEAR || LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass != VEST_PACK)
+			{
+				return( FALSE );
+			}
+			break;
+		case LTHIGHPOCKPOS:
+			if (Item[pObj->usItem].usItemClass != IC_LBEGEAR || LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass != THIGH_PACK)
+			{
+				return( FALSE );
+			}
+			break;
+		case RTHIGHPOCKPOS:
+			if (Item[pObj->usItem].usItemClass != IC_LBEGEAR || LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass != THIGH_PACK)
+			{
+				return( FALSE );
+			}
+			break;
+		case CPACKPOCKPOS:
+			if (Item[pObj->usItem].usItemClass != IC_LBEGEAR || LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass != COMBAT_PACK)
+			{
+				return( FALSE );
+			}
+			if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING)
+			{
+				if(LoadBearingEquipment[Item[pSoldier->inv[BPACKPOCKPOS].usItem].ubClassIndex].lbeCombo != LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeCombo ||
+				LoadBearingEquipment[Item[pSoldier->inv[BPACKPOCKPOS].usItem].ubClassIndex].lbeCombo == 0)
+				{
+					return( FALSE );
+				}
+			}
+			break;
+		case BPACKPOCKPOS:
+			if (Item[pObj->usItem].usItemClass != IC_LBEGEAR || LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeClass != BACKPACK)
+			{
+				return( FALSE );
+			}
+			// Removed backpack/gunsling restrictions
+			//if(pSoldier->inv[GUNSLINGPOCKPOS].usItem != NOTHING)
+			//	return( FALSE );
+			if(pSoldier->inv[CPACKPOCKPOS].usItem != NOTHING)
+			{
+				if(LoadBearingEquipment[Item[pSoldier->inv[CPACKPOCKPOS].usItem].ubClassIndex].lbeCombo != LoadBearingEquipment[Item[pObj->usItem].ubClassIndex].lbeCombo ||
+				LoadBearingEquipment[Item[pSoldier->inv[CPACKPOCKPOS].usItem].ubClassIndex].lbeCombo == 0)
+				{
+					return( FALSE );
+				}
+			}
+			break;
+		case GUNSLINGPOCKPOS:	// Gun Sling
+			//if (Item[pObj->usItem].usItemClass != IC_GUN && Item[pObj->usItem].usItemClass != IC_BLADE && Item[pObj->usItem].usItemClass != IC_LAUNCHER)
+			if(Item[pObj->usItem].usItemClass == IC_AMMO || Item[pObj->usItem].usItemClass == IC_GRENADE)
+				return(CompatibleAmmoForGun(pObj, &pSoldier->inv[GUNSLINGPOCKPOS]));
+			// Removed backpack/gunsling restrictions
+			//if(pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING)
+			//	return(CompatibleAmmoForGun(pObj, &pSoldier->inv[GUNSLINGPOCKPOS]));
+			break;
+		case KNIFEPOCKPOS:	// Knife sheath
+			if (Item[pObj->usItem].usItemClass != IC_BLADE && Item[pObj->usItem].usItemClass != IC_THROWING_KNIFE )
+				return(CompatibleAmmoForGun(pObj, &pSoldier->inv[KNIFEPOCKPOS]));
+			break;
+		// IC Pockets
+		case BIGPOCK1POS:
+		case BIGPOCK2POS:
+		case BIGPOCK3POS:
+		case BIGPOCK4POS:
+		case BIGPOCK5POS:
+		case BIGPOCK6POS:
+		case BIGPOCK7POS:
+		case MEDPOCK1POS:
+		case MEDPOCK2POS:
+		case MEDPOCK3POS:
+		case MEDPOCK4POS:
+		case SMALLPOCK2POS:
+		case SMALLPOCK3POS:
+		case SMALLPOCK4POS:
+		case SMALLPOCK5POS:
+		case SMALLPOCK6POS:
+		case SMALLPOCK7POS:
+		case SMALLPOCK8POS:
+		case SMALLPOCK9POS:
+		case SMALLPOCK10POS:
+		case SMALLPOCK11POS:
+		case SMALLPOCK12POS:
+		case SMALLPOCK13POS:
+		case SMALLPOCK14POS:
+		case SMALLPOCK15POS:
+		case SMALLPOCK16POS:
+		case SMALLPOCK17POS:
+		case SMALLPOCK18POS:
+		case SMALLPOCK19POS:
+		case SMALLPOCK20POS:
+		case SMALLPOCK21POS:
+		case SMALLPOCK22POS:
+		case SMALLPOCK23POS:
+		case SMALLPOCK24POS:
+		case SMALLPOCK25POS:
+		case SMALLPOCK26POS:
+		case SMALLPOCK27POS:
+		case SMALLPOCK28POS:
+		case SMALLPOCK29POS:
+		case SMALLPOCK30POS:
+			if(gGameOptions.ubInventorySystem)
+			{
+				if(icLBE[bPos] == BPACKPOCKPOS && (!(pSoldier->ZipperFlag) || (pSoldier->ZipperFlag && gAnimControl[pSoldier->usAnimState].ubEndHeight == ANIM_STAND)) && (gTacticalStatus.uiFlags & INCOMBAT))
+					return( FALSE );
+				lbePocket = (pSoldier->inv[icLBE[bPos]].usItem == NOTHING) ? LoadBearingEquipment[icClass[bPos]].lbePocketIndex[icPocket[bPos]] : LoadBearingEquipment[Item[pSoldier->inv[icLBE[bPos]].usItem].ubClassIndex].lbePocketIndex[icPocket[bPos]];
+				pRestrict = LBEPocketType[lbePocket].pRestriction;
+				if(pRestrict != 0)
+					if(pRestrict != Item[pObj->usItem].usItemClass)
+						lbePocket = 0;
+			}
+			break;
 		default:
 			break;
 	}
 
-	ubSlotLimit = ItemSlotLimit( pObj->usItem, bPos );
-	if (ubSlotLimit == 0 && bPos >= SMALLPOCK1POS )
+	if(!gGameOptions.ubInventorySystem)
 	{
-		// doesn't fit!
-		return( FALSE );
+		if (ubSlotLimit == 0 && bPos >= SMALLPOCK1POS )
+		{
+			// doesn't fit!
+			return( FALSE );
+		}
 	}
+	else
+	{
+		// CHRISL: lbePocket==0 means pocket disabled.  ubSlotLimit==0 means pocket can't hold item
+		if ( lbePocket == 0 || ubSlotLimit == 0 )
+			return ( CompatibleAmmoForGun(pObj, &pSoldier->inv[bPos]) );
 
+		// CHRISL: Adjust parameters to include the new inventory system
+		if (ubSlotLimit == 0 && bPos >= BIGPOCKFINAL )
+			return( CompatibleAmmoForGun(pObj, &pSoldier->inv[bPos]) );
+	}
+
 	return( TRUE );
 }
 
@@ -3872,7 +4279,8 @@
     }
     // Lesh: end
 
-	ubSlotLimit = ItemSlotLimit( pObj->usItem, bPos );
+	// CHRISL:
+	ubSlotLimit = (!gGameOptions.ubInventorySystem) ? ItemSlotLimit( pObj->usItem, bPos ) : ItemSlotLimit( pObj, bPos, pSoldier );
 
 	pInSlot = &(pSoldier->inv[bPos]);
 
@@ -3962,7 +4370,8 @@
 */
 				}
 			}
-			else if ( ubSlotLimit == 1 || (ubSlotLimit == 0 && bPos >= HANDPOS && bPos <= BIGPOCK4POS ) )
+			// CHRISL
+			else if ( ubSlotLimit == 1 || (ubSlotLimit == 0 && bPos >= HANDPOS && bPos < BIGPOCKFINAL ) )
 			{
 				if (pObj->ubNumberOfObjects <= 1)
 				{
@@ -4060,11 +4469,14 @@
 	return( TRUE );
 }
 
+// CHRISL: Function needed for LBENODE
+extern BOOLEAN MoveItemFromLBEItem( SOLDIERTYPE *pSoldier, UINT32 uiHandPos, OBJECTTYPE *pObj );
+
 BOOLEAN InternalAutoPlaceObject( SOLDIERTYPE * pSoldier, OBJECTTYPE * pObj, BOOLEAN fNewItem, INT8 bExcludeSlot )
 {
 	INT8			bSlot;
 	INVTYPE	* pItem;
-	UINT8			ubPerSlot;
+	UINT8			ubPerSlot, packCombo, backCombo;
 
 	// statuses of extra objects would be 0 if the # exceeds the maximum
 	Assert( pObj->ubNumberOfObjects <= MAX_OBJECTS_PER_SLOT);
@@ -4078,7 +4490,23 @@
 	switch (pItem->usItemClass)
 	{
 		case IC_GUN:
+			// CHRISL: 
+			if(gGameOptions.ubInventorySystem && (pItem->twohanded) && pSoldier->inv[GUNSLINGPOCKPOS].usItem == NONE)	// Long Gun use Gun Sling
+			{
+				PlaceObject( pSoldier, GUNSLINGPOCKPOS, pObj );
+				SetNewItem( pSoldier, GUNSLINGPOCKPOS, fNewItem );
+				if (pObj->ubNumberOfObjects == 0)
+					return( TRUE );
+			}
 		case IC_BLADE:
+			// CHRISL:
+			if(gGameOptions.ubInventorySystem && pSoldier->inv[KNIFEPOCKPOS].usItem == NONE)	// Knife
+			{
+				PlaceObject( pSoldier, KNIFEPOCKPOS, pObj );
+				SetNewItem( pSoldier, KNIFEPOCKPOS, fNewItem );
+				if (pObj->ubNumberOfObjects == 0)
+					return( TRUE );
+			}
 		case IC_LAUNCHER:
 		case IC_BOMB:
 		case IC_GRENADE:
@@ -4127,6 +4555,13 @@
 					}
 					break;
 				case ARMOURCLASS_LEGGINGS:
+					// CHRISL:
+					if(Item[pSoldier->inv[LEGPOS].usItem].attachment)
+					{
+						pObj->usAttachItem[0] = pSoldier->inv[LEGPOS].usItem;
+						pObj->bAttachStatus[0] = pSoldier->inv[LEGPOS].ItemData.Generic.bStatus[0];
+						pSoldier->inv[LEGPOS].usItem = NONE;
+					}
 					if (pSoldier->inv[LEGPOS].usItem == NONE)
 					{
 						// put on the armour!
@@ -4175,6 +4610,68 @@
 				}
 			}
 			break;
+		// CHRISL:
+		case IC_LBEGEAR:
+			if(gGameOptions.ubInventorySystem)
+			{
+				if(pSoldier->inv[LTHIGHPOCKPOS].usItem == NOTHING && LoadBearingEquipment[pItem->ubClassIndex].lbeClass == THIGH_PACK)	// Thigh pack
+				{
+					MoveItemFromLBEItem( pSoldier, LTHIGHPOCKPOS, pObj);
+					PlaceObject( pSoldier, LTHIGHPOCKPOS, pObj );
+					SetNewItem( pSoldier, LTHIGHPOCKPOS, fNewItem );
+					if(pObj->ubNumberOfObjects == 0)
+						return( TRUE );
+				}
+				else if(pSoldier->inv[RTHIGHPOCKPOS].usItem == NOTHING && LoadBearingEquipment[pItem->ubClassIndex].lbeClass == THIGH_PACK)	// Thigh pack
+				{
+					MoveItemFromLBEItem( pSoldier, RTHIGHPOCKPOS, pObj);
+					PlaceObject( pSoldier, RTHIGHPOCKPOS, pObj );
+					SetNewItem( pSoldier, RTHIGHPOCKPOS, fNewItem );
+					if(pObj->ubNumberOfObjects == 0)
+						return( TRUE );
+				}
+				else if(pSoldier->inv[VESTPOCKPOS].usItem == NOTHING && LoadBearingEquipment[pItem->ubClassIndex].lbeClass == VEST_PACK)	// Vest pack
+				{
+					MoveItemFromLBEItem( pSoldier, VESTPOCKPOS, pObj);
+					PlaceObject( pSoldier, VESTPOCKPOS, pObj );
+					SetNewItem( pSoldier, VESTPOCKPOS, fNewItem );
+					if(pObj->ubNumberOfObjects == 0)
+						return( TRUE );
+				}
+				else if(pSoldier->inv[CPACKPOCKPOS].usItem == NOTHING && LoadBearingEquipment[pItem->ubClassIndex].lbeClass == COMBAT_PACK)	// Combat pack
+				{
+					packCombo = LoadBearingEquipment[pItem->ubClassIndex].lbeCombo;
+					backCombo = LoadBearingEquipment[Item[pSoldier->inv[BPACKPOCKPOS].usItem].ubClassIndex].lbeCombo;
+					if((pSoldier->inv[BPACKPOCKPOS].usItem != NOTHING && packCombo != 0 && backCombo == packCombo) || pSoldier->inv[BPACKPOCKPOS].usItem == NOTHING)
+					{
+						MoveItemFromLBEItem( pSoldier, CPACKPOCKPOS, pObj);
+						PlaceObject( pSoldier, CPACKPOCKPOS, pObj );
+						SetNewItem( pSoldier, CPACKPOCKPOS, fNewItem );
+						if(pObj->ubNumberOfObjects == 0)
+							return( TRUE );
+					}
+				}
+				else if(pSoldier->inv[BPACKPOCKPOS].usItem == NOTHING && LoadBearingEquipment[pItem->ubClassIndex].lbeClass == BACKPACK)	// Backpack
+				{
+					if(pSoldier->inv[GUNSLINGPOCKPOS].usItem == NOTHING)
+					{
+						packCombo = LoadBearingEquipment[Item[pSoldier->inv[CPACKPOCKPOS].usItem].ubClassIndex].lbeCombo;
+						backCombo = LoadBearingEquipment[pItem->ubClassIndex].lbeCombo;
+						if((pSoldier->inv[CPACKPOCKPOS].usItem != NOTHING && backCombo != 0 && backCombo == packCombo) || pSoldier->inv[CPACKPOCKPOS].usItem == NOTHING)
+						{
+							MoveItemFromLBEItem( pSoldier, BPACKPOCKPOS, pObj);
+							PlaceObject( pSoldier, BPACKPOCKPOS, pObj );
+							SetNewItem( pSoldier, BPACKPOCKPOS, fNewItem );
+							pSoldier->DropPackFlag = FALSE;
+							pSoldier->ZipperFlag = FALSE;
+							RenderBackpackButtons(0);
+							if(pObj->ubNumberOfObjects == 0)
+								return( TRUE );
+						}
+					}
+				}
+			}
+			break;
 		default:
 			break;
 	}
@@ -4186,9 +4683,10 @@
 		// Madd
 		//bSlot = HANDPOS;
 		//while (1) 
-		for( bSlot = HANDPOS; bSlot <= BIGPOCK4POS; bSlot++)
+		// CHRISL
+		for( bSlot = HANDPOS; bSlot < BIGPOCKFINAL; bSlot++)
 		{	
-			bSlot = FindEmptySlotWithin( pSoldier, bSlot, BIGPOCK4POS );
+			bSlot = FindEmptySlotWithin( pSoldier, bSlot, (BIGPOCKFINAL-1) );
 			if (bSlot == ITEM_NOT_FOUND)
 			{
 				return( FALSE );
@@ -4222,14 +4720,17 @@
 			bSlot = HANDPOS;
 			while (1) 
 			{
-				bSlot = FindObjWithin( pSoldier, pObj->usItem, bSlot, SMALLPOCK8POS );
+				// CHRISL
+				bSlot = FindObjWithin( pSoldier, pObj->usItem, bSlot, (NUM_INV_SLOTS-1) );
 				if (bSlot == ITEM_NOT_FOUND)
 				{
 					break;
 				}
 				if ( bSlot != bExcludeSlot )
 				{
-					if ( ( (Item[ pObj->usItem ].usItemClass == IC_MONEY) && pSoldier->inv[ bSlot ].ItemData.Money.uiMoneyAmount < MoneySlotLimit( bSlot ) ) || (Item[ pObj->usItem ].usItemClass != IC_MONEY && pSoldier->inv[bSlot].ubNumberOfObjects < ItemSlotLimit( pObj->usItem, bSlot ) ) )
+					// CHRISL: Use new ItemSlotLimit function if we're using the new inventory system
+					UINT8 isLimit = (!gGameOptions.ubInventorySystem) ? ItemSlotLimit( pObj->usItem, bSlot ) : ItemSlotLimit( pObj, bSlot, pSoldier );
+					if ( ( (Item[ pObj->usItem ].usItemClass == IC_MONEY) && pSoldier->inv[ bSlot ].ItemData.Money.uiMoneyAmount < MoneySlotLimit( bSlot ) ) || (Item[ pObj->usItem ].usItemClass != IC_MONEY && pSoldier->inv[bSlot].ubNumberOfObjects < isLimit ) )
 					{
 						// NEW: If in SKI, don't auto-place anything into a stackable slot that's currently hatched out!  Such slots
 						// will disappear in their entirety if sold/moved, causing anything added through here to vanish also!
@@ -4248,10 +4749,11 @@
 			}
 		}
 		// Search for empty slots to dump into, starting with small pockets
-		bSlot = SMALLPOCK1POS;
+		bSlot = BIGPOCKFINAL;	/* CHRISL */
 		while( 1 )
 		{
-			bSlot = FindEmptySlotWithin( pSoldier, bSlot, SMALLPOCK8POS );
+			// CHRISL
+			bSlot = FindEmptySlotWithin( pSoldier, bSlot, (NUM_INV_SLOTS-1) );
 			if (bSlot == ITEM_NOT_FOUND)
 			{
 				break;
@@ -4268,7 +4770,8 @@
 		bSlot = HANDPOS;
 		while (1)		
 		{
-			bSlot = FindEmptySlotWithin( pSoldier, bSlot, BIGPOCK4POS );
+			// CHRISL
+			bSlot = FindEmptySlotWithin( pSoldier, bSlot, (BIGPOCKFINAL-1) );
 			if (bSlot == ITEM_NOT_FOUND)
 			{
 				break;
@@ -5217,7 +5720,8 @@
 		return( TRUE );
 	}
 
-	for (bLoop = BIGPOCK1POS; bLoop < SMALLPOCK8POS; bLoop++)
+	// CHRISL:
+	for (bLoop = BIGPOCK1POS; bLoop < NUM_INV_SLOTS; bLoop++)
 	{
 		if ( gMercProfiles[ ubProfile ].bInvNumber[ bLoop ] == 0 && (pSoldier == NULL || pSoldier->inv[ bLoop ].usItem == NOTHING ) )
 		{
@@ -6559,7 +7063,8 @@
 
 	//ADB and AXP 28.03.2007: CtH bug fix: We also want to check on a firing weapon, "raised" alone is not enough ;)
 	bool usingGunScope = WeaponReady(pSoldier);
-	for (int i = HELMETPOS; i < BIGPOCK1POS; i++)
+	// CHRISL:
+	for (int i = HELMETPOS; i < BODYPOSFINAL; i++)
 	{
 		// Okay, it's time for some optimization here too
 		pObj = &( pSoldier->inv[i]);
@@ -6616,7 +7121,8 @@
 
 	//ADB and AXP 28.03.2007: CtH bug fix: We also want to check on a firing weapon, "raised" alone is not enough ;)
 	bool usingGunScope = WeaponReady(pSoldier);
-	for (int i = HELMETPOS; i < BIGPOCK1POS; i++)
+	// CHRISL:
+	for (int i = HELMETPOS; i < BODYPOSFINAL; i++)
 	{
 		// More optimization
 		pObj = &( pSoldier->inv[i]);
@@ -6662,7 +7168,8 @@
 
 	//ADB and AXP 28.03.2007: CtH bug fix: We also want to check on a firing weapon, "raised" alone is not enough ;)
 	bool usingGunScope = WeaponReady(pSoldier);
-	for (int i = 0; i < BIGPOCK1POS; i++)
+	// CHRISL:
+	for (int i = 0; i < BODYPOSFINAL; i++)
 	{
 		// More optimization
 		pObj = &( pSoldier->inv[i]);
@@ -6711,7 +7218,8 @@
 
 	//ADB and AXP 28.03.2007: CtH bug fix: We also want to check on a firing weapon, "raised" alone is not enough ;)
 	bool usingGunScope = WeaponReady(pSoldier);
-	for (int i = 0; i < BIGPOCK1POS; i++)
+	// CHRISL:
+	for (int i = 0; i < BODYPOSFINAL; i++)
 	{
 		// More optimization
 		pObj = &( pSoldier->inv[i]);
@@ -6760,7 +7268,8 @@
 
 	//ADB and AXP 28.03.2007: CtH bug fix: We also want to check on a firing weapon, "raised" alone is not enough ;)
 	bool usingGunScope = WeaponReady(pSoldier);
-	for (int i = 0; i < BIGPOCK1POS; i++)
+	// CHRISL:
+	for (int i = 0; i < BODYPOSFINAL; i++)
 	{
 		// More optimization
 		pObj = &( pSoldier->inv[i]);
@@ -6833,7 +7342,8 @@
 	UINT16 usItem;
 	INVTYPE *pItem;
 
-	for (int i = HELMETPOS; i < BIGPOCK1POS; i++)
+	// CHRISL:
+	for (int i = HELMETPOS; i < BODYPOSFINAL; i++)
 	{
 		// Okay, it's time for some optimization here
 		usItem = pSoldier->inv[i].usItem;
@@ -7488,6 +7998,15 @@
 		if ( pSoldier->inv[bLoop].usItem > NONE )
 			ttl += GetCamoBonus(&pSoldier->inv[bLoop]);
 	}
+	// CHRISL: Add additional loop for LBE items while using new inventory system
+	if(gGameOptions.ubInventorySystem)
+	{
+		for (bLoop = VESTPOCKPOS; bLoop <= BPACKPOCKPOS; bLoop++)
+		{
+			if ( pSoldier->inv[bLoop].usItem > NONE )
+				ttl += GetCamoBonus(&pSoldier->inv[bLoop]);
+		}
+	}
 
 	return __min( ttl, 100 );
 }
@@ -7501,6 +8020,15 @@
 		if ( pSoldier->inv[bLoop].usItem > NONE )
 			ttl += GetUrbanCamoBonus(&pSoldier->inv[bLoop]);
 	}
+	// CHRISL: Add additional loop for LBE items while using new inventory system
+	if(gGameOptions.ubInventorySystem)
+	{
+		for (bLoop = VESTPOCKPOS; bLoop <= BPACKPOCKPOS; bLoop++)
+		{
+			if ( pSoldier->inv[bLoop].usItem > NONE )
+				ttl += GetUrbanCamoBonus(&pSoldier->inv[bLoop]);
+		}
+	}
 
 	return __min( ttl, 100 );
 }
@@ -7514,6 +8042,15 @@
 		if ( pSoldier->inv[bLoop].usItem > NONE )
 			ttl += GetDesertCamoBonus(&pSoldier->inv[bLoop]);
 	}
+	// CHRISL: Add additional loop for LBE items while using new inventory system
+	if(gGameOptions.ubInventorySystem)
+	{
+		for (bLoop = VESTPOCKPOS; bLoop <= BPACKPOCKPOS; bLoop++)
+		{
+			if ( pSoldier->inv[bLoop].usItem > NONE )
+				ttl += GetDesertCamoBonus(&pSoldier->inv[bLoop]);
+		}
+	}
 
 	return __min( ttl, 100 );
 }
@@ -7527,6 +8064,15 @@
 		if ( pSoldier->inv[bLoop].usItem > NONE )
 			ttl += GetSnowCamoBonus(&pSoldier->inv[bLoop]);
 	}
+	// CHRISL: Add additional loop for LBE items while using new inventory system
+	if(gGameOptions.ubInventorySystem)
+	{
+		for (bLoop = VESTPOCKPOS; bLoop <= BPACKPOCKPOS; bLoop++)
+		{
+			if ( pSoldier->inv[bLoop].usItem > NONE )
+				ttl += GetSnowCamoBonus(&pSoldier->inv[bLoop]);
+		}
+	}
 
 	return __min( ttl, 100 );
 }
@@ -7593,7 +8139,8 @@
 {
 	INT8	bLoop;
 
-	for (bLoop = HANDPOS; bLoop <= SMALLPOCK8POS; bLoop++)
+	// CHRISL:
+	for (bLoop = HANDPOS; bLoop < NUM_INV_SLOTS; bLoop++)
 	{
 		if (Item[pSoldier->inv[bLoop].usItem].brightlightvisionrangebonus > bonusToBeat && Item[pSoldier->inv[bLoop].usItem].usItemClass == IC_FACE )			
 		{
@@ -7607,7 +8154,8 @@
 {
 	INT8	bLoop;
 
-	for (bLoop = HANDPOS; bLoop <= SMALLPOCK8POS; bLoop++)
+	// CHRISL:
+	for (bLoop = HANDPOS; bLoop < NUM_INV_SLOTS; bLoop++)
 	{
 		if (Item[pSoldier->inv[bLoop].usItem].nightvisionrangebonus > bonusToBeat && Item[pSoldier->inv[bLoop].usItem].usItemClass == IC_FACE )			
 		{
Index: Tactical/Items.h
===================================================================
--- Tactical/Items.h	(revision 1299)
+++ Tactical/Items.h	(working copy)
@@ -46,8 +46,10 @@
 extern BOOLEAN AttachObject( SOLDIERTYPE * pSoldier, OBJECTTYPE * pTargetObj, OBJECTTYPE * pAttachment );
 extern BOOLEAN RemoveAttachment( OBJECTTYPE * pObj, INT8 bAttachPos, OBJECTTYPE * pNewObj );
 
-extern UINT8	CalculateObjectWeight( OBJECTTYPE *pObject );
+extern UINT16	CalculateObjectWeight( OBJECTTYPE *pObject );
 extern UINT32 CalculateCarriedWeight( SOLDIERTYPE * pSoldier );
+// CHRISL:
+extern UINT16 CalculateItemSize( OBJECTTYPE *pObject );
 
 extern UINT16 TotalPoints( OBJECTTYPE * pObj );
 extern UINT16 UseKitPoints( OBJECTTYPE * pObj, UINT16 usPoints, SOLDIERTYPE *pSoldier );
@@ -62,7 +64,9 @@
 extern BOOLEAN ReloadGun( SOLDIERTYPE * pSoldier, OBJECTTYPE * pGun, OBJECTTYPE * pAmmo );
 extern BOOLEAN UnloadGun( SOLDIERTYPE * pSoldier, OBJECTTYPE * pGun); 
 
-UINT8 ItemSlotLimit( UINT16 usItem, INT8 bSlot );
+UINT8 ItemSlotLimit( UINT16 usItem, INT16 bSlot );
+// CHRISL: Add new inventory version of ItemSlotLimit function
+extern UINT8 ItemSlotLimit( OBJECTTYPE * pObject, INT16 bSlot, SOLDIERTYPE *pSoldier );
 
 // Function to put an item in a soldier profile
 // It's very primitive, just finds an empty place!
@@ -309,3 +313,4 @@
 
 #endif
 
+
Index: Tactical/LOS.cpp
===================================================================
--- Tactical/LOS.cpp	(revision 1299)
+++ Tactical/LOS.cpp	(working copy)
@@ -1970,7 +1970,8 @@
 		// Place knife on guy....
 
 		// See if they have room ( and make sure it's not in hand pos?
-		bSlot = FindEmptySlotWithin( pTarget, BIGPOCK1POS, SMALLPOCK8POS );
+		// CHRISL:
+		bSlot = FindEmptySlotWithin( pTarget, BIGPOCK1POS, (NUM_INV_SLOTS-1) );
 		if (bSlot == NO_SLOT)
 		{
 			// Add item
Index: Tactical/Merc Hiring.cpp
===================================================================
--- Tactical/Merc Hiring.cpp	(revision 1299)
+++ Tactical/Merc Hiring.cpp	(working copy)
@@ -141,6 +141,12 @@
 			Object.ItemData.Generic.bStatus[0]				= 100;
 			// Give it 
 			fReturn = AutoPlaceObject( MercPtrs[iNewIndex], &Object, FALSE );
+			// CHRISL: This condition should resolve the issue of the letter not being issued to the first merc
+			if(!fReturn && gGameOptions.ubInventorySystem)
+			{
+				memcpy( &(MercPtrs[iNewIndex]->inv[NUM_INV_SLOTS-1]), &Object, sizeof( OBJECTTYPE ) );
+				fReturn=TRUE;
+			}
 			Assert( fReturn );
 		}
 
Index: Tactical/opplist.cpp
===================================================================
--- Tactical/opplist.cpp	(revision 1299)
+++ Tactical/opplist.cpp	(working copy)
@@ -1232,7 +1232,7 @@
 		sDistVisible += sDistVisible * GetTotalVisionRangeBonus(pSoldier, bLightLevel) / 100;
 	}
 
-	
+
 	// give one step better vision for people with nightops
 	if (HAS_SKILL_TRAIT( pSoldier, NIGHTOPS ))
 	{
@@ -4591,6 +4591,62 @@
 		ubLine++;
 
 		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"VESTPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[VESTPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[VESTPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[VESTPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"LTHIGHPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[LTHIGHPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[LTHIGHPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[LTHIGHPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"RTHIGHPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[RTHIGHPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[RTHIGHPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[RTHIGHPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"CPACKPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[CPACKPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[CPACKPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[CPACKPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"BPACKPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[BPACKPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[BPACKPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[BPACKPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"GUNSLINGPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[GUNSLINGPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[GUNSLINGPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[GUNSLINGPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"KNIFEPOCKPOS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[KNIFEPOCKPOS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[KNIFEPOCKPOS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[KNIFEPOCKPOS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
 		gprintf( 0, LINE_HEIGHT * ubLine, L"BIGPOCK1POS:");
 		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
 		if( pSoldier->inv[BIGPOCK1POS].usItem )
@@ -4622,7 +4678,64 @@
 		WriteQuantityAndAttachments( &pSoldier->inv[BIGPOCK4POS], LINE_HEIGHT*ubLine );
 		ubLine++;
 
+		// CHRISL: Added entries for all the new inventory pockets.
 		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"BIGPOCK5POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[BIGPOCK5POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[BIGPOCK5POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[BIGPOCK5POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"BIGPOCK6POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[BIGPOCK6POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[BIGPOCK6POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[BIGPOCK6POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"BIGPOCK7POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[BIGPOCK7POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[BIGPOCK7POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[BIGPOCK7POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"MEDPOCK1POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[MEDPOCK1POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[MEDPOCK1POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[MEDPOCK1POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"MEDPOCK2POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[MEDPOCK2POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[MEDPOCK2POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[MEDPOCK2POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"MEDPOCK3POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[MEDPOCK3POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[MEDPOCK3POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[MEDPOCK3POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"MEDPOCK4POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[MEDPOCK4POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[MEDPOCK4POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[MEDPOCK4POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
 		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK1POS:");
 		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
 		if( pSoldier->inv[SMALLPOCK1POS].usItem )
@@ -4678,6 +4791,7 @@
 		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK7POS], LINE_HEIGHT*ubLine );
 		ubLine++;
 
+		// CHRISL: Added entries for all the new inventory pockets
 		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
 		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK8POS:");
 		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
@@ -4685,6 +4799,182 @@
 			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK8POS].usItem] );
 		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK8POS], LINE_HEIGHT*ubLine );
 		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK9POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK9POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK9POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK9POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK10POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK10POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK10POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK10POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK11POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK11POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK11POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK11POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK12POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK12POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK12POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK12POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK13POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK13POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK13POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK13POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK14POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK14POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK14POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK14POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK15POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK15POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK15POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK15POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK16POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK16POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK16POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK16POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK17POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK17POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK17POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK17POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK18POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK18POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK18POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK18POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK19POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK19POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK19POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK19POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK20POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK20POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK20POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK20POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK21POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK21POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK21POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK21POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK22POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK22POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK22POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK22POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK23POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK23POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK23POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK23POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK24POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK24POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK24POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK24POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK25POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK25POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK25POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK25POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK26POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK26POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK26POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK26POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK27POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK27POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK27POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK27POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK28POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK28POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK28POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK28POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK29POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK29POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK29POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK29POS], LINE_HEIGHT*ubLine );
+		ubLine++;
+
+		SetFontShade(LARGEFONT1, FONT_SHADE_GREEN);
+		gprintf( 0, LINE_HEIGHT * ubLine, L"SMALLPOCK30POS:");
+		SetFontShade(LARGEFONT1, FONT_SHADE_NEUTRAL);
+		if( pSoldier->inv[SMALLPOCK30POS].usItem )
+			gprintf( 150, LINE_HEIGHT * ubLine, L"%s", ShortItemNames[pSoldier->inv[SMALLPOCK30POS].usItem] );
+		WriteQuantityAndAttachments( &pSoldier->inv[SMALLPOCK30POS], LINE_HEIGHT*ubLine );
+		ubLine++;
 	}
 	else
 	{
@@ -5695,7 +5985,7 @@
 			fMuzzleFlash = TRUE;
 		}
 	}
-
+	
     int sDistVisible = pSoldier->GetMaxDistanceVisible(sGridNo, bLevel, CALC_FROM_WANTED_DIR );
 
 	if ( fMuzzleFlash )
@@ -5703,7 +5993,7 @@
 		// turn flash on again
 		MercPtrs[ ubNoiseMaker ]->fMuzzleFlash = TRUE;
 	}
-
+		
 	if (PythSpacesAway(pSoldier->sGridNo,sGridNo) <= sDistVisible )
 	{
 		// just use the XXadjustedXX center of the gridno
Index: Tactical/Overhead Types.h
===================================================================
--- Tactical/Overhead Types.h	(revision 1299)
+++ Tactical/Overhead Types.h	(working copy)
@@ -82,6 +82,12 @@
 #define SWATCOST					0
 #define CRAWLCOST					1
 
+// CHRISL: AP Cost Movement modifiers when wearing a backpack
+#define RUNDIVISORBPACK				1.5
+#define WALKCOSTBPACK					0
+#define SWATCOSTBPACK					1
+#define CRAWLCOSTBPACK					2
+
 // defines
 // ######################################################
 #define MAX_PATH_LIST_SIZE		30
Index: Tactical/Overhead.cpp
===================================================================
--- Tactical/Overhead.cpp	(revision 1299)
+++ Tactical/Overhead.cpp	(working copy)
@@ -1877,9 +1877,18 @@
 	{
 		// We have been told to jump fence....
 
+		// CHRISL: Added penalty for jumping a fence while wearing a backpack
 		// Do we have APs?
-		sAPCost = AP_JUMPFENCE;
-		sBPCost = BP_JUMPFENCE;
+		if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NOTHING)
+		{
+			sAPCost = AP_JUMPFENCEBPACK;
+			sBPCost = BP_JUMPFENCEBPACK;
+		}
+		else
+		{
+			sAPCost = AP_JUMPFENCE;
+			sBPCost = BP_JUMPFENCE;
+		}
 
 		if ( EnoughPoints( pSoldier, sAPCost, sBPCost, FALSE )  )
 		{
Index: Tactical/PATHAI.cpp
===================================================================
--- Tactical/PATHAI.cpp	(revision 1299)
+++ Tactical/PATHAI.cpp	(working copy)
@@ -1439,7 +1439,12 @@
 					//case TRAVELCOST_DOOR		:	ubAPCost = AP_MOVEMENT_FLAT;
 					//													break;
 
-				case TRAVELCOST_FENCE		: ubAPCost = AP_JUMPFENCE;
+				// CHRISL:	
+				case TRAVELCOST_FENCE		: 
+					if(gGameOptions.ubInventorySystem && s->inv[BPACKPOCKPOS].usItem!=NOTHING)
+						ubAPCost = AP_JUMPFENCEBPACK;
+					else
+						ubAPCost = AP_JUMPFENCE;
 
 					/*
 					if ( sSwitchValue == TRAVELCOST_FENCE )
@@ -1503,24 +1508,37 @@
 				}
 
 				// adjust AP cost for movement mode
+		// CHRISL: Adjusted system to use different move costs while wearing a backpack
 				switch( usMovementModeToUseForAPs )
 				{
-				case RUNNING:	
-				case ADULTMONSTER_WALKING:	
-					// save on casting
-					ubAPCost = ubAPCost * 10 / ( (UINT8) (RUNDIVISOR * 10));
-					//ubAPCost = (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) );	break;
-					break;
-				case WALKING:
-				case ROBOT_WALK:
-					ubAPCost = (ubAPCost + WALKCOST);
-					break;
-				case SWATTING:
-					ubAPCost = (ubAPCost + SWATCOST);
-					break;
-				case CRAWLING:
-					ubAPCost = (ubAPCost + CRAWLCOST);
-					break;
+					case RUNNING:	
+					case ADULTMONSTER_WALKING:	
+						// save on casting
+						if(gGameOptions.ubInventorySystem && s->inv[BPACKPOCKPOS].usItem!=NONE)
+							ubAPCost = ubAPCost * 10 / ( (UINT8) (RUNDIVISORBPACK * 10));
+						else
+							ubAPCost = ubAPCost * 10 / ( (UINT8) (RUNDIVISOR * 10));
+						//ubAPCost = (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) );	break;
+						break;
+					case WALKING:
+					case ROBOT_WALK:
+						if(gGameOptions.ubInventorySystem && s->inv[BPACKPOCKPOS].usItem!=NONE)
+							ubAPCost = (ubAPCost + WALKCOSTBPACK);
+						else
+							ubAPCost = (ubAPCost + WALKCOST);
+						break;
+					case SWATTING:
+						if(gGameOptions.ubInventorySystem && s->inv[BPACKPOCKPOS].usItem!=NONE)
+							ubAPCost = (ubAPCost + SWATCOSTBPACK);
+						else
+							ubAPCost = (ubAPCost + SWATCOST);
+						break;
+					case CRAWLING:
+						if(gGameOptions.ubInventorySystem && s->inv[BPACKPOCKPOS].usItem!=NONE)
+							ubAPCost = (ubAPCost + CRAWLCOSTBPACK);
+						else
+						ubAPCost = (ubAPCost + CRAWLCOST);
+						break;
 				}
 
 				if (nextCost == TRAVELCOST_FENCE)
@@ -2436,14 +2454,40 @@
 					}
 
 					// so, then we must modify it for other movement styles and accumulate
-					switch( usMovementModeToUseForAPs )
-					{
-					case RUNNING:		sPoints += (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) ) + sExtraCostStand;	break;
-					case WALKING :	sPoints += (sTileCost + WALKCOST) + sExtraCostStand;		break;
-					case SWATTING:	sPoints += (sTileCost + SWATCOST) + sExtraCostSwat;		break;
-					case CRAWLING:	sPoints += (sTileCost + CRAWLCOST) + sExtraCostCrawl;		break;
-					default      :  sPoints += sTileCost;									break;
-					}
+				  // CHRISL: Force display path to calculate AP cost differently if we're wearing a backpack
+				  switch( usMovementModeToUseForAPs )
+				  {
+					  case RUNNING:
+						  if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+							  sPoints += (INT16)(DOUBLE)( (sTileCost / RUNDIVISORBPACK) ) + sExtraCostStand;
+						  else
+							  sPoints += (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) ) + sExtraCostStand;
+						  break;
+					  case WALKING :
+						  if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+							 sPoints += (sTileCost + WALKCOSTBPACK) + sExtraCostStand;
+						  else
+							  sPoints += (sTileCost + WALKCOST) + sExtraCostStand;
+						  break;
+					  case SWATTING:
+						  if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+							  sPoints += (sTileCost + SWATCOSTBPACK) + sExtraCostSwat;
+						  else
+							  sPoints += (sTileCost + SWATCOST) + sExtraCostSwat;
+						  break;
+					  case CRAWLING:
+						  if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+							  sPoints += (sTileCost + CRAWLCOSTBPACK) + sExtraCostCrawl;
+						  else
+							  sPoints += (sTileCost + CRAWLCOST) + sExtraCostCrawl;
+						  break;
+					  default      :
+						  if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+							  sPoints += sTileCost;
+						  else
+							  sPoints += sTileCost;
+						  break;
+				  }
 				}	 	
 			}
 
@@ -2453,17 +2497,30 @@
 			{
 				// ATE; TODO: Put stuff in here to allow for fact of costs other than movement ( jump fence, open door )
 
+				// CHRISL: Adjusted system to use different move costs while wearing a backpack
 				// store WALK cost
-				sPointsWalk += (sTileCost + WALKCOST) + sExtraCostStand;
-
+				if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPointsWalk += (sTileCost + WALKCOSTBPACK) + sExtraCostStand;
+				else
+					sPointsWalk += (sTileCost + WALKCOST) + sExtraCostStand;
+			
 				// now get cost as if CRAWLING
-				sPointsCrawl += (sTileCost + CRAWLCOST) + sExtraCostCrawl; 
+				if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPointsCrawl += (sTileCost + CRAWLCOSTBPACK) + sExtraCostCrawl; 
+				else
+					sPointsCrawl += (sTileCost + CRAWLCOST) + sExtraCostCrawl; 
 
 				// now get cost as if SWATTING
-				sPointsSwat += (sTileCost + SWATCOST) + sExtraCostSwat;
+				if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPointsSwat += (sTileCost + SWATCOSTBPACK) + sExtraCostSwat;
+				else
+					sPointsSwat += (sTileCost + SWATCOST) + sExtraCostSwat;
 
 				// now get cost as if RUNNING
-				sPointsRun += (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) ) + sExtraCostStand;
+				if(gGameOptions.ubInventorySystem && pSold->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPointsRun += (INT16)(DOUBLE)( (sTileCost / RUNDIVISORBPACK) ) + sExtraCostStand;
+				else
+					sPointsRun += (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) ) + sExtraCostStand;
 			}
 
 			if ( iCnt == 0 && bPlot )
Index: Tactical/Points.cpp
===================================================================
--- Tactical/Points.cpp	(revision 1299)
+++ Tactical/Points.cpp	(working copy)
@@ -119,7 +119,12 @@
 		break;
 
 		// cost for jumping a fence REPLACES all other AP costs!
-	case TRAVELCOST_FENCE		: return( AP_JUMPFENCE );
+	// CHRISL: 
+	case TRAVELCOST_FENCE		: 
+		 if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NOTHING)
+			 return( AP_JUMPFENCEBPACK );
+		 else
+			  return( AP_JUMPFENCE );
 
 	case TRAVELCOST_NONE			: return( 0 );
 
@@ -286,30 +291,52 @@
 	{
 		switch(usMovementMode)
 		{
-		case RUNNING:	
-		case ADULTMONSTER_WALKING:	
-		case BLOODCAT_RUN:
-			sPoints = (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) );	break;
+			case RUNNING:	
+			case ADULTMONSTER_WALKING:	
+			case BLOODCAT_RUN:
+				// CHRISL: Adjusted system to use different move costs while wearing a backpack
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (INT16)(DOUBLE)( (sTileCost / RUNDIVISORBPACK) );
+				else
+					sPoints = (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) );
+				break;
 
-		case CROW_FLY:
-		case SIDE_STEP:
-		case WALK_BACKWARDS:
-		case ROBOT_WALK:
-		case BLOODCAT_WALK_BACKWARDS:
-		case MONSTER_WALK_BACKWARDS:
-		case LARVAE_WALK:
-		case WALKING :	sPoints = (sTileCost + WALKCOST);		break;
+			case CROW_FLY:
+			case SIDE_STEP:
+			case WALK_BACKWARDS:
+			case ROBOT_WALK:
+			case BLOODCAT_WALK_BACKWARDS:
+			case MONSTER_WALK_BACKWARDS:
+      case LARVAE_WALK:
+			case WALKING :
+				// CHRISL: Adjusted system to use different move costs while wearing a backpack
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (sTileCost + WALKCOSTBPACK);
+				else
+					sPoints = (sTileCost + WALKCOST);
+				break;
 
-		case START_SWAT:
-		case SWAT_BACKWARDS:
-		case SWATTING:	sPoints = (sTileCost + SWATCOST);		break;
-		case CRAWLING:	sPoints = (sTileCost + CRAWLCOST);		break;
+			case START_SWAT:
+			case SWAT_BACKWARDS:
+				// CHRISL: Adjusted system to use different move costs while wearing a backpack
+			case SWATTING:
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (sTileCost + SWATCOSTBPACK);
+				else
+					sPoints = (sTileCost + SWATCOST);
+				break;
+			case CRAWLING:
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (sTileCost + CRAWLCOSTBPACK);
+				else
+					sPoints = (sTileCost + CRAWLCOST);
+				break;
 
-		default:
+			default:
 
-			// Invalid movement mode
-			DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("Invalid movement mode %d used in ActionPointCost", usMovementMode  ) );
-			sPoints = 1;
+				// Invalid movement mode
+				DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("Invalid movement mode %d used in ActionPointCost", usMovementMode  ) );
+				sPoints = 1;
 		}
 	}
 
@@ -349,30 +376,52 @@
 	{
 		switch(usMovementMode)
 		{
-		case RUNNING:	
-		case ADULTMONSTER_WALKING:	
-		case BLOODCAT_RUN:
-			sPoints = (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) );	break;
+			case RUNNING:	
+			case ADULTMONSTER_WALKING:	
+			case BLOODCAT_RUN:
+				// CHRISL: Adjusted system to use different move costs while wearing a backpack
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (INT16)(DOUBLE)( (sTileCost / RUNDIVISORBPACK) );
+				else
+					sPoints = (INT16)(DOUBLE)( (sTileCost / RUNDIVISOR) );
+				break;
 
-		case CROW_FLY:
-		case SIDE_STEP:
-		case ROBOT_WALK:
-		case WALK_BACKWARDS:
-		case BLOODCAT_WALK_BACKWARDS:
-		case MONSTER_WALK_BACKWARDS:
-		case LARVAE_WALK:
-		case WALKING :	sPoints = (sTileCost + WALKCOST);		break;
+			case CROW_FLY:
+			case SIDE_STEP:
+			case ROBOT_WALK:
+			case WALK_BACKWARDS:
+			case BLOODCAT_WALK_BACKWARDS:
+			case MONSTER_WALK_BACKWARDS:
+			case LARVAE_WALK:
+			// CHRISL: Adjusted system to use different move costs while wearing a backpack
+			case WALKING :
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (sTileCost + WALKCOSTBPACK);
+				else
+					sPoints = (sTileCost + WALKCOST);
+				break;
 
-		case START_SWAT:
-		case SWAT_BACKWARDS:
-		case SWATTING:	sPoints = (sTileCost + SWATCOST);		break;
-		case CRAWLING:	sPoints = (sTileCost + CRAWLCOST);		break;
+			case START_SWAT:
+			case SWAT_BACKWARDS:
+			// CHRISL: Adjusted system to use different move costs while wearing a backpack
+			case SWATTING:
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (sTileCost + SWATCOSTBPACK);
+				else
+					sPoints = (sTileCost + SWATCOST);
+				break;
+			case CRAWLING:
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+					sPoints = (sTileCost + CRAWLCOSTBPACK);
+				else
+					sPoints = (sTileCost + CRAWLCOST);
+				break;
 
-		default:
+			default:
 
-			// Invalid movement mode
-			DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("Invalid movement mode %d used in ActionPointCost", usMovementMode  ) );
-			sPoints = 1;
+				// Invalid movement mode
+				DebugMsg( TOPIC_JA2, DBG_LEVEL_3, String("Invalid movement mode %d used in ActionPointCost", usMovementMode  ) );
+				sPoints = 1;
 		}
 	}
 
@@ -888,7 +937,7 @@
 	// Lalien: only for soldiers that are in loaded sector, 
 	if ( gfWorldLoaded &&  pSoldier->bInSector)
 	{
-		if( sBreathPerAP < 0 && ( pSoldier->bLevel  || !FindStructure( pSoldier->sGridNo, STRUCTURE_ROOF )  )  && pSoldier->bBreath > 1)
+		if( sBreathPerAP < 0 && ( pSoldier->bLevel  ||!FindStructure( pSoldier->sGridNo, STRUCTURE_ROOF )  )  && pSoldier->bBreath > 1)
 		{
 			sBreathPerAP -= (INT16)( sBreathPerAP * gbCurrentRainIntensity * gGameExternalOptions.ubBreathGainReductionPerRainIntensity  / 100 );	
 		}
Index: Tactical/Points.h
===================================================================
--- Tactical/Points.h	(revision 1299)
+++ Tactical/Points.h	(working copy)
@@ -109,6 +109,7 @@
 #define	AP_CLIMBROOF						10			// APs to climb roof
 #define	AP_CLIMBOFFROOF					6				// APs to climb off roof
 #define AP_JUMPFENCE						6				// time to jump over a fence
+#define AP_JUMPFENCEBPACK						10				// time to jump over a fence
 
 
 #define AP_OPEN_SAFE            8       // time to use combination
@@ -190,6 +191,7 @@
 #define	BP_CLIMBROOF						500			// BPs to climb roof
 #define	BP_CLIMBOFFROOF					250			// BPs to climb off roof
 #define	BP_JUMPFENCE						200			// BPs to jump fence
+#define	BP_JUMPFENCEBPACK						500			// BPs to jump fence
 
 
 /*
Index: Tactical/ShopKeeper Interface.cpp
===================================================================
--- Tactical/ShopKeeper Interface.cpp	(revision 1299)
+++ Tactical/ShopKeeper Interface.cpp	(working copy)
@@ -1328,7 +1328,8 @@
 	}
 
 	RenderClock( CLOCK_X, CLOCK_Y );
-	RenderTownIDString( );
+	// CHRISL: Added X,Y parameters to allow control of TownID string placement.
+	RenderTownIDString( CLOCK_X, (CLOCK_Y - 29) );
 
 //ATM:
 //	RenderSkiAtmPanel();
@@ -1474,7 +1475,8 @@
 
 	//Render the clock and the town name
 	RenderClock( CLOCK_X, CLOCK_Y );
-	RenderTownIDString( );
+	// CHRISL: Added X,Y parameters to allow control of TownID string placement.
+	RenderTownIDString( CLOCK_X, (CLOCK_Y - 29) );
 
 //	RenderTacticalInterface( );
 //	RenderSMPanel( &fDirty );
@@ -2758,6 +2760,14 @@
 		DrawTextToScreen( zTemp, (UINT16)(usPosX+SKI_ATTACHMENT_SYMBOL_X_OFFSET), (UINT16)(usPosY+SKI_ATTACHMENT_SYMBOL_Y_OFFSET), 0, TINYFONT1, FONT_GREEN, FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );	
 	}
 
+	// CHRISL: if item is LBENODE
+	if( gGameOptions.ubInventorySystem && pItemObject->ItemData.Trigger.bDetonatorType == ITEM_NOT_FOUND)
+	{
+		//Display the '*' in the bottom right corner of the square
+		swprintf( zTemp, L"*" );
+		DrawTextToScreen( zTemp, (UINT16)(usPosX+SKI_ATTACHMENT_SYMBOL_X_OFFSET), (UINT16)(usPosY+SKI_ATTACHMENT_SYMBOL_Y_OFFSET), 0, TINYFONT1, FONT_BLUE, FONT_MCOLOR_BLACK, FALSE, LEFT_JUSTIFIED );	
+	}
+
 	// Display 'JAMMED' if it's jammed
 	if ( pItemObject->ItemData.Gun.bGunAmmoStatus < 0 )
 	{
@@ -3068,8 +3078,9 @@
 		1,0,1,0,1,0,1,0,
 		0,1,0,1,0,1,0,1
 	};
-	ClipRect.iLeft = usPosX;
-	ClipRect.iRight = usPosX + usWidth;
+	// CHRISL:
+	ClipRect.iLeft = usPosX-1;
+	ClipRect.iRight = usPosX + usWidth-1;
 	ClipRect.iTop = usPosY;
 	ClipRect.iBottom = usPosY + usHeight;
 
Index: Tactical/Soldier Control.cpp
===================================================================
--- Tactical/Soldier Control.cpp	(revision 1299)
+++ Tactical/Soldier Control.cpp	(working copy)
@@ -360,7 +360,7 @@
 	// The following are based on the "old" SOLDIERTYPE struct
 	// Remove these later
 	Assert(SIZEOF_SOLDIERTYPE_POD == 2344);
-	Assert(offsetof( SOLDIERTYPE, bFiller ) == 2305);
+	Assert(offsetof( SOLDIERTYPE, bFiller ) == 2310); /* CHRISL: */
 }
 
 // Copy Constructor
@@ -395,6 +395,7 @@
 //  Note that the constructor does this automatically.
 void SOLDIERTYPE::initialize() {
 	memset( this, 0, SIZEOF_SOLDIERTYPE_POD);
+	DropPackKey=-1;	/* CHRISL */
 	inv.initialize();
 	for (int idx=0; idx < (int)inv.size(); ++idx) {
 		bNewItemCount[idx] = 0;
@@ -434,45 +435,46 @@
 	inv[SMALLPOCK7POS] = DO_NOT_USE_Inv[OldInventory::SMALLPOCK7POS];
 	inv[SMALLPOCK8POS] = DO_NOT_USE_Inv[OldInventory::SMALLPOCK8POS];
 
-	bNewItemCount[OldInventory::HELMETPOS] = DO_NOT_USE_bNewItemCount[HELMETPOS];
-	bNewItemCount[OldInventory::VESTPOS] = DO_NOT_USE_bNewItemCount[VESTPOS];
-	bNewItemCount[OldInventory::LEGPOS] = DO_NOT_USE_bNewItemCount[LEGPOS];
-	bNewItemCount[OldInventory::HEAD1POS] = DO_NOT_USE_bNewItemCount[HEAD1POS];
-	bNewItemCount[OldInventory::HEAD2POS] = DO_NOT_USE_bNewItemCount[HEAD2POS];
-	bNewItemCount[OldInventory::HANDPOS] = DO_NOT_USE_bNewItemCount[HANDPOS];
-	bNewItemCount[OldInventory::SECONDHANDPOS] = DO_NOT_USE_bNewItemCount[SECONDHANDPOS];
-	bNewItemCount[OldInventory::BIGPOCK1POS] = DO_NOT_USE_bNewItemCount[BIGPOCK1POS];
-	bNewItemCount[OldInventory::BIGPOCK2POS] = DO_NOT_USE_bNewItemCount[BIGPOCK2POS];
-	bNewItemCount[OldInventory::BIGPOCK3POS] = DO_NOT_USE_bNewItemCount[BIGPOCK3POS];
-	bNewItemCount[OldInventory::BIGPOCK4POS] = DO_NOT_USE_bNewItemCount[BIGPOCK4POS];
-	bNewItemCount[OldInventory::SMALLPOCK1POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK1POS];
-	bNewItemCount[OldInventory::SMALLPOCK2POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK2POS];
-	bNewItemCount[OldInventory::SMALLPOCK3POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK3POS];
-	bNewItemCount[OldInventory::SMALLPOCK4POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK4POS];
-	bNewItemCount[OldInventory::SMALLPOCK5POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK5POS];
-	bNewItemCount[OldInventory::SMALLPOCK6POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK6POS];
-	bNewItemCount[OldInventory::SMALLPOCK7POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK7POS];
-	bNewItemCount[OldInventory::SMALLPOCK8POS] = DO_NOT_USE_bNewItemCount[SMALLPOCK8POS];
+	// CHRISL:
+	bNewItemCount[HELMETPOS] = DO_NOT_USE_bNewItemCount[OldInventory::HELMETPOS];
+	bNewItemCount[VESTPOS] = DO_NOT_USE_bNewItemCount[OldInventory::VESTPOS];
+	bNewItemCount[LEGPOS] = DO_NOT_USE_bNewItemCount[OldInventory::LEGPOS];
+	bNewItemCount[HEAD1POS] = DO_NOT_USE_bNewItemCount[OldInventory::HEAD1POS];
+	bNewItemCount[HEAD2POS] = DO_NOT_USE_bNewItemCount[OldInventory::HEAD2POS];
+	bNewItemCount[HANDPOS] = DO_NOT_USE_bNewItemCount[OldInventory::HANDPOS];
+	bNewItemCount[SECONDHANDPOS] = DO_NOT_USE_bNewItemCount[OldInventory::SECONDHANDPOS];
+	bNewItemCount[BIGPOCK1POS] = DO_NOT_USE_bNewItemCount[OldInventory::BIGPOCK1POS];
+	bNewItemCount[BIGPOCK2POS] = DO_NOT_USE_bNewItemCount[OldInventory::BIGPOCK2POS];
+	bNewItemCount[BIGPOCK3POS] = DO_NOT_USE_bNewItemCount[OldInventory::BIGPOCK3POS];
+	bNewItemCount[BIGPOCK4POS] = DO_NOT_USE_bNewItemCount[OldInventory::BIGPOCK4POS];
+	bNewItemCount[SMALLPOCK1POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK1POS];
+	bNewItemCount[SMALLPOCK2POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK2POS];
+	bNewItemCount[SMALLPOCK3POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK3POS];
+	bNewItemCount[SMALLPOCK4POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK4POS];
+	bNewItemCount[SMALLPOCK5POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK5POS];
+	bNewItemCount[SMALLPOCK6POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK6POS];
+	bNewItemCount[SMALLPOCK7POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK7POS];
+	bNewItemCount[SMALLPOCK8POS] = DO_NOT_USE_bNewItemCount[OldInventory::SMALLPOCK8POS];
 
-	bNewItemCycleCount[OldInventory::HELMETPOS] = DO_NOT_USE_bNewItemCycleCount[HELMETPOS];
-	bNewItemCycleCount[OldInventory::VESTPOS] = DO_NOT_USE_bNewItemCycleCount[VESTPOS];
-	bNewItemCycleCount[OldInventory::LEGPOS] = DO_NOT_USE_bNewItemCycleCount[LEGPOS];
-	bNewItemCycleCount[OldInventory::HEAD1POS] = DO_NOT_USE_bNewItemCycleCount[HEAD1POS];
-	bNewItemCycleCount[OldInventory::HEAD2POS] = DO_NOT_USE_bNewItemCycleCount[HEAD2POS];
-	bNewItemCycleCount[OldInventory::HANDPOS] = DO_NOT_USE_bNewItemCycleCount[HANDPOS];
-	bNewItemCycleCount[OldInventory::SECONDHANDPOS] = DO_NOT_USE_bNewItemCycleCount[SECONDHANDPOS];
-	bNewItemCycleCount[OldInventory::BIGPOCK1POS] = DO_NOT_USE_bNewItemCycleCount[BIGPOCK1POS];
-	bNewItemCycleCount[OldInventory::BIGPOCK2POS] = DO_NOT_USE_bNewItemCycleCount[BIGPOCK2POS];
-	bNewItemCycleCount[OldInventory::BIGPOCK3POS] = DO_NOT_USE_bNewItemCycleCount[BIGPOCK3POS];
-	bNewItemCycleCount[OldInventory::BIGPOCK4POS] = DO_NOT_USE_bNewItemCycleCount[BIGPOCK4POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK1POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK1POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK2POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK2POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK3POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK3POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK4POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK4POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK5POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK5POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK6POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK6POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK7POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK7POS];
-	bNewItemCycleCount[OldInventory::SMALLPOCK8POS] = DO_NOT_USE_bNewItemCycleCount[SMALLPOCK8POS];
+	bNewItemCycleCount[HELMETPOS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::HELMETPOS];
+	bNewItemCycleCount[VESTPOS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::VESTPOS];
+	bNewItemCycleCount[LEGPOS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::LEGPOS];
+	bNewItemCycleCount[HEAD1POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::HEAD1POS];
+	bNewItemCycleCount[HEAD2POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::HEAD2POS];
+	bNewItemCycleCount[HANDPOS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::HANDPOS];
+	bNewItemCycleCount[SECONDHANDPOS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SECONDHANDPOS];
+	bNewItemCycleCount[BIGPOCK1POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::BIGPOCK1POS];
+	bNewItemCycleCount[BIGPOCK2POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::BIGPOCK2POS];
+	bNewItemCycleCount[BIGPOCK3POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::BIGPOCK3POS];
+	bNewItemCycleCount[BIGPOCK4POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::BIGPOCK4POS];
+	bNewItemCycleCount[SMALLPOCK1POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK1POS];
+	bNewItemCycleCount[SMALLPOCK2POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK2POS];
+	bNewItemCycleCount[SMALLPOCK3POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK3POS];
+	bNewItemCycleCount[SMALLPOCK4POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK4POS];
+	bNewItemCycleCount[SMALLPOCK5POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK5POS];
+	bNewItemCycleCount[SMALLPOCK6POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK6POS];
+	bNewItemCycleCount[SMALLPOCK7POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK7POS];
+	bNewItemCycleCount[SMALLPOCK8POS] = DO_NOT_USE_bNewItemCycleCount[OldInventory::SMALLPOCK8POS];
 }
 void SOLDIERTYPE::CopyNewInventoryToOld() {
 	// Do not use a loop in case the new inventory slots are arranged differently than the old
@@ -650,45 +652,46 @@
 	inv[SMALLPOCK7POS] = DO_NOT_USE_inv[OldInventory::SMALLPOCK7POS];
 	inv[SMALLPOCK8POS] = DO_NOT_USE_inv[OldInventory::SMALLPOCK8POS];
 
-	bInvStatus[OldInventory::HELMETPOS] = DO_NOT_USE_bInvStatus[HELMETPOS];
-	bInvStatus[OldInventory::VESTPOS] = DO_NOT_USE_bInvStatus[VESTPOS];
-	bInvStatus[OldInventory::LEGPOS] = DO_NOT_USE_bInvStatus[LEGPOS];
-	bInvStatus[OldInventory::HEAD1POS] = DO_NOT_USE_bInvStatus[HEAD1POS];
-	bInvStatus[OldInventory::HEAD2POS] = DO_NOT_USE_bInvStatus[HEAD2POS];
-	bInvStatus[OldInventory::HANDPOS] = DO_NOT_USE_bInvStatus[HANDPOS];
-	bInvStatus[OldInventory::SECONDHANDPOS] = DO_NOT_USE_bInvStatus[SECONDHANDPOS];
-	bInvStatus[OldInventory::BIGPOCK1POS] = DO_NOT_USE_bInvStatus[BIGPOCK1POS];
-	bInvStatus[OldInventory::BIGPOCK2POS] = DO_NOT_USE_bInvStatus[BIGPOCK2POS];
-	bInvStatus[OldInventory::BIGPOCK3POS] = DO_NOT_USE_bInvStatus[BIGPOCK3POS];
-	bInvStatus[OldInventory::BIGPOCK4POS] = DO_NOT_USE_bInvStatus[BIGPOCK4POS];
-	bInvStatus[OldInventory::SMALLPOCK1POS] = DO_NOT_USE_bInvStatus[SMALLPOCK1POS];
-	bInvStatus[OldInventory::SMALLPOCK2POS] = DO_NOT_USE_bInvStatus[SMALLPOCK2POS];
-	bInvStatus[OldInventory::SMALLPOCK3POS] = DO_NOT_USE_bInvStatus[SMALLPOCK3POS];
-	bInvStatus[OldInventory::SMALLPOCK4POS] = DO_NOT_USE_bInvStatus[SMALLPOCK4POS];
-	bInvStatus[OldInventory::SMALLPOCK5POS] = DO_NOT_USE_bInvStatus[SMALLPOCK5POS];
-	bInvStatus[OldInventory::SMALLPOCK6POS] = DO_NOT_USE_bInvStatus[SMALLPOCK6POS];
-	bInvStatus[OldInventory::SMALLPOCK7POS] = DO_NOT_USE_bInvStatus[SMALLPOCK7POS];
-	bInvStatus[OldInventory::SMALLPOCK8POS] = DO_NOT_USE_bInvStatus[SMALLPOCK8POS];
+	// CHRISL:
+	bInvStatus[HELMETPOS] = DO_NOT_USE_bInvStatus[OldInventory::HELMETPOS];
+	bInvStatus[VESTPOS] = DO_NOT_USE_bInvStatus[OldInventory::VESTPOS];
+	bInvStatus[LEGPOS] = DO_NOT_USE_bInvStatus[OldInventory::LEGPOS];
+	bInvStatus[HEAD1POS] = DO_NOT_USE_bInvStatus[OldInventory::HEAD1POS];
+	bInvStatus[HEAD2POS] = DO_NOT_USE_bInvStatus[OldInventory::HEAD2POS];
+	bInvStatus[HANDPOS] = DO_NOT_USE_bInvStatus[OldInventory::HANDPOS];
+	bInvStatus[SECONDHANDPOS] = DO_NOT_USE_bInvStatus[OldInventory::SECONDHANDPOS];
+	bInvStatus[BIGPOCK1POS] = DO_NOT_USE_bInvStatus[OldInventory::BIGPOCK1POS];
+	bInvStatus[BIGPOCK2POS] = DO_NOT_USE_bInvStatus[OldInventory::BIGPOCK2POS];
+	bInvStatus[BIGPOCK3POS] = DO_NOT_USE_bInvStatus[OldInventory::BIGPOCK3POS];
+	bInvStatus[BIGPOCK4POS] = DO_NOT_USE_bInvStatus[OldInventory::BIGPOCK4POS];
+	bInvStatus[SMALLPOCK1POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK1POS];
+	bInvStatus[SMALLPOCK2POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK2POS];
+	bInvStatus[SMALLPOCK3POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK3POS];
+	bInvStatus[SMALLPOCK4POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK4POS];
+	bInvStatus[SMALLPOCK5POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK5POS];
+	bInvStatus[SMALLPOCK6POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK6POS];
+	bInvStatus[SMALLPOCK7POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK7POS];
+	bInvStatus[SMALLPOCK8POS] = DO_NOT_USE_bInvStatus[OldInventory::SMALLPOCK8POS];
 
-	bInvNumber[OldInventory::HELMETPOS] = DO_NOT_USE_bInvNumber[HELMETPOS];
-	bInvNumber[OldInventory::VESTPOS] = DO_NOT_USE_bInvNumber[VESTPOS];
-	bInvNumber[OldInventory::LEGPOS] = DO_NOT_USE_bInvNumber[LEGPOS];
-	bInvNumber[OldInventory::HEAD1POS] = DO_NOT_USE_bInvNumber[HEAD1POS];
-	bInvNumber[OldInventory::HEAD2POS] = DO_NOT_USE_bInvNumber[HEAD2POS];
-	bInvNumber[OldInventory::HANDPOS] = DO_NOT_USE_bInvNumber[HANDPOS];
-	bInvNumber[OldInventory::SECONDHANDPOS] = DO_NOT_USE_bInvNumber[SECONDHANDPOS];
-	bInvNumber[OldInventory::BIGPOCK1POS] = DO_NOT_USE_bInvNumber[BIGPOCK1POS];
-	bInvNumber[OldInventory::BIGPOCK2POS] = DO_NOT_USE_bInvNumber[BIGPOCK2POS];
-	bInvNumber[OldInventory::BIGPOCK3POS] = DO_NOT_USE_bInvNumber[BIGPOCK3POS];
-	bInvNumber[OldInventory::BIGPOCK4POS] = DO_NOT_USE_bInvNumber[BIGPOCK4POS];
-	bInvNumber[OldInventory::SMALLPOCK1POS] = DO_NOT_USE_bInvNumber[SMALLPOCK1POS];
-	bInvNumber[OldInventory::SMALLPOCK2POS] = DO_NOT_USE_bInvNumber[SMALLPOCK2POS];
-	bInvNumber[OldInventory::SMALLPOCK3POS] = DO_NOT_USE_bInvNumber[SMALLPOCK3POS];
-	bInvNumber[OldInventory::SMALLPOCK4POS] = DO_NOT_USE_bInvNumber[SMALLPOCK4POS];
-	bInvNumber[OldInventory::SMALLPOCK5POS] = DO_NOT_USE_bInvNumber[SMALLPOCK5POS];
-	bInvNumber[OldInventory::SMALLPOCK6POS] = DO_NOT_USE_bInvNumber[SMALLPOCK6POS];
-	bInvNumber[OldInventory::SMALLPOCK7POS] = DO_NOT_USE_bInvNumber[SMALLPOCK7POS];
-	bInvNumber[OldInventory::SMALLPOCK8POS] = DO_NOT_USE_bInvNumber[SMALLPOCK8POS];
+	bInvNumber[HELMETPOS] = DO_NOT_USE_bInvNumber[OldInventory::HELMETPOS];
+	bInvNumber[VESTPOS] = DO_NOT_USE_bInvNumber[OldInventory::VESTPOS];
+	bInvNumber[LEGPOS] = DO_NOT_USE_bInvNumber[OldInventory::LEGPOS];
+	bInvNumber[HEAD1POS] = DO_NOT_USE_bInvNumber[OldInventory::HEAD1POS];
+	bInvNumber[HEAD2POS] = DO_NOT_USE_bInvNumber[OldInventory::HEAD2POS];
+	bInvNumber[HANDPOS] = DO_NOT_USE_bInvNumber[OldInventory::HANDPOS];
+	bInvNumber[SECONDHANDPOS] = DO_NOT_USE_bInvNumber[OldInventory::SECONDHANDPOS];
+	bInvNumber[BIGPOCK1POS] = DO_NOT_USE_bInvNumber[OldInventory::BIGPOCK1POS];
+	bInvNumber[BIGPOCK2POS] = DO_NOT_USE_bInvNumber[OldInventory::BIGPOCK2POS];
+	bInvNumber[BIGPOCK3POS] = DO_NOT_USE_bInvNumber[OldInventory::BIGPOCK3POS];
+	bInvNumber[BIGPOCK4POS] = DO_NOT_USE_bInvNumber[OldInventory::BIGPOCK4POS];
+	bInvNumber[SMALLPOCK1POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK1POS];
+	bInvNumber[SMALLPOCK2POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK2POS];
+	bInvNumber[SMALLPOCK3POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK3POS];
+	bInvNumber[SMALLPOCK4POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK4POS];
+	bInvNumber[SMALLPOCK5POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK5POS];
+	bInvNumber[SMALLPOCK6POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK6POS];
+	bInvNumber[SMALLPOCK7POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK7POS];
+	bInvNumber[SMALLPOCK8POS] = DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK8POS];
 }
 void MERCPROFILESTRUCT::CopyNewInventoryToOld() {
 	// Do not use a loop in case the new inventory slots are arranged differently than the old
@@ -753,7 +756,113 @@
 	DO_NOT_USE_bInvNumber[OldInventory::SMALLPOCK8POS] = bInvNumber[SMALLPOCK8POS];
 }
 
+// CHRISL:
+MERCPROFILEGEAR::MERCPROFILEGEAR() {
+	invCnt = 19;
+	lbeCnt = 5;
+	inv.reserve(invCnt);
+	iStatus.reserve(invCnt);
+	iDrop.reserve(invCnt);
+	iNumber.reserve(invCnt);
+	lbe.reserve(lbeCnt);
+	lStatus.reserve(lbeCnt);
+	for (int idx=0; idx < invCnt; ++idx) {
+		inv.push_back(0);
+		iStatus.push_back(0);
+		iDrop.push_back(0);
+		iNumber.push_back(0);
+	}
+	for (int idx=0; idx < lbeCnt; ++idx) {
+		lbe.push_back(0);
+		lStatus.push_back(0);
+	}
+	initialize();
 
+	Assert(inv.size() == invCnt);
+	Assert(iStatus.size() == invCnt);
+	Assert(iDrop.size() == invCnt);
+	Assert(iNumber.size() == invCnt);
+	Assert(lbe.size() == lbeCnt);
+	Assert(lStatus.size() == lbeCnt);
+}
+
+// Copy Constructor
+MERCPROFILEGEAR::MERCPROFILEGEAR(const MERCPROFILEGEAR& src) {
+	memcpy(this, &src, SIZEOF_MERCPROFILEGEAR_POD);
+	inv = src.inv;
+	iStatus = src.iStatus;
+	iDrop = src.iDrop;
+	iNumber = src.iNumber;
+	lbe = src.lbe;
+	lStatus = src.lStatus;
+
+	Assert(inv.size() == invCnt);
+	Assert(iStatus.size() == invCnt);
+	Assert(iDrop.size() == invCnt);
+	Assert(iNumber.size() == invCnt);
+	Assert(lbe.size() == lbeCnt);
+	Assert(lStatus.size() == lbeCnt);
+}
+
+// Assignment operator
+MERCPROFILEGEAR& MERCPROFILEGEAR::operator=(const MERCPROFILEGEAR& src) {
+    if (this != &src) {
+		memcpy(this, &src, SIZEOF_MERCPROFILEGEAR_POD);
+		inv = src.inv;
+		iStatus = src.iStatus;
+		iDrop = src.iDrop;
+		iNumber = src.iNumber;
+		lbe = src.lbe;
+		lStatus = src.lStatus;
+		invCnt = src.invCnt;
+		lbeCnt = src.lbeCnt;
+    }
+	Assert(inv.size() == invCnt);
+	Assert(iStatus.size() == invCnt);
+	Assert(iDrop.size() == invCnt);
+	Assert(iNumber.size() == invCnt);
+	Assert(lbe.size() == lbeCnt);
+	Assert(lStatus.size() == lbeCnt);
+	return *this;
+}
+
+// Destructor
+MERCPROFILEGEAR::~MERCPROFILEGEAR() {
+}
+
+// Initialize the soldier.  
+//  Use this instead of the old method of calling memset!
+//  Note that the constructor does this automatically.
+void MERCPROFILEGEAR::initialize() {
+	memset( this, 0, SIZEOF_MERCPROFILEGEAR_POD);
+	clearInventory();
+	Assert(inv.size() == invCnt);
+	Assert(iStatus.size() == invCnt);
+	Assert(iDrop.size() == invCnt);
+	Assert(iNumber.size() == invCnt);
+	Assert(lbe.size() == lbeCnt);
+	Assert(lStatus.size() == lbeCnt);
+}
+
+void MERCPROFILEGEAR::clearInventory() {
+	for (int idx=0; idx < (int)inv.size(); ++idx) {
+		inv[idx] = 0;
+		iStatus[idx] = 0;
+		iDrop[idx] = 0;
+		iNumber[idx] = 0;
+	}
+	for (int idx=0; idx < (int)lbe.size(); ++idx) {
+		lbe[idx] = 0;
+		lStatus[idx] = 0;
+	}
+	Assert(inv.size() == invCnt);
+	Assert(iStatus.size() == invCnt);
+	Assert(iDrop.size() == invCnt);
+	Assert(iNumber.size() == invCnt);
+	Assert(lbe.size() == lbeCnt);
+	Assert(lStatus.size() == lbeCnt);
+}
+
 BOOLEAN IsValidSecondHandShot( SOLDIERTYPE *pSoldier );
 
 UINT8					*gubpNumReplacementsPerRange;
@@ -2489,7 +2598,14 @@
 			// Only if our previous is not running
 			if ( pSoldier->usAnimState != RUNNING )
 			{
-				sAPCost = AP_START_RUN_COST;
+				// CHRISL: Make changes so that we charge extra APs while wearing a backpack while using new inventory system
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NOTHING)
+				{
+					sAPCost = AP_START_RUN_COST + 2;
+					sBPCost += 2;
+				}
+				else
+					sAPCost = AP_START_RUN_COST;
 				DeductPoints( pSoldier, sAPCost, sBPCost );
 			}
 			// Set pending action count to 0
@@ -2512,7 +2628,31 @@
 
 			if ( !pSoldier->fDontChargeAPsForStanceChange )
 			{
-				DeductPoints( pSoldier, AP_CROUCH, BP_CROUCH );
+				// CHRISL: Make changes so that we charge extra APs while wearing a backpack while using new inventory system
+				if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NOTHING && !pSoldier->ZipperFlag)
+				{
+					if(usNewState == KNEEL_UP)
+					{
+						sAPCost=AP_CROUCH+2;
+						sBPCost=BP_CROUCH+2;
+					}
+					else if(usNewState == KNEEL_DOWN)
+					{
+						sAPCost=AP_CROUCH+1;
+						sBPCost=BP_CROUCH+1;
+					}
+					else
+					{
+						sAPCost=AP_CROUCH;
+						sBPCost=BP_CROUCH;
+					}
+				}
+				else
+				{
+					sAPCost=AP_CROUCH;
+					sBPCost=BP_CROUCH;
+				}
+				DeductPoints( pSoldier, sAPCost, sBPCost );
 			}
 			pSoldier->fDontChargeAPsForStanceChange = FALSE;
 			break;
@@ -2526,7 +2666,26 @@
 				// ATE: Don't do this if we are still 'moving'....
 				if ( pSoldier->sGridNo == pSoldier->sFinalDestination || pSoldier->usPathIndex == 0 )
 				{
-					DeductPoints( pSoldier, AP_PRONE, BP_PRONE );
+					// CHRISL: Make changes so that we charge extra APs while wearing a backpack while using new inventory system
+					if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NOTHING && !pSoldier->ZipperFlag)
+					{
+						if(usNewState == PRONE_UP)
+						{
+						sAPCost=AP_PRONE+2;
+						sBPCost=BP_PRONE+2;
+						}
+						else
+						{
+						sAPCost=AP_PRONE+1;
+						sBPCost=BP_PRONE+1;
+						}
+					}
+					else
+					{
+					sAPCost=AP_PRONE;
+					sBPCost=BP_PRONE;
+					}
+					DeductPoints( pSoldier, sAPCost, sBPCost );
 				}
 			}
 			pSoldier->fDontChargeAPsForStanceChange = FALSE;
@@ -2593,7 +2752,11 @@
 
 		case HOPFENCE:
 
-			DeductPoints( pSoldier, AP_JUMPFENCE, BP_JUMPFENCE );
+			// CHRISL: Make changes so that we charge extra APs while wearing a backpack while using new inventory system
+			if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NOTHING)
+				DeductPoints( pSoldier, AP_JUMPFENCEBPACK, BP_JUMPFENCEBPACK );
+			else
+				DeductPoints( pSoldier, AP_JUMPFENCE, BP_JUMPFENCE );
 			break;
 
 			// Deduct aps for falling down....
@@ -7024,6 +7187,9 @@
 	UINT8							ubWhoIsThere;
 
 
+	//CHRISL: Disable climbing up to a roof while wearing a backpack
+	if(gGameOptions.ubInventorySystem && pSoldier->inv[BPACKPOCKPOS].usItem!=NONE)
+		return;
 	if ( FindHeigherLevel( pSoldier, pSoldier->sGridNo, pSoldier->bDirection, &bNewDirection ) && ( pSoldier->bLevel == 0 ) )
 	{
 		if ( EnoughPoints( pSoldier, GetAPsToClimbRoof( pSoldier, FALSE ), 0, TRUE ) )
Index: Tactical/Soldier Control.h
===================================================================
--- Tactical/Soldier Control.h	(revision 1299)
+++ Tactical/Soldier Control.h	(working copy)
@@ -257,7 +257,9 @@
 
 typedef struct path PathSt;
 typedef PathSt *PathStPtr;
-enum {
+/* CHRISL: Added listings for each of the new inventory pockets.  Also split the enum so we could include
+endpoint markers for each type (big, med, sml) of pocket. */
+enum INVENTORY{
 	HELMETPOS = 0,
 	VESTPOS,
 	LEGPOS,
@@ -265,50 +267,94 @@
 	HEAD2POS,
 	HANDPOS,
 	SECONDHANDPOS,
-	BIGPOCK1POS,
+	VESTPOCKPOS,
+	LTHIGHPOCKPOS,
+	RTHIGHPOCKPOS,
+	CPACKPOCKPOS,
+	BPACKPOCKPOS,
+	GUNSLINGPOCKPOS,
+	KNIFEPOCKPOS,
+	BODYPOSFINAL,
+	BIGPOCK1POS = BODYPOSFINAL,
 	BIGPOCK2POS,
 	BIGPOCK3POS,
 	BIGPOCK4POS,
-	SMALLPOCK1POS,
+	BIGPOCK5POS,
+	BIGPOCK6POS,
+	BIGPOCK7POS,
+	BIGPOCKFINAL,
+	MEDPOCK1POS = BIGPOCKFINAL,
+	MEDPOCK2POS,
+	MEDPOCK3POS,
+	MEDPOCK4POS,
+	MEDPOCKFINAL,
+	SMALLPOCK1POS = MEDPOCKFINAL,
 	SMALLPOCK2POS,
 	SMALLPOCK3POS,
 	SMALLPOCK4POS,
 	SMALLPOCK5POS,
 	SMALLPOCK6POS,
 	SMALLPOCK7POS,
-	SMALLPOCK8POS, // = 18, so 19 pockets needed
-
-	NUM_INV_SLOTS,
+	SMALLPOCK8POS,
+	SMALLPOCK9POS,
+	SMALLPOCK10POS,
+	SMALLPOCK11POS,
+	SMALLPOCK12POS,
+	SMALLPOCK13POS,
+	SMALLPOCK14POS,
+	SMALLPOCK15POS,
+	SMALLPOCK16POS,
+	SMALLPOCK17POS,
+	SMALLPOCK18POS,
+	SMALLPOCK19POS,
+	SMALLPOCK20POS,
+	SMALLPOCK21POS,
+	SMALLPOCK22POS,
+	SMALLPOCK23POS,
+	SMALLPOCK24POS,
+	SMALLPOCK25POS,
+	SMALLPOCK26POS,
+	SMALLPOCK27POS,
+	SMALLPOCK28POS,
+	SMALLPOCK29POS,
+	SMALLPOCK30POS,
+	NUM_INV_SLOTS
 };
+// CHRISL: Arrays to track ic group information
+//							{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54}
+const INT8	icLBE[55] =		{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,10,10,11,11,11,11, 7, 7, 8, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,10,10,10,11,11,11,11,11,11,11,11};
+const INT8	icClass[55] =	{-1,-1,-1,-1,-1,-1,-1, 5, 5, 5, 5, 5, 6, 6, 3, 3, 3, 4, 4, 4, 4, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4};
+const INT8	icPocket[55] =	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 4, 5, 6, 8, 9,10,11,10,11, 4, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7};
+const INT8	oldInv[55] =	{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+const INT8	vehicleInv[55]=	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0};
 
 // WDS - Clean up inventory handling
 // NOTE NOTE NOTE!  Leave this alone until it is no longer needed.  It must match the
 // original definition so old files can be read.
 namespace OldInventory {
-enum {
-	HELMETPOS = 0,
-	VESTPOS,
-	LEGPOS,
-	HEAD1POS,
-	HEAD2POS,
-	HANDPOS,
-	SECONDHANDPOS,
-	BIGPOCK1POS,
-	BIGPOCK2POS,
-	BIGPOCK3POS,
-	BIGPOCK4POS,
-	SMALLPOCK1POS,
-	SMALLPOCK2POS,
-	SMALLPOCK3POS,
-	SMALLPOCK4POS,
-	SMALLPOCK5POS,
-	SMALLPOCK6POS,
-	SMALLPOCK7POS,
-	SMALLPOCK8POS, // = 18, so 19 pockets needed
-
-	NUM_INV_SLOTS,
+	enum {
+		HELMETPOS = 0,
+		VESTPOS,
+		LEGPOS,
+		HEAD1POS,
+		HEAD2POS,
+		HANDPOS,
+		SECONDHANDPOS,
+		BIGPOCK1POS,
+		BIGPOCK2POS,
+		BIGPOCK3POS,
+		BIGPOCK4POS,
+		SMALLPOCK1POS,
+		SMALLPOCK2POS,
+		SMALLPOCK3POS,
+		SMALLPOCK4POS,
+		SMALLPOCK5POS,
+		SMALLPOCK6POS,
+		SMALLPOCK7POS,
+		SMALLPOCK8POS, // = 18, so 19 pockets needed
+		NUM_INV_SLOTS,
+	};
 };
-};
 
 //used for color codes, but also shows the enemy type for debugging purposes
 enum
@@ -403,6 +449,9 @@
 private:
 	vector<OBJECTTYPE> inv;
 	int slotCnt;
+	// Added for new inventory system to work
+	friend BOOLEAN SaveSoldierStructure( HWFILE hFile );
+	friend BOOLEAN LoadSoldierStructure( HWFILE hFile );
 };
 
 //typedef struct
@@ -1055,8 +1104,13 @@
 	INT8	snowCamo;	
 	INT8	wornSnowCamo;
 
-	UINT8					bFiller[ 36 ];
+	INT16	DropPackKey;
+	BOOLEAN	DropPackFlag;
+	BOOLEAN	ZipperFlag;
 
+//	UINT8					bFiller[ 36 ];
+	UINT8					bFiller[ 31 ];
+
 	//
 	// New and OO stuff goes after here.  Above this point any changes will goof up reading from files.
 	//
Index: Tactical/Soldier Create.cpp
===================================================================
--- Tactical/Soldier Create.cpp	(revision 1299)
+++ Tactical/Soldier Create.cpp	(working copy)
@@ -515,7 +515,8 @@
 		{
 			INT32 i;
 			BOOLEAN fSecondFaceItem = FALSE;
-			for( i = BIGPOCK1POS; i <= BIGPOCK4POS; i++ )
+			// CHRISL:
+			for( i = BIGPOCK1POS; i < BIGPOCKFINAL; i++ )
 			{
 				if( Item[ Soldier.inv[ i ].usItem ].usItemClass & IC_FACE )
 				{
@@ -2577,6 +2578,9 @@
 	}
 }
 
+// CHRISL: External function call to resort profile inventory
+extern void DistributeInitialGear(MERCPROFILESTRUCT *pProfile);
+
 void CopyProfileItems( SOLDIERTYPE *pSoldier, SOLDIERCREATE_STRUCT *pCreateStruct )
 {
 	UINT32								cnt, cnt2;
@@ -2594,6 +2598,9 @@
 		{
 			// do some special coding to put stuff in the profile in better-looking
 			// spots
+			// CHRISL: Resort profile items to use LBE pockets properly
+			if(gGameOptions.ubInventorySystem)
+				DistributeInitialGear(pProfile);
 			// WDS - Clean up inventory handling
 //			memset( pSoldier->inv, 0, NUM_INV_SLOTS * sizeof( OBJECTTYPE ) );
 			for ( cnt = 0; cnt < NUM_INV_SLOTS; cnt++ )
@@ -2616,12 +2623,20 @@
 						if (cnt2 == NUM_INV_SLOTS)
 						{
 							// oh well, couldn't find anything to attach to!
-							AutoPlaceObject( pSoldier, &Obj, FALSE );
+							//CHRISL: Place items by slots chosen in profile if using new inventory system
+							if(!gGameOptions.ubInventorySystem)
+								AutoPlaceObject( pSoldier, &Obj, FALSE );
+							else
+								PlaceObject( pSoldier, cnt, &Obj );
 						}
 					}
 					else
 					{
-						AutoPlaceObject( pSoldier, &Obj, FALSE );
+						//CHRISL: Place items by slots chosen in profile if using new inventory system
+						if(!gGameOptions.ubInventorySystem)
+							AutoPlaceObject( pSoldier, &Obj, FALSE );
+						else
+							PlaceObject( pSoldier, cnt, &Obj );
 					}
 
 				}
@@ -2700,13 +2715,15 @@
 			if (pProfile->uiMoney > 0)
 			{
 				uiMoneyLeft = pProfile->uiMoney;
-				bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, SMALLPOCK8POS );
+				// CHRISL:
+				bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, (NUM_INV_SLOTS-1) );
 
 				// add in increments of 
 				while ( bSlot != NO_SLOT )
 				{
 					uiMoneyLimitInSlot = MAX_MONEY_PER_SLOT;
-					if ( bSlot >= SMALLPOCK1POS )
+					// CHRISL:
+					if ( bSlot >= BIGPOCKFINAL )
 					{
 						uiMoneyLimitInSlot /= 2;
 					}
@@ -2725,7 +2742,8 @@
 						break;
 					}
 
-					bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, SMALLPOCK8POS );
+					// CHRISL:
+					bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, (NUM_INV_SLOTS-1) );
 				}			
 			}
 		}
Index: Tactical/soldier profile type.h
===================================================================
--- Tactical/soldier profile type.h	(revision 1299)
+++ Tactical/soldier profile type.h	(working copy)
@@ -161,7 +161,55 @@
 #define BUDDY_OPINION +25
 #define HATED_OPINION -25
 
-// WDS - Clean up inventory handling
+//CHRISL:
+typedef struct
+{
+	UINT32				lbeClass;
+	UINT16				lbeIndex;
+	UINT8				ubID;
+	BOOLEAN				ZipperFlag;
+	UINT32				uiNodeChecksum;
+	OBJECTTYPE			inv[12];
+} LBENODE;
+
+//extern LBENODE			*LBEptr;
+extern vector<LBENODE>	LBEptr;
+extern UINT16			LBEptrNum;
+
+// CHRISL: Class to handle profile equipment from XML_MercStartingGear
+class MERCPROFILEGEAR {
+public:
+	// Constructor
+	MERCPROFILEGEAR();
+	// Copy Constructor
+	MERCPROFILEGEAR(const MERCPROFILEGEAR&);
+	// Assignment operator
+	MERCPROFILEGEAR& operator=(const MERCPROFILEGEAR&);
+	// Destructor
+	~MERCPROFILEGEAR();
+
+	// Initialize the mercenary profile gear
+	void initialize();
+
+	//  Note that the constructor does this automatically.
+	void clearInventory();
+public:
+	UINT16		mIndex;
+	CHAR8		mName[80];
+	char		endOfPOD;	// marker for end of POD (plain old data)
+	vector<int>	inv;
+	vector<int>	iStatus;
+	vector<int>	iDrop;
+	vector<int>	iNumber;
+	vector<int>	lbe;
+	vector<int>	lStatus;
+private:
+	int			invCnt;
+	int			lbeCnt;
+};
+#define SIZEOF_MERCPROFILEGEAR_POD offsetof( MERCPROFILEGEAR, endOfPOD )
+
+// WDS Inventory cleanup, phase 2
 //typedef struct	
 class MERCPROFILESTRUCT {
 public:
Index: Tactical/Soldier Profile.cpp
===================================================================
--- Tactical/Soldier Profile.cpp	(revision 1299)
+++ Tactical/Soldier Profile.cpp	(working copy)
@@ -69,7 +69,10 @@
 #define		SET_PROFILE_GAINS2			500, 500, 500, 500, 500, 500, 500, 500, 500
 
 MERCPROFILESTRUCT gMercProfiles[ NUM_PROFILES ];
+MERCPROFILEGEAR gMercProfileGear[ NUM_PROFILES ];
 
+extern UINT8 gubItemDroppableFlag[NUM_INV_SLOTS];
+
 INT8 gbSkillTraitBonus[NUM_SKILLTRAITS] =
 {
 	 0,  //NO_SKILLTRAIT
@@ -232,7 +235,7 @@
 	STR8 pFileName3_Tons = "BINARYDATA\\Prof_Expert_TonsOfGuns.dat";
 	STR8 pFileName4_Tons = "BINARYDATA\\Prof_Insane_TonsOfGuns.dat";
 
-	UINT32 uiLoop, uiLoop2;//, uiLoop3;
+	UINT32 uiLoop, uiLoop2, uiLoop3;
 	UINT16 usItem;//, usNewGun, usAmmo, usNewAmmo;
 	UINT32	uiNumBytesRead;
 
@@ -284,6 +287,38 @@
 		}
 		gMercProfiles[ uiLoop ].CopyOldInventoryToNew();
 
+		// CHRISL: Overwrite inventory data pulled from prof.dat with data stored in gMercProfileGear
+		// Start by resetting all profile inventory values to 0
+		gMercProfiles[uiLoop].clearInventory();
+		gMercProfiles[uiLoop].ubInvUndroppable = 0;
+		// Next, go through and assign everything but lbe gear
+		for(uiLoop2=0; uiLoop2<OldInventory::NUM_INV_SLOTS; uiLoop2++)
+		{
+			gMercProfiles[uiLoop].inv[uiLoop2] = gMercProfileGear[uiLoop].inv[uiLoop2];
+			gMercProfiles[uiLoop].bInvStatus[uiLoop2] = gMercProfileGear[uiLoop].iStatus[uiLoop2];
+			if(gMercProfiles[uiLoop].inv[uiLoop2] != NONE)
+			{
+				if(uiLoop2 > 5)
+					gMercProfiles[uiLoop].bInvNumber[uiLoop2] = gMercProfileGear[uiLoop].iNumber[uiLoop2];
+				else
+					gMercProfiles[uiLoop].bInvNumber[uiLoop2] = 1;
+				if(!gMercProfileGear[uiLoop].iDrop[uiLoop2] && uiLoop > 56)
+					gMercProfiles[uiLoop].ubInvUndroppable |= gubItemDroppableFlag[uiLoop2];
+			}
+		}
+		// Last, go through and assign LBE items.  Only needed for new inventory system
+		if(gGameOptions.ubInventorySystem)
+		{
+			for(uiLoop2=0; uiLoop2<5; uiLoop2++)
+			{
+				uiLoop3 = uiLoop2 + OldInventory::NUM_INV_SLOTS; 
+				gMercProfiles[uiLoop].inv[uiLoop3] = gMercProfileGear[uiLoop].lbe[uiLoop2];
+				gMercProfiles[uiLoop].bInvStatus[uiLoop3] = gMercProfileGear[uiLoop].lStatus[uiLoop2];
+				if(gMercProfiles[uiLoop].inv[uiLoop3] != NONE)
+					gMercProfiles[uiLoop].bInvNumber[uiLoop3] = 1;
+			}
+		}
+
 		//if the Dialogue exists for the merc, allow the merc to be hired
 		if( DialogueDataFileExistsForProfile( (UINT8)uiLoop, 0, FALSE, NULL ) )
 		{
Index: Tactical/Soldier Profile.h
===================================================================
--- Tactical/Soldier Profile.h	(revision 1299)
+++ Tactical/Soldier Profile.h	(working copy)
@@ -11,6 +11,7 @@
 extern BOOLEAN	gfPotentialTeamChangeDuringDeath;
 
 extern MERCPROFILESTRUCT gMercProfiles[ NUM_PROFILES ];
+extern MERCPROFILEGEAR gMercProfileGear[ NUM_PROFILES ];
 
 #define AIM_AND_MERC_MERCS		51		// A.I.M. is 0-39, M.E.R.C.s are 40-50
 
Index: Tactical/SoldierTooltips.cpp
===================================================================
--- Tactical/SoldierTooltips.cpp	(revision 1299)
+++ Tactical/SoldierTooltips.cpp	(working copy)
@@ -266,7 +266,7 @@
 		// weapon in off hand info code block end
 
 		// large objects in big inventory slots info code block start
-		for ( UINT8 BigSlot = BIGPOCK1POS; BigSlot <= BIGPOCK4POS; BigSlot++ )
+		for ( UINT8 BigSlot = BIGPOCK1POS; BigSlot < BIGPOCKFINAL; BigSlot++ )
 		{
 			if ( pSoldier->inv[ BigSlot ].usItem == 0 )
 				continue; // slot is empty, move on to the next slot
@@ -290,6 +290,19 @@
 					if ( !gGameExternalOptions.fEnableSoldierTooltipBigSlot4 )
 						continue;
 					break;
+// CHRISL: Added new large pockets introduced by new inventory system
+				case BIGPOCK5POS:
+					if ( !gGameExternalOptions.fEnableSoldierTooltipBigSlot5 )
+						continue;
+					break;
+				case BIGPOCK6POS:
+					if ( !gGameExternalOptions.fEnableSoldierTooltipBigSlot6 )
+						continue;
+					break;
+				case BIGPOCK7POS:
+					if ( !gGameExternalOptions.fEnableSoldierTooltipBigSlot7 )
+						continue;
+				    break;
 			}
 
 			if ( Item[ pSoldier->inv[ BigSlot ].usItem ].rocketlauncher )
@@ -486,4 +499,4 @@
 	InvalidateRegion(  iX, iY, (iX + iW) , (iY + iH) );
 
 	//InvalidateScreen();
-}
\ No newline at end of file
+}
Index: Tactical/Tactical Save.cpp
===================================================================
--- Tactical/Tactical Save.cpp	(revision 1299)
+++ Tactical/Tactical Save.cpp	(working copy)
@@ -2862,6 +2862,24 @@
 		uiChecksum += pSoldier->inv[ uiLoop ].ubNumberOfObjects;
 	}
 
+ 	return( uiChecksum );
+}
+
+// CHRISL: New Checksum for LBENODE
+UINT32 LBENODEChecksum( LBENODE * pNode )
+{
+	UINT32	uiChecksum = 1;
+	UINT32	uiLoop;
+
+	uiChecksum += (pNode->lbeClass + 1);
+	uiChecksum *= (pNode->lbeIndex +1);
+	uiChecksum += (pNode->ubID +1);
+
+	for ( uiLoop = 0; uiLoop < 12; uiLoop++ )
+	{
+		uiChecksum += pNode->inv[ uiLoop ].usItem;
+	}
+
 	return( uiChecksum );
 }
 
Index: Tactical/Tactical Save.h
===================================================================
--- Tactical/Tactical Save.h	(revision 1299)
+++ Tactical/Tactical Save.h	(working copy)
@@ -101,6 +101,7 @@
 
 UINT32 MercChecksum( SOLDIERTYPE * pSoldier );
 UINT32 ProfileChecksum( MERCPROFILESTRUCT * pProfile );
+UINT32 LBENODEChecksum( LBENODE * pNode );
 BOOLEAN JA2EncryptedFileRead( HWFILE hFile, PTR pDest, UINT32 uiBytesToRead, UINT32 *puiBytesRead );
 BOOLEAN JA2EncryptedFileWrite( HWFILE hFile, PTR pDest, UINT32 uiBytesToWrite, UINT32 *puiBytesWritten );
 
Index: Tactical/XML.h
===================================================================
--- Tactical/XML.h	(revision 1299)
+++ Tactical/XML.h	(working copy)
@@ -38,6 +38,10 @@
 #define	ENEMYGUNCHOICESFILENAME					"EnemyGunChoices.xml"
 #define	ENEMYITEMCHOICESFILENAME				"EnemyItemChoices.xml"
 #define	IMPITEMCHOICESFILENAME					"IMPItemChoices.xml"
+// CHRISL:
+#define LOADBEARINGEQUIPMENTFILENAME			"LoadBearingEquipment.xml"
+#define LBEPOCKETFILENAME						"Pockets.xml"
+#define MERCSTARTINGGEARFILENAME				"MercStartingGear.xml"
 
 #define TONYINVENTORYFILENAME                   "NPCInventory\\TonyInventory.xml"
 #define DEVININVENTORYFILENAME                  "NPCInventory\\DevinInventory.xml"
@@ -119,6 +123,16 @@
 extern BOOLEAN ReadInArmourStats(STR fileName);
 extern BOOLEAN WriteArmourStats();
 
+// CHRISL:
+extern BOOLEAN ReadInlbeStats(STR fileName);
+extern BOOLEAN WritelbeEquipmentStats();
+
+extern BOOLEAN ReadInLBEPocketStats(STR fileName);
+extern BOOLEAN WriteLBEPocketEquipmentStats();
+
+extern BOOLEAN ReadInMercStartingGearStats(STR fileName);
+extern BOOLEAN WriteMercStartingGearStats();
+
 extern BOOLEAN ReadInExplosiveStats(STR fileName);
 extern BOOLEAN WriteExplosiveStats();
 
Index: Tactical/XML_LBEPocket.cpp
===================================================================
--- Tactical/XML_LBEPocket.cpp	(revision 0)
+++ Tactical/XML_LBEPocket.cpp	(revision 0)
@@ -0,0 +1,514 @@
+#ifdef PRECOMPILEDHEADERS
+	#include "Tactical All.h"
+#else
+	#include "sgp.h"
+	#include "overhead types.h"
+	#include "Sound Control.h"
+	#include "Soldier Control.h"
+	#include "overhead.h"
+	#include "Event Pump.h"
+	#include "weapons.h"
+	#include "Animation Control.h"
+	#include "sys globals.h"
+	#include "Handle UI.h"
+	#include "Isometric Utils.h"
+	#include "worldman.h"
+	#include "math.h"
+	#include "points.h"
+	#include "ai.h"
+	#include "los.h"
+	#include "renderworld.h"
+	#include "opplist.h"
+	#include "interface.h"
+	#include "message.h"
+	#include "campaign.h"
+	#include "items.h"
+	#include "weapons.h"
+	#include "text.h"
+	#include "Soldier Profile.h"
+	#include "tile animation.h"
+	#include "Dialogue Control.h"
+	#include "SkillCheck.h"
+	#include "explosion control.h"
+	#include "Quests.h"
+	#include "Physics.h"
+	#include "Random.h"
+	#include "Vehicles.h"
+	#include "bullets.h"
+	#include "morale.h"
+	#include "meanwhile.h"
+	#include "SkillCheck.h"
+	#include "gamesettings.h"
+	#include "SaveLoadMap.h"
+	#include "Debug Control.h"
+	#include "expat.h"
+	#include "XML.h"
+#endif
+
+struct
+{
+	PARSE_STAGE	curElement;
+
+	CHAR8			szCharData[MAX_CHAR_DATA_LENGTH+1];
+	POCKETTYPE		curLBEPocket;
+//	POCKETTYPE *	curArray;
+//	UINT32			maxArraySize;
+	
+	UINT32			currentDepth;
+	UINT32			maxReadDepth;
+}
+typedef lbepocketParseData;
+
+static void XMLCALL 
+lbepocketStartElementHandle(void *userData, const XML_Char *name, const XML_Char **atts)
+{
+	lbepocketParseData * pData = (lbepocketParseData *)userData;
+
+	if(pData->currentDepth <= pData->maxReadDepth) //are we reading this element?
+	{
+		if(strcmp(name, "POCKETLIST") == 0 && pData->curElement == ELEMENT_NONE)
+		{
+			pData->curElement = ELEMENT_LIST;
+
+			//memset(pData->curArray,0,sizeof(POCKETTYPE)*pData->maxArraySize);
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+		else if(strcmp(name, "POCKET") == 0 && pData->curElement == ELEMENT_LIST)
+		{
+			pData->curElement = ELEMENT;
+
+			//memset(&pData->curLBEPocket,0,sizeof(POCKETTYPE));
+			pData->curLBEPocket = POCKETTYPE();
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+		else if(pData->curElement == ELEMENT &&
+				(strcmp(name, "pIndex") == 0 ||
+				strcmp(name, "pName") == 0 ||
+				strcmp(name, "pSilhouette") == 0 ||
+				strcmp(name, "pType") == 0 ||
+				strcmp(name, "pRestriction") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.0") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.1") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.2") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.3") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.4") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.5") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.6") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.7") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.8") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.9") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.10") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.11") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.12") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.13") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.14") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.15") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.16") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.17") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.18") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.19") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.20") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.21") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.22") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.23") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.24") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.25") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.26") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.27") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.28") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.29") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.30") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.31") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.32") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.33") == 0 ||
+				strcmp(name, "ItemCapacityPerSize.34") == 0 ))
+		{
+			pData->curElement = ELEMENT_PROPERTY;
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+
+		pData->szCharData[0] = '\0';
+	}
+
+	pData->currentDepth++;
+
+}
+
+static void XMLCALL
+lbepocketCharacterDataHandle(void *userData, const XML_Char *str, int len)
+{
+	lbepocketParseData * pData = (lbepocketParseData *)userData;
+
+	if( (pData->currentDepth <= pData->maxReadDepth) && 
+		(strlen(pData->szCharData) < MAX_CHAR_DATA_LENGTH)
+	  ){
+		strncat(pData->szCharData,str,__min((unsigned int)len,MAX_CHAR_DATA_LENGTH-strlen(pData->szCharData)));
+	  }
+}
+
+
+static void XMLCALL
+lbepocketEndElementHandle(void *userData, const XML_Char *name)
+{
+	lbepocketParseData * pData = (lbepocketParseData *)userData;
+
+	if(pData->currentDepth <= pData->maxReadDepth) //we're at the end of an element that we've been reading
+	{
+		if(strcmp(name, "POCKETLIST") == 0)
+		{
+			pData->curElement = ELEMENT_NONE;
+		}
+		else if(strcmp(name, "POCKET") == 0)
+		{
+			pData->curElement = ELEMENT_LIST;
+			LBEPocketType.push_back(pData->curLBEPocket);
+		}
+		else if(strcmp(name, "pIndex") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.pIndex   = (UINT16) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "pName") == 0)
+		{
+			pData->curElement = ELEMENT;
+			if(MAX_CHAR_DATA_LENGTH >= strlen(pData->szCharData))
+				strcpy(pData->curLBEPocket.pName,pData->szCharData);
+			else
+			{
+				strncpy(pData->curLBEPocket.pName,pData->szCharData,MAX_CHAR_DATA_LENGTH);
+				pData->curLBEPocket.pName[MAX_CHAR_DATA_LENGTH] = '\0';
+			}
+		}
+		else if(strcmp(name, "pSilhouette") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.pSilhouette  = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "pType") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.pType = (UINT16) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "pRestriction") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.pRestriction = (UINT32) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.0") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[0] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.1") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[1] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.2") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[2] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.3") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[3] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.4") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[4] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.5") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[5] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.6") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[6] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.7") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[7] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.8") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[8] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.9") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[9] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.10") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[10] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.11") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[11] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.12") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[12] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.13") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[13] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.14") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[14] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.15") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[15] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.16") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[16] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.17") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[17] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.18") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[18] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.19") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[19] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.20") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[20] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.21") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[21] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.22") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[22] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.23") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[23] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.24") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[24] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.25") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[25] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.26") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[26] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.27") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[27] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.28") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[28] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.29") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[29] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.30") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[30] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.31") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[31] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.32") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[32] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.33") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[33] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "ItemCapacityPerSize.34") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBEPocket.ItemCapacityPerSize[34] = (UINT8) atol(pData->szCharData);
+		}
+
+		pData->maxReadDepth--;
+	}
+
+	pData->currentDepth--;
+}
+
+
+
+
+BOOLEAN ReadInLBEPocketStats(STR fileName)
+{
+	HWFILE		hFile;
+	UINT32		uiBytesRead;
+	UINT32		uiFSize;
+	CHAR8 *		lpcBuffer;
+	XML_Parser	parser = XML_ParserCreate(NULL);
+	
+	lbepocketParseData pData;
+
+	DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Loading LBEPocket.xml" );
+
+	// Open loadbearingequipment file
+	hFile = FileOpen( fileName, FILE_ACCESS_READ, FALSE );
+	if ( !hFile )
+		return( FALSE );
+	
+	uiFSize = FileGetSize(hFile);
+	lpcBuffer = (CHAR8 *) MemAlloc(uiFSize+1);
+
+	//Read in block
+	if ( !FileRead( hFile, lpcBuffer, uiFSize, &uiBytesRead ) )
+	{
+		MemFree(lpcBuffer);
+		return( FALSE );
+	}
+
+	lpcBuffer[uiFSize] = 0; //add a null terminator
+
+	FileClose( hFile );
+
+	
+	XML_SetElementHandler(parser, lbepocketStartElementHandle, lbepocketEndElementHandle);
+	XML_SetCharacterDataHandler(parser, lbepocketCharacterDataHandle);
+
+	
+	memset(&pData,0,sizeof(pData));
+	//pData.curArray = LBEPocketType;
+	//pData.maxArraySize = MAXITEMS; 
+	
+	XML_SetUserData(parser, &pData);
+
+
+    if(!XML_Parse(parser, lpcBuffer, uiFSize, TRUE))
+	{
+		CHAR8 errorBuf[511];
+
+		sprintf(errorBuf, "XML Parser Error in Pocket.xml: %s at line %d", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser));
+		LiveMessage(errorBuf);
+
+		MemFree(lpcBuffer);
+		return FALSE;
+	}
+
+	MemFree(lpcBuffer);
+
+
+	XML_ParserFree(parser);
+
+
+	return( TRUE );
+}
+BOOLEAN WriteLBEPocketEquipmentStats()
+{
+	//DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"writelbepocketsstats");
+	HWFILE		hFile;
+
+	//Debug code; make sure that what we got from the file is the same as what's there
+	// Open a new file
+	hFile = FileOpen( "TABLEDATA\\Pocket out.xml", FILE_ACCESS_WRITE | FILE_CREATE_ALWAYS, FALSE );
+	if ( !hFile )
+		return( FALSE );
+	
+	{
+		UINT32 cnt;
+
+		FilePrintf(hFile,"<POCKETLIST>\r\n");
+		for(cnt = 0;cnt < MAXITEMS;cnt++)
+		{
+
+			FilePrintf(hFile,"\t<POCKET>\r\n");
+
+			FilePrintf(hFile,"\t\t<pIndex>%d</pIndex>\r\n",								cnt );
+			FilePrintf(hFile,"\t\t<pSilhouette>%d</pSilhouette>\r\n",								LBEPocketType[cnt].pSilhouette  );
+			FilePrintf(hFile,"\t\t<pType>%d</pType>\r\n",								LBEPocketType[cnt].pType   );
+			FilePrintf(hFile,"\t\t<pRestriction>%d</pRestriction>\r\n",						LBEPocketType[cnt].pRestriction	);
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.0>%d</ItemCapacityPerSize.0>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[0]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.1>%d</ItemCapacityPerSize.1>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[1]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.2>%d</ItemCapacityPerSize.2>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[2]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.3>%d</ItemCapacityPerSize.3>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[3]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.4>%d</ItemCapacityPerSize.4>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[4]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.5>%d</ItemCapacityPerSize.5>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[5]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.6>%d</ItemCapacityPerSize.6>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[6]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.7>%d</ItemCapacityPerSize.7>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[7]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.8>%d</ItemCapacityPerSize.8>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[8]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.9>%d</ItemCapacityPerSize.9>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[9]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.10>%d</ItemCapacityPerSize.10>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[10]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.11>%d</ItemCapacityPerSize.11>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[11]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.12>%d</ItemCapacityPerSize.12>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[12]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.13>%d</ItemCapacityPerSize.13>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[13]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.14>%d</ItemCapacityPerSize.14>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[14]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.15>%d</ItemCapacityPerSize.15>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[15]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.16>%d</ItemCapacityPerSize.16>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[16]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.17>%d</ItemCapacityPerSize.17>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[17]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.18>%d</ItemCapacityPerSize.18>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[18]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.19>%d</ItemCapacityPerSize.19>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[19]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.20>%d</ItemCapacityPerSize.20>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[20]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.21>%d</ItemCapacityPerSize.21>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[21]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.22>%d</ItemCapacityPerSize.22>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[22]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.23>%d</ItemCapacityPerSize.23>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[23]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.24>%d</ItemCapacityPerSize.24>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[24]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.25>%d</ItemCapacityPerSize.25>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[25]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.26>%d</ItemCapacityPerSize.26>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[26]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.27>%d</ItemCapacityPerSize.27>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[27]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.28>%d</ItemCapacityPerSize.28>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[28]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.29>%d</ItemCapacityPerSize.29>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[29]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.30>%d</ItemCapacityPerSize.30>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[30]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.31>%d</ItemCapacityPerSize.31>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[31]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.32>%d</ItemCapacityPerSize.32>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[32]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.33>%d</ItemCapacityPerSize.33>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[33]   );
+			FilePrintf(hFile,"\t\t<ItemCapacityPerSize.34>%d</ItemCapacityPerSize.34>\r\n",								LBEPocketType[cnt].ItemCapacityPerSize[34]   );
+
+			FilePrintf(hFile,"\t</POCKET>\r\n");
+		}
+		FilePrintf(hFile,"</POCKETLIST>\r\n");
+	}
+	FileClose( hFile );
+
+	return( TRUE );
+}
Index: Tactical/XML_LoadBearingEquipment.cpp
===================================================================
--- Tactical/XML_LoadBearingEquipment.cpp	(revision 0)
+++ Tactical/XML_LoadBearingEquipment.cpp	(revision 0)
@@ -0,0 +1,335 @@
+#ifdef PRECOMPILEDHEADERS
+	#include "Tactical All.h"
+#else
+	#include "sgp.h"
+	#include "overhead types.h"
+	#include "Sound Control.h"
+	#include "Soldier Control.h"
+	#include "overhead.h"
+	#include "Event Pump.h"
+	#include "weapons.h"
+	#include "Animation Control.h"
+	#include "sys globals.h"
+	#include "Handle UI.h"
+	#include "Isometric Utils.h"
+	#include "worldman.h"
+	#include "math.h"
+	#include "points.h"
+	#include "ai.h"
+	#include "los.h"
+	#include "renderworld.h"
+	#include "opplist.h"
+	#include "interface.h"
+	#include "message.h"
+	#include "campaign.h"
+	#include "items.h"
+	#include "weapons.h"
+	#include "text.h"
+	#include "Soldier Profile.h"
+	#include "tile animation.h"
+	#include "Dialogue Control.h"
+	#include "SkillCheck.h"
+	#include "explosion control.h"
+	#include "Quests.h"
+	#include "Physics.h"
+	#include "Random.h"
+	#include "Vehicles.h"
+	#include "bullets.h"
+	#include "morale.h"
+	#include "meanwhile.h"
+	#include "SkillCheck.h"
+	#include "gamesettings.h"
+	#include "SaveLoadMap.h"
+	#include "Debug Control.h"
+	#include "expat.h"
+	#include "XML.h"
+#endif
+
+struct
+{
+	PARSE_STAGE	curElement;
+
+	CHAR8			szCharData[MAX_CHAR_DATA_LENGTH+1];
+	LBETYPE			curLBE;
+//	LBETYPE *		curArray;
+//	vector<LBETYPE>*	curArray;
+//	UINT32			maxArraySize;
+	
+	UINT32			currentDepth;
+	UINT32			maxReadDepth;
+}
+typedef lbeParseData;
+
+static void XMLCALL 
+lbeStartElementHandle(void *userData, const XML_Char *name, const XML_Char **atts)
+{
+	lbeParseData * pData = (lbeParseData *)userData;
+
+	if(pData->currentDepth <= pData->maxReadDepth) //are we reading this element?
+	{
+		if(strcmp(name, "LOADBEARINGEQUIPMENTLIST") == 0 && pData->curElement == ELEMENT_NONE)
+		{
+			pData->curElement = ELEMENT_LIST;
+
+			//memset(pData->curArray,0,sizeof(LBETYPE)*pData->maxArraySize);
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+		else if(strcmp(name, "LOADBEARINGEQUIPMENT") == 0 && pData->curElement == ELEMENT_LIST)
+		{
+			pData->curElement = ELEMENT;
+
+			pData->curLBE = LBETYPE();
+			//memset(&pData->curLBE,0,sizeof(LBETYPE));
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+		else if(pData->curElement == ELEMENT &&
+				(strcmp(name, "lbeIndex") == 0 ||
+				strcmp(name, "lbeClass") == 0 ||
+				strcmp(name, "lbeCombo") == 0 ||
+				strcmp(name, "lbePocketIndex.1") == 0 ||
+				strcmp(name, "lbePocketIndex.2") == 0 ||
+				strcmp(name, "lbePocketIndex.3") == 0 ||
+				strcmp(name, "lbePocketIndex.4") == 0 ||
+				strcmp(name, "lbePocketIndex.5") == 0 ||
+				strcmp(name, "lbePocketIndex.6") == 0 ||
+				strcmp(name, "lbePocketIndex.7") == 0 ||
+				strcmp(name, "lbePocketIndex.8") == 0 ||
+				strcmp(name, "lbePocketIndex.9") == 0 ||
+				strcmp(name, "lbePocketIndex.10") == 0 ||
+				strcmp(name, "lbePocketIndex.11") == 0 ||
+				strcmp(name, "lbePocketIndex.12") == 0 ))
+		{
+			pData->curElement = ELEMENT_PROPERTY;
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+
+		pData->szCharData[0] = '\0';
+	}
+
+	pData->currentDepth++;
+
+}
+
+static void XMLCALL
+lbeCharacterDataHandle(void *userData, const XML_Char *str, int len)
+{
+	lbeParseData * pData = (lbeParseData *)userData;
+
+	if( (pData->currentDepth <= pData->maxReadDepth) && 
+		(strlen(pData->szCharData) < MAX_CHAR_DATA_LENGTH)
+	  ){
+		strncat(pData->szCharData,str,__min((unsigned int)len,MAX_CHAR_DATA_LENGTH-strlen(pData->szCharData)));
+	  }
+}
+
+
+static void XMLCALL
+lbeEndElementHandle(void *userData, const XML_Char *name)
+{
+	lbeParseData * pData = (lbeParseData *)userData;
+
+	if(pData->currentDepth <= pData->maxReadDepth) //we're at the end of an element that we've been reading
+	{
+		if(strcmp(name, "LOADBEARINGEQUIPMENTLIST") == 0)
+		{
+			pData->curElement = ELEMENT_NONE;
+		}
+		else if(strcmp(name, "LOADBEARINGEQUIPMENT") == 0)
+		{
+			pData->curElement = ELEMENT_LIST;
+			LoadBearingEquipment.push_back(pData->curLBE);
+		}
+		else if(strcmp(name, "lbeIndex") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbeIndex   = (UINT16) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbeClass") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbeClass  = (UINT32) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbeCombo") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbeCombo  = (UINT32) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.1") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[0] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.2") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[1] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.3") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[2] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.4") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[3] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.5") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[4] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.6") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[5] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.7") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[6] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.8") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[7] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.9") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[8] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.10") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[9] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.11") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[10] = (UINT8) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lbePocketIndex.12") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curLBE.lbePocketIndex[11] = (UINT8) atol(pData->szCharData);
+		}
+
+		pData->maxReadDepth--;
+	}
+
+	pData->currentDepth--;
+}
+
+
+
+
+BOOLEAN ReadInlbeStats(STR fileName)
+{
+	HWFILE		hFile;
+	UINT32		uiBytesRead;
+	UINT32		uiFSize;
+	CHAR8 *		lpcBuffer;
+	XML_Parser	parser = XML_ParserCreate(NULL);
+	
+	lbeParseData pData;
+
+	DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Loading LoadBearingEquipment.xml" );
+
+	// Open loadbearingequipment file
+	hFile = FileOpen( fileName, FILE_ACCESS_READ, FALSE );
+	if ( !hFile )
+		return( FALSE );
+	
+	uiFSize = FileGetSize(hFile);
+	lpcBuffer = (CHAR8 *) MemAlloc(uiFSize+1);
+
+	//Read in block
+	if ( !FileRead( hFile, lpcBuffer, uiFSize, &uiBytesRead ) )
+	{
+		MemFree(lpcBuffer);
+		return( FALSE );
+	}
+
+	lpcBuffer[uiFSize] = 0; //add a null terminator
+
+	FileClose( hFile );
+
+	
+	XML_SetElementHandler(parser, lbeStartElementHandle, lbeEndElementHandle);
+	XML_SetCharacterDataHandler(parser, lbeCharacterDataHandle);
+
+	
+	memset(&pData,0,sizeof(pData));
+	//pData.curArray = LoadBearingEquipment;
+	//pData.maxArraySize = MAXITEMS; 
+	
+	XML_SetUserData(parser, &pData);
+
+
+    if(!XML_Parse(parser, lpcBuffer, uiFSize, TRUE))
+	{
+		CHAR8 errorBuf[511];
+
+		sprintf(errorBuf, "XML Parser Error in LoadBearingEquipment.xml: %s at line %d", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser));
+		LiveMessage(errorBuf);
+
+		MemFree(lpcBuffer);
+		return FALSE;
+	}
+
+	MemFree(lpcBuffer);
+
+
+	XML_ParserFree(parser);
+
+
+	return( TRUE );
+}
+BOOLEAN WritelbeEquipmentStats()
+{
+	//DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"writelbestats");
+	HWFILE		hFile;
+
+	//Debug code; make sure that what we got from the file is the same as what's there
+	// Open a new file
+	hFile = FileOpen( "TABLEDATA\\LoadBearingEquipment out.xml", FILE_ACCESS_WRITE | FILE_CREATE_ALWAYS, FALSE );
+	if ( !hFile )
+		return( FALSE );
+	
+	{
+		UINT32 cnt;
+
+		FilePrintf(hFile,"<LOADBEARINGEQUIPMENTLIST>\r\n");
+		for(cnt = 0;cnt < MAXITEMS;cnt++)
+		{
+
+			FilePrintf(hFile,"\t<LOADBEARINGEQUIPMENT>\r\n");
+
+			FilePrintf(hFile,"\t\t<lbeIndex>%d</lbeIndex>\r\n",								cnt );
+			FilePrintf(hFile,"\t\t<lbeClass>%d</lbeClass>\r\n",								LoadBearingEquipment[cnt].lbeClass  );
+			FilePrintf(hFile,"\t\t<lbeCombo>%d</lbeCombo>\r\n",								LoadBearingEquipment[cnt].lbeCombo  );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.1>%d</lbePocketIndex.1>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[0]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.2>%d</lbePocketIndex.2>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[1]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.3>%d</lbePocketIndex.3>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[2]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.4>%d</lbePocketIndex.4>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[3]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.5>%d</lbePocketIndex.5>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[4]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.6>%d</lbePocketIndex.6>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[5]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.7>%d</lbePocketIndex.7>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[6]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.8>%d</lbePocketIndex.8>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[7]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.9>%d</lbePocketIndex.9>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[8]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.10>%d</lbePocketIndex.10>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[9]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.11>%d</lbePocketIndex.11>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[10]   );
+			FilePrintf(hFile,"\t\t<lbePocketIndex.12>%d</lbePocketIndex.12>\r\n",								LoadBearingEquipment[cnt].lbePocketIndex[11]   );
+
+			FilePrintf(hFile,"\t</LOADBEARINGEQUIPMENT>\r\n");
+		}
+		FilePrintf(hFile,"</LOADBEARINGEQUIPMENTLIST>\r\n");
+	}
+	FileClose( hFile );
+
+	return( TRUE );
+}
Index: Tactical/XML_MercStartingGear.cpp
===================================================================
--- Tactical/XML_MercStartingGear.cpp	(revision 0)
+++ Tactical/XML_MercStartingGear.cpp	(revision 0)
@@ -0,0 +1,756 @@
+#ifdef PRECOMPILEDHEADERS
+	#include "Tactical All.h"
+#else
+	#include "sgp.h"
+	#include "overhead types.h"
+	#include "Sound Control.h"
+	#include "Soldier Control.h"
+	#include "overhead.h"
+	#include "Event Pump.h"
+	#include "weapons.h"
+	#include "Animation Control.h"
+	#include "sys globals.h"
+	#include "Handle UI.h"
+	#include "Isometric Utils.h"
+	#include "worldman.h"
+	#include "math.h"
+	#include "points.h"
+	#include "ai.h"
+	#include "los.h"
+	#include "renderworld.h"
+	#include "opplist.h"
+	#include "interface.h"
+	#include "message.h"
+	#include "campaign.h"
+	#include "items.h"
+	#include "weapons.h"
+	#include "text.h"
+	#include "Soldier Profile.h"
+	#include "tile animation.h"
+	#include "Dialogue Control.h"
+	#include "SkillCheck.h"
+	#include "explosion control.h"
+	#include "Quests.h"
+	#include "Physics.h"
+	#include "Random.h"
+	#include "Vehicles.h"
+	#include "bullets.h"
+	#include "morale.h"
+	#include "meanwhile.h"
+	#include "SkillCheck.h"
+	#include "gamesettings.h"
+	#include "SaveLoadMap.h"
+	#include "Debug Control.h"
+	#include "expat.h"
+	#include "XML.h"
+#endif
+
+struct
+{
+	PARSE_STAGE	curElement;
+
+	CHAR8				szCharData[MAX_CHAR_DATA_LENGTH+1];
+	MERCPROFILEGEAR		curMercStartingGear;
+	MERCPROFILEGEAR *	curArray;
+	UINT32				maxArraySize;
+	
+	UINT32				currentDepth;
+	UINT32				maxReadDepth;
+}
+typedef MercStartingGearParseData;
+
+static void XMLCALL 
+MercStartingGearStartElementHandle(void *userData, const XML_Char *name, const XML_Char **atts)
+{
+	MercStartingGearParseData * pData = (MercStartingGearParseData *)userData;
+
+	if(pData->currentDepth <= pData->maxReadDepth) //are we reading this element?
+	{
+		if(strcmp(name, "MERCGEARLIST") == 0 && pData->curElement == ELEMENT_NONE)
+		{
+			pData->curElement = ELEMENT_LIST;
+
+			//pData->curArray = &(MERCPROFILEGEAR());
+			//memset(pData->curArray,0,sizeof(MERCPROFILEGEAR)*pData->maxArraySize);
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+		else if(strcmp(name, "MERCGEAR") == 0 && pData->curElement == ELEMENT_LIST)
+		{
+			pData->curElement = ELEMENT;
+
+			pData->curMercStartingGear = MERCPROFILEGEAR();
+			//memset(&pData->curMercStartingGear,0,sizeof(MERCPROFILEGEAR));
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+		else if(pData->curElement == ELEMENT &&
+				(strcmp(name, "mIndex") == 0 ||
+				strcmp(name, "mName") == 0 ||
+				strcmp(name, "mHelmet") == 0 ||
+				strcmp(name, "mHelmetStatus") == 0 ||
+				strcmp(name, "mHelmetDrop") == 0 ||
+				strcmp(name, "mVest") == 0 ||
+				strcmp(name, "mVestStatus") == 0 ||
+				strcmp(name, "mVestDrop") == 0 ||
+				strcmp(name, "mLeg") == 0 ||
+				strcmp(name, "mLegStatus") == 0 ||
+				strcmp(name, "mLegDrop") == 0 ||
+				strcmp(name, "mWeapon") == 0 ||
+				strcmp(name, "mWeaponStatus") == 0 ||
+				strcmp(name, "mWeaponDrop") == 0 ||
+				strcmp(name, "mBig0") == 0 ||
+				strcmp(name, "mBig0Quantity") == 0 ||
+				strcmp(name, "mBig0Status") == 0 ||
+				strcmp(name, "mBig0Drop") == 0 ||
+				strcmp(name, "mBig1") == 0 ||
+				strcmp(name, "mBig1Quantity") == 0 ||
+				strcmp(name, "mBig1Status") == 0 ||
+				strcmp(name, "mBig1Drop") == 0 ||
+				strcmp(name, "mBig2") == 0 ||
+				strcmp(name, "mBig2Quantity") == 0 ||
+				strcmp(name, "mBig2Status") == 0 ||
+				strcmp(name, "mBig2Drop") == 0 ||
+				strcmp(name, "mBig3") == 0 ||
+				strcmp(name, "mBig3Quantity") == 0 ||
+				strcmp(name, "mBig3Status") == 0 ||
+				strcmp(name, "mBig3Drop") == 0 ||
+				strcmp(name, "mSmall0") == 0 ||
+				strcmp(name, "mSmall0Quantity") == 0 ||
+				strcmp(name, "mSmall0Status") == 0 ||
+				strcmp(name, "mSmall1") == 0 ||
+				strcmp(name, "mSmall1Quantity") == 0 ||
+				strcmp(name, "mSmall1Status") == 0 ||
+				strcmp(name, "mSmall2") == 0 ||
+				strcmp(name, "mSmall2Quantity") == 0 ||
+				strcmp(name, "mSmall2Status") == 0 ||
+				strcmp(name, "mSmall3") == 0 ||
+				strcmp(name, "mSmall3Quantity") == 0 ||
+				strcmp(name, "mSmall3Status") == 0 ||
+				strcmp(name, "mSmall4") == 0 ||
+				strcmp(name, "mSmall4Quantity") == 0 ||
+				strcmp(name, "mSmall4Status") == 0 ||
+				strcmp(name, "mSmall5") == 0 ||
+				strcmp(name, "mSmall5Quantity") == 0 ||
+				strcmp(name, "mSmall5Status") == 0 ||
+				strcmp(name, "mSmall6") == 0 ||
+				strcmp(name, "mSmall6Quantity") == 0 ||
+				strcmp(name, "mSmall6Status") == 0 ||
+				strcmp(name, "mSmall7") == 0 ||
+				strcmp(name, "mSmall7Quantity") == 0 ||
+				strcmp(name, "mSmall7Status") == 0 ||
+				strcmp(name, "lVest") == 0 ||
+				strcmp(name, "lVestStatus") == 0 ||
+				strcmp(name, "lLeftThigh") == 0 ||
+				strcmp(name, "lLeftThighStatus") == 0 ||
+				strcmp(name, "lRightThigh") == 0 ||
+				strcmp(name, "lRightThighStatus") == 0 ||
+				strcmp(name, "lCPack") == 0 ||
+				strcmp(name, "lCPackStatus") == 0 ||
+				strcmp(name, "lBPack") == 0 ||
+				strcmp(name, "lBPackStatus") == 0 ))
+		{
+			pData->curElement = ELEMENT_PROPERTY;
+
+			pData->maxReadDepth++; //we are not skipping this element
+		}
+
+		pData->szCharData[0] = '\0';
+	}
+
+	pData->currentDepth++;
+
+}
+
+static void XMLCALL
+MercStartingGearCharacterDataHandle(void *userData, const XML_Char *str, int len)
+{
+	MercStartingGearParseData * pData = (MercStartingGearParseData *)userData;
+
+	if( (pData->currentDepth <= pData->maxReadDepth) && 
+		(strlen(pData->szCharData) < MAX_CHAR_DATA_LENGTH)
+	  ){
+		strncat(pData->szCharData,str,__min((unsigned int)len,MAX_CHAR_DATA_LENGTH-strlen(pData->szCharData)));
+	  }
+}
+
+
+static void XMLCALL
+MercStartingGearEndElementHandle(void *userData, const XML_Char *name)
+{
+	MercStartingGearParseData * pData = (MercStartingGearParseData *)userData;
+	char temp;
+
+	if(pData->currentDepth <= pData->maxReadDepth) //we're at the end of an element that we've been reading
+	{
+		if(strcmp(name, "MERCGEARLIST") == 0)
+		{
+			pData->curElement = ELEMENT_NONE;
+		}
+		else if(strcmp(name, "MERCGEAR") == 0)
+		{
+			pData->curElement = ELEMENT_LIST;
+
+			if(pData->curMercStartingGear.mIndex < pData->maxArraySize)
+			{
+				pData->curArray[pData->curMercStartingGear.mIndex] = pData->curMercStartingGear; //write the armour into the table
+			}
+		}
+		else if(strcmp(name, "mIndex") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.mIndex   = (UINT16) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mName") == 0)
+		{
+			pData->curElement = ELEMENT;
+			if(MAX_CHAR_DATA_LENGTH >= strlen(pData->szCharData))
+				strcpy(pData->curMercStartingGear.mName,pData->szCharData);
+			else
+			{
+				strncpy(pData->curMercStartingGear.mName,pData->szCharData,MAX_CHAR_DATA_LENGTH);
+				pData->curMercStartingGear.mName[MAX_CHAR_DATA_LENGTH] = '\0';
+			}
+			for(int i=0;i<min((int)strlen(pData->szCharData),MAX_CHAR_DATA_LENGTH);i++)
+			{
+				temp = pData->szCharData[i];
+				pData->curMercStartingGear.mName[i] = temp;
+				//DebugMsg (TOPIC_JA2,DBG_LEVEL_3,String("itemEndElementHandle: itemname[%d] = %s, temp = %s",i,&pData->curItem.szItemName[i],&temp));
+			}
+		}
+		else if(strcmp(name, "mHelmet") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[0]  = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mVest") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[1] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mLeg") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[2] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mWeapon") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[5] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig0") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[7] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig1") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[8] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig2") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[9] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig3") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[10] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall0") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[11] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall1") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[12] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall2") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[13] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall3") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[14] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall4") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[15] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall5") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[16] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall6") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[17] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall7") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.inv[18] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mHelmetStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[0] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mVestStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[1] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mLegStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[2] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mWeaponStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[5] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig0Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[7] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig1Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[8] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig2Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[9] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig3Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[10] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall0Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[11] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall1Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[12] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall2Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[13] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall3Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[14] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall4Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[15] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall5Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[16] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall6Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[17] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall7Status") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iStatus[18] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mHelmetDrop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[0] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mVestDrop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[1] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mLegDrop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[2] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mWeaponDrop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[5] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig0Drop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[7] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig1Drop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[8] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig2Drop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[9] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig3Drop") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iDrop[10] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig0Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[7] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig1Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[8] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig2Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[9] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mBig3Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[10] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall0Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[11] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall1Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[12] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall2Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[13] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall3Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[14] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall4Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[15] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall5Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[16] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall6Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[17] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "mSmall7Quantity") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.iNumber[18] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lVest") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lbe[0] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lLeftThigh") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lbe[1] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lRightThigh") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lbe[2] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lCPack") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lbe[3] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lBPack") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lbe[4] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lVestStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lStatus[0] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lLeftThighStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lStatus[1] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lRightThighStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lStatus[2] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lCPackStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lStatus[3] = (int) atol(pData->szCharData);
+		}
+		else if(strcmp(name, "lBPackStatus") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curMercStartingGear.lStatus[4] = (int) atol(pData->szCharData);
+		}
+
+		pData->maxReadDepth--;
+	}
+
+	pData->currentDepth--;
+}
+
+
+
+
+BOOLEAN ReadInMercStartingGearStats(STR fileName)
+{
+	HWFILE		hFile;
+	UINT32		uiBytesRead;
+	UINT32		uiFSize;
+	CHAR8 *		lpcBuffer;
+	XML_Parser	parser = XML_ParserCreate(NULL);
+	
+	MercStartingGearParseData pData;
+
+	DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Loading MercStartingGear.xml" );
+
+	// Open gMercProfileGear file
+	hFile = FileOpen( fileName, FILE_ACCESS_READ, FALSE );
+	if ( !hFile )
+		return( FALSE );
+	
+	uiFSize = FileGetSize(hFile);
+	lpcBuffer = (CHAR8 *) MemAlloc(uiFSize+1);
+
+	//Read in block
+	if ( !FileRead( hFile, lpcBuffer, uiFSize, &uiBytesRead ) )
+	{
+		MemFree(lpcBuffer);
+		return( FALSE );
+	}
+
+	lpcBuffer[uiFSize] = 0; //add a null terminator
+
+	FileClose( hFile );
+
+	
+	XML_SetElementHandler(parser, MercStartingGearStartElementHandle, MercStartingGearEndElementHandle);
+	XML_SetCharacterDataHandler(parser, MercStartingGearCharacterDataHandle);
+
+	
+	memset(&pData,0,sizeof(pData));
+	pData.curArray = gMercProfileGear;
+	pData.maxArraySize = NUM_PROFILES; 
+	
+	XML_SetUserData(parser, &pData);
+
+
+    if(!XML_Parse(parser, lpcBuffer, uiFSize, TRUE))
+	{
+		CHAR8 errorBuf[511];
+
+		sprintf(errorBuf, "XML Parser Error in MercStartingGear.xml: %s at line %d", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser));
+		LiveMessage(errorBuf);
+
+		MemFree(lpcBuffer);
+		return FALSE;
+	}
+
+	MemFree(lpcBuffer);
+
+
+	XML_ParserFree(parser);
+
+
+	return( TRUE );
+}
+BOOLEAN WriteMercStartingGearStats()
+{
+	//DebugMsg (TOPIC_JA2,DBG_LEVEL_3,"writemercstartinggearstats");
+	HWFILE		hFile;
+
+	//Debug code; make sure that what we got from the file is the same as what's there
+	// Open a new file
+	hFile = FileOpen( "TABLEDATA\\MercStartingGear out.xml", FILE_ACCESS_WRITE | FILE_CREATE_ALWAYS, FALSE );
+	if ( !hFile )
+		return( FALSE );
+	
+	{
+		UINT32 cnt;
+		CHAR16 str[100];
+
+		FilePrintf(hFile,"<MERCGEARLIST>\r\n");
+		for(cnt = 0;cnt < NUM_PROFILES;cnt++)
+		{
+
+			FilePrintf(hFile,"\t<MERCGEAR>\r\n");
+
+			FilePrintf(hFile,"\t\t<mIndex>%d</mIndex>\r\n",								cnt );
+//			FilePrintf(hFile,"\t\t<mName>%d</mName>\r\n",								gMercProfileGear[cnt].mName  );
+
+			
+			int j = -1;
+			for (int i=0;i<80;i++)
+			{
+				j++;
+				if ( i<(int)strlen(gMercProfileGear[cnt].mName))
+				{
+					str[i] = gMercProfileGear[cnt].mName [j];
+				}
+				else
+				{
+					str[i] ='\0';
+				}
+			}
+			STR16 szRemainder = str;
+			FilePrintf(hFile,"\t\t<mName>");
+			while(szRemainder[0] != '\0')
+			{
+				UINT32 uiCharLoc = wcscspn(szRemainder, L"&<>\'\"\0");
+				CHAR16 invChar = szRemainder[uiCharLoc];
+				
+				if(uiCharLoc)
+				{
+					szRemainder[uiCharLoc] = '\0';
+					FilePrintf(hFile,"%S",szRemainder);
+					szRemainder[uiCharLoc] = invChar;
+				}
+
+				szRemainder += uiCharLoc;
+
+				switch(invChar)
+				{
+					case '&':
+						FilePrintf(hFile,"&amp;");
+						szRemainder++;
+					break;
+
+					case '<':
+						FilePrintf(hFile,"&lt;");
+						szRemainder++;
+					break;
+
+					case '>':
+						FilePrintf(hFile,"&gt;");
+						szRemainder++;
+					break;
+
+					case '\'':
+						FilePrintf(hFile,"&apos;");
+						szRemainder++;
+					break;
+
+					case '\"':
+						FilePrintf(hFile,"&quot;");
+						szRemainder++;
+					break;
+				}
+			}
+			FilePrintf(hFile,"</mName>\r\n");
+			FilePrintf(hFile,"\t\t<mHelmet>%d</mHelmet>\r\n",						gMercProfileGear[cnt].inv[0]  );
+			FilePrintf(hFile,"\t\t<mVest>%d</mVest>\r\n",							gMercProfileGear[cnt].inv[1]   );
+			FilePrintf(hFile,"\t\t<mLeg>%d</mLeg>\r\n",								gMercProfileGear[cnt].inv[2]   );
+			FilePrintf(hFile,"\t\t<mWeapon>%d</mWeapon>\r\n",						gMercProfileGear[cnt].inv[5]   );
+			FilePrintf(hFile,"\t\t<mHelmetStatus>%d</mHelmetStatus>\r\n",			gMercProfileGear[cnt].iStatus[0]   );
+			FilePrintf(hFile,"\t\t<mVestStatus>%d</mVestStatus>\r\n",				gMercProfileGear[cnt].iStatus[1]   );
+			FilePrintf(hFile,"\t\t<mLegStatus>%d</mLegStatus>\r\n",					gMercProfileGear[cnt].iStatus[2]   );
+			FilePrintf(hFile,"\t\t<mWeaponStatus>%d</mWeaponStatus>\r\n",			gMercProfileGear[cnt].iStatus[5]   );
+			FilePrintf(hFile,"\t\t<mHelmetDrop>%d</mHelmetDrop>\r\n",				gMercProfileGear[cnt].iDrop[0]   );
+			FilePrintf(hFile,"\t\t<mVestDrop>%d</mVestDrop>\r\n",					gMercProfileGear[cnt].iDrop[1]   );
+			FilePrintf(hFile,"\t\t<mLegDrop>%d</mLegDrop>\r\n",						gMercProfileGear[cnt].iDrop[2]   );
+			FilePrintf(hFile,"\t\t<mWeaponDrop>%d</mWeaponDrop>\r\n",				gMercProfileGear[cnt].iDrop[5]   );
+			FilePrintf(hFile,"\t\t<mBig0>%d</mBig0>\r\n",							gMercProfileGear[cnt].inv[7]   );
+			FilePrintf(hFile,"\t\t<mBig1>%d</mBig1>\r\n",							gMercProfileGear[cnt].inv[8]   );
+			FilePrintf(hFile,"\t\t<mBig2>%d</mBig2>\r\n",							gMercProfileGear[cnt].inv[9]   );
+			FilePrintf(hFile,"\t\t<mBig3>%d</mBig3>\r\n",							gMercProfileGear[cnt].inv[10]   );
+			FilePrintf(hFile,"\t\t<mBig0Quantity>%d</mBig0Quantity>\r\n",			gMercProfileGear[cnt].iNumber[7]   );
+			FilePrintf(hFile,"\t\t<mBig1Quantity>%d</mBig1Quantity>\r\n",			gMercProfileGear[cnt].iNumber[8]   );
+			FilePrintf(hFile,"\t\t<mBig2Quantity>%d</mBig2Quantity>\r\n",			gMercProfileGear[cnt].iNumber[9]   );
+			FilePrintf(hFile,"\t\t<mBig3Quantity>%d</mBig3Quantity>\r\n",			gMercProfileGear[cnt].iNumber[10]   );
+			FilePrintf(hFile,"\t\t<mBig0Status>%d</mBig0Status>\r\n",				gMercProfileGear[cnt].iStatus[7]   );
+			FilePrintf(hFile,"\t\t<mBig1Status>%d</mBig1Status>\r\n",				gMercProfileGear[cnt].iStatus[8]   );
+			FilePrintf(hFile,"\t\t<mBig2Status>%d</mBig2Status>\r\n",				gMercProfileGear[cnt].iStatus[9]   );
+			FilePrintf(hFile,"\t\t<mBig3Status>%d</mBig3Status>\r\n",				gMercProfileGear[cnt].iStatus[10]   );
+			FilePrintf(hFile,"\t\t<mBig0Drop>%d</mBig0Drop>\r\n",					gMercProfileGear[cnt].iDrop[7]   );
+			FilePrintf(hFile,"\t\t<mBig1Drop>%d</mBig1Drop>\r\n",					gMercProfileGear[cnt].iDrop[8]   );
+			FilePrintf(hFile,"\t\t<mBig2Drop>%d</mBig2Drop>\r\n",					gMercProfileGear[cnt].iDrop[9]   );
+			FilePrintf(hFile,"\t\t<mBig3Drop>%d</mBig3Drop>\r\n",					gMercProfileGear[cnt].iDrop[10]   );
+			FilePrintf(hFile,"\t\t<mSmall0>%d</mSmall0>\r\n",						gMercProfileGear[cnt].inv[11]   );
+			FilePrintf(hFile,"\t\t<mSmall1>%d</mSmall1>\r\n",						gMercProfileGear[cnt].inv[12]   );
+			FilePrintf(hFile,"\t\t<mSmall2>%d</mSmall2>\r\n",						gMercProfileGear[cnt].inv[13]   );
+			FilePrintf(hFile,"\t\t<mSmall3>%d</mSmall3>\r\n",						gMercProfileGear[cnt].inv[14]   );
+			FilePrintf(hFile,"\t\t<mSmall4>%d</mSmall4>\r\n",						gMercProfileGear[cnt].inv[15]   );
+			FilePrintf(hFile,"\t\t<mSmall5>%d</mSmall5>\r\n",						gMercProfileGear[cnt].inv[16]   );
+			FilePrintf(hFile,"\t\t<mSmall6>%d</mSmall6>\r\n",						gMercProfileGear[cnt].inv[17]   );
+			FilePrintf(hFile,"\t\t<mSmall7>%d</mSmall7>\r\n",						gMercProfileGear[cnt].inv[18]   );
+			FilePrintf(hFile,"\t\t<mSmall0Quantity>%d</mSmall0Quantity>\r\n",		gMercProfileGear[cnt].iNumber[11]   );
+			FilePrintf(hFile,"\t\t<mSmall1Quantity>%d</mSmall1Quantity>\r\n",		gMercProfileGear[cnt].iNumber[12]   );
+			FilePrintf(hFile,"\t\t<mSmall2Quantity>%d</mSmall2Quantity>\r\n",		gMercProfileGear[cnt].iNumber[13]   );
+			FilePrintf(hFile,"\t\t<mSmall3Quantity>%d</mSmall3Quantity>\r\n",		gMercProfileGear[cnt].iNumber[14]   );
+			FilePrintf(hFile,"\t\t<mSmall4Quantity>%d</mSmall4Quantity>\r\n",		gMercProfileGear[cnt].iNumber[15]   );
+			FilePrintf(hFile,"\t\t<mSmall5Quantity>%d</mSmall5Quantity>\r\n",		gMercProfileGear[cnt].iNumber[16]   );
+			FilePrintf(hFile,"\t\t<mSmall6Quantity>%d</mSmall6Quantity>\r\n",		gMercProfileGear[cnt].iNumber[17]   );
+			FilePrintf(hFile,"\t\t<mSmall7Quantity>%d</mSmall7Quantity>\r\n",		gMercProfileGear[cnt].iNumber[18]   );
+			FilePrintf(hFile,"\t\t<mSmall0Status>%d</mSmall0Status>\r\n",			gMercProfileGear[cnt].iStatus[11]   );
+			FilePrintf(hFile,"\t\t<mSmall1Status>%d</mSmall1Status>\r\n",			gMercProfileGear[cnt].iStatus[12]   );
+			FilePrintf(hFile,"\t\t<mSmall2Status>%d</mSmall2Status>\r\n",			gMercProfileGear[cnt].iStatus[13]   );
+			FilePrintf(hFile,"\t\t<mSmall3Status>%d</mSmall3Status>\r\n",			gMercProfileGear[cnt].iStatus[14]   );
+			FilePrintf(hFile,"\t\t<mSmall4Status>%d</mSmall4Status>\r\n",			gMercProfileGear[cnt].iStatus[15]   );
+			FilePrintf(hFile,"\t\t<mSmall5Status>%d</mSmall5Status>\r\n",			gMercProfileGear[cnt].iStatus[16]   );
+			FilePrintf(hFile,"\t\t<mSmall6Status>%d</mSmall6Status>\r\n",			gMercProfileGear[cnt].iStatus[17]   );
+			FilePrintf(hFile,"\t\t<mSmall7Status>%d</mSmall7Status>\r\n",			gMercProfileGear[cnt].iStatus[18]   );
+			FilePrintf(hFile,"\t\t<lVest>%d</lVest>\r\n",							gMercProfileGear[cnt].lbe[0]   );
+			FilePrintf(hFile,"\t\t<lLeftThigh>%d</lLeftThigh>\r\n",					gMercProfileGear[cnt].lbe[1]   );
+			FilePrintf(hFile,"\t\t<lRightThigh>%d</lRightThigh>\r\n",				gMercProfileGear[cnt].lbe[2]   );
+			FilePrintf(hFile,"\t\t<lCPack>%d</lCPack>\r\n",							gMercProfileGear[cnt].lbe[3]   );
+			FilePrintf(hFile,"\t\t<lBPack>%d</lBPack>\r\n",							gMercProfileGear[cnt].lbe[4]   );
+			FilePrintf(hFile,"\t\t<lVestStatus>%d</lVestStatus>\r\n",				gMercProfileGear[cnt].lStatus[0]   );
+			FilePrintf(hFile,"\t\t<lLeftThighStatus>%d</lLeftThighStatus>\r\n",		gMercProfileGear[cnt].lStatus[1]   );
+			FilePrintf(hFile,"\t\t<lRightThighStatus>%d</lRightThighStatus>\r\n",	gMercProfileGear[cnt].lStatus[2]   );
+			FilePrintf(hFile,"\t\t<lCPackStatus>%d</lCPackStatus>\r\n",				gMercProfileGear[cnt].lStatus[3]   );
+			FilePrintf(hFile,"\t\t<lBPackStatus>%d</lBPackStatus>\r\n",				gMercProfileGear[cnt].lStatus[4]   );
+
+			FilePrintf(hFile,"\t</MERCGEAR>\r\n");
+		}
+		FilePrintf(hFile,"</MERCGEARLIST>\r\n");
+	}
+	FileClose( hFile );
+
+	return( TRUE );
+}
Index: TacticalAI/AIUtils.cpp
===================================================================
--- TacticalAI/AIUtils.cpp	(revision 1299)
+++ TacticalAI/AIUtils.cpp	(working copy)
@@ -2336,15 +2336,18 @@
 	if (Item[pSoldier->inv[bSlot].usItem].ubPerPocket == 0)
 	{
 		// then we're looking for a big pocket
-		bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, BIGPOCK4POS );
+		// CHRISL: Adjust final parameter to use dynamic inventory endpoint
+		bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, (BIGPOCKFINAL-1) );
 	}
 	else
 	{
 		// try a small pocket first
-		bSlot = FindEmptySlotWithin( pSoldier, SMALLPOCK1POS, SMALLPOCK8POS );
+		// CHRISL: Adjust final parameter to use dynamic inventory endpoint
+		bSlot = FindEmptySlotWithin( pSoldier, SMALLPOCK1POS, (NUM_INV_SLOTS-1) );
 		if (bSlot == NO_SLOT)
 		{
-			bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, BIGPOCK4POS );
+			// CHRISL: Adjust final parameter to use dynamic inventory endpoint
+			bSlot = FindEmptySlotWithin( pSoldier, BIGPOCK1POS, (BIGPOCKFINAL-1) );
 		}
 	}
 	if (bSlot == NO_SLOT)
Index: TacticalAI/Attacks.cpp
===================================================================
--- TacticalAI/Attacks.cpp	(revision 1299)
+++ TacticalAI/Attacks.cpp	(working copy)
@@ -2004,7 +2004,8 @@
 			if ( (Item[ pSoldier->inv[ HANDPOS ].usItem ].usItemClass == IC_GUN) && !(Item[ pSoldier->inv[ HANDPOS ].usItem ].twohanded ) )
 			{
 				// look for another pistol/SMG if available
-				bWeaponIn = FindAIUsableObjClassWithin( pSoldier, IC_WEAPON, BIGPOCK1POS, SMALLPOCK8POS );
+				// CHRISL: Change final parameter to use dynamic pocket definition
+				bWeaponIn = FindAIUsableObjClassWithin( pSoldier, IC_WEAPON, BIGPOCK1POS, (NUM_INV_SLOTS-1) );
 				//				if (bWeaponIn != NO_SLOT && (Item[ pSoldier->inv[ bWeaponIn ].usItem ].usItemClass == IC_GUN) && !(Item[ pSoldier->inv[ bWeaponIn ].usItem ].fFlags & ITEM_TWO_HANDED ) )
 				if (bWeaponIn != NO_SLOT && (Item[ pSoldier->inv[ bWeaponIn ].usItem ].usItemClass == IC_GUN) && !(Item[ pSoldier->inv[ bWeaponIn ].usItem ].twohanded ) )
 				{
Index: TacticalAI/DecideAction.cpp
===================================================================
--- TacticalAI/DecideAction.cpp	(revision 1299)
+++ TacticalAI/DecideAction.cpp	(working copy)
@@ -4035,7 +4035,8 @@
 		if ( ( ubBestAttackAction == AI_ACTION_NONE ) && fTryPunching )
 		{
 			// nothing (else) to attack with so let's try hand-to-hand
-			bWeaponIn = FindObjWithin( pSoldier, NOTHING, HANDPOS, SMALLPOCK8POS );
+		 // CHRISL: Change final parameter to use dynamic setting
+		 bWeaponIn = FindObjWithin( pSoldier, NOTHING, HANDPOS, (NUM_INV_SLOTS-1) );
 
 			if (bWeaponIn != NO_SLOT)
 			{
Index: TileEngine/Radar Screen.cpp
===================================================================
--- TileEngine/Radar Screen.cpp	(revision 1299)
+++ TileEngine/Radar Screen.cpp	(working copy)
@@ -62,6 +62,15 @@
 BOOLEAN		fImageLoaded = FALSE;
 BOOLEAN   fRenderRadarScreen = TRUE;
 INT16			sSelectedSquadLine = -1;
+// CHRISL: Moved radar coords from header file
+INT16	RADAR_WINDOW_TM_X;
+INT16	RADAR_WINDOW_SM_X;
+INT16	RADAR_WINDOW_TM_Y;
+INT16	RADAR_WINDOW_SM_Y;
+INT16	RADAR_WINDOW_WIDTH;
+INT16	RADAR_WINDOW_HEIGHT;
+INT16	RADAR_WINDOW_STRAT_X;
+INT16	RADAR_WINDOW_STRAT_Y;
 
 BOOLEAN		gfRadarCurrentGuyFlash = FALSE;
 
@@ -73,11 +82,25 @@
 
 MOUSE_REGION gRadarRegionSquadList[ NUMBER_OF_SQUADS ];
 
+void InitRadarScreenCoords( )
+{
+		RADAR_WINDOW_TM_X = (SCREEN_WIDTH - 97);
+		RADAR_WINDOW_SM_X = (SCREEN_WIDTH - 97);
+		RADAR_WINDOW_TM_Y = (INTERFACE_START_Y + 13);
+		RADAR_WINDOW_SM_Y = (!gGameOptions.ubInventorySystem) ? (INV_INTERFACE_START_Y + 33) : (INV_INTERFACE_START_Y + 116);
+		RADAR_WINDOW_WIDTH = 88;
+		RADAR_WINDOW_HEIGHT = 44;
+		RADAR_WINDOW_STRAT_X = (SCREEN_WIDTH - 97);
+		RADAR_WINDOW_STRAT_Y = (SCREEN_HEIGHT - 107);
+}
+
 BOOLEAN InitRadarScreen( )
 {
 		// Add region for radar
-		MSYS_DefineRegion( &gRadarRegion, RADAR_WINDOW_X, RADAR_WINDOW_TM_Y, 
-											 RADAR_WINDOW_X + RADAR_WINDOW_WIDTH,
+		// CHRISL: Move screen coord setup to it's own function
+		InitRadarScreenCoords();
+		MSYS_DefineRegion( &gRadarRegion, RADAR_WINDOW_TM_X, RADAR_WINDOW_TM_Y, 
+											 RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH,
 											 RADAR_WINDOW_TM_Y + RADAR_WINDOW_HEIGHT,
 											 MSYS_PRIORITY_HIGHEST, 0, 
 											 RadarRegionMoveCallback,
@@ -89,7 +112,7 @@
 		//disable the radar map
 		MSYS_DisableRegion(&gRadarRegion);
 
-		gsRadarX = RADAR_WINDOW_X;
+		gsRadarX = RADAR_WINDOW_TM_X;
 		gsRadarY = RADAR_WINDOW_TM_Y;
 
 		return( TRUE );
@@ -173,23 +196,29 @@
 
 	// Add new one
 
-		// Move based on inventory panel
+	// CHRISL: Reset coords
+	InitRadarScreenCoords();
+	// Move based on inventory panel
 	if( guiCurrentScreen == MAP_SCREEN )
 	{
+		gsRadarX = RADAR_WINDOW_STRAT_X;
 		gsRadarY = RADAR_WINDOW_STRAT_Y;
 	}
 	else if ( gsCurInterfacePanel == SM_PANEL )
 	{
-		gsRadarY = RADAR_WINDOW_TM_Y;
+		gsRadarX = RADAR_WINDOW_SM_X;
+		gsRadarY = RADAR_WINDOW_SM_Y;
 	}
 	else
 	{
+		gsRadarX = RADAR_WINDOW_TM_X;
 		gsRadarY = RADAR_WINDOW_TM_Y;
 	}
 
 	// Add region for radar
-	MSYS_DefineRegion( &gRadarRegion, RADAR_WINDOW_X, (UINT16)(gsRadarY), 
-										 RADAR_WINDOW_X + RADAR_WINDOW_WIDTH,
+	// CHRISL:
+	MSYS_DefineRegion( &gRadarRegion, (UINT16) (gsRadarX), (UINT16)(gsRadarY), 
+										 (UINT16) (gsRadarX + RADAR_WINDOW_WIDTH),
 										 (UINT16)(gsRadarY + RADAR_WINDOW_HEIGHT),
 										 MSYS_PRIORITY_HIGHEST, 0, 
 										 RadarRegionMoveCallback,
@@ -350,11 +379,13 @@
 			}
 		}
 
-		BltVideoObjectFromIndex(  guiSAVEBUFFER, gusRadarImage, 0, RADAR_WINDOW_X, gsRadarY, VO_BLT_SRCTRANSPARENCY, NULL );
+		// CHRISL:
+		BltVideoObjectFromIndex(  guiSAVEBUFFER, gusRadarImage, 0, gsRadarX, gsRadarY, VO_BLT_SRCTRANSPARENCY, NULL );
 	}
 
 	// FIRST DELETE WHAT'S THERE
-	RestoreExternBackgroundRect( RADAR_WINDOW_X, gsRadarY, RADAR_WINDOW_WIDTH + 1 , RADAR_WINDOW_HEIGHT + 1 );
+	// CHRISL:
+	RestoreExternBackgroundRect( gsRadarX, gsRadarY, RADAR_WINDOW_WIDTH + 1 , RADAR_WINDOW_HEIGHT + 1 );
 
 	// Determine scale factors
 
@@ -394,7 +425,7 @@
 
 	sWidth		= ( RADAR_WINDOW_WIDTH );
 	sHeight		= ( RADAR_WINDOW_HEIGHT );
-	sX				= RADAR_WINDOW_X;
+	sX				= gsRadarX;
 	sY				= gsRadarY;
 
 
@@ -419,7 +450,8 @@
 
 	pDestBuf = LockVideoSurface( FRAME_BUFFER, &uiDestPitchBYTES );
 	
-	SetClippingRegionAndImageWidth( uiDestPitchBYTES, RADAR_WINDOW_X, gsRadarY, ( RADAR_WINDOW_X + RADAR_WINDOW_WIDTH - 1 ), ( gsRadarY + RADAR_WINDOW_HEIGHT - 1 ) );
+	// CHRISL:
+	SetClippingRegionAndImageWidth( uiDestPitchBYTES, gsRadarX, gsRadarY, ( gsRadarX + RADAR_WINDOW_WIDTH - 1 ), ( gsRadarY + RADAR_WINDOW_HEIGHT - 1 ) );
 
 	if( !( guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN ) )
 	{
@@ -428,8 +460,8 @@
 			// WANNE: Correct radar rectangle size if it is too large to fit in radar screen [2007-05-14]
 			if (fAllowRadarMovementHor == FALSE)
 			{
-				sRadarTLX = RADAR_WINDOW_X;
-				sRadarBRX = RADAR_WINDOW_X + RADAR_WINDOW_WIDTH;
+				sRadarTLX = RADAR_WINDOW_TM_X;
+				sRadarBRX = RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH;
 			}
 
 			if (fAllowRadarMovementVer == FALSE)
@@ -483,7 +515,7 @@
 
 
 			// Add starting relative to interface
-			sXSoldRadar += RADAR_WINDOW_X;
+			sXSoldRadar += gsRadarX;
 			sYSoldRadar += gsRadarY;
 
 			// if we are in 16 bit mode....kind of redundant
@@ -549,7 +581,7 @@
 				}
 
 				// Add starting relative to interface
-				sXSoldRadar += RADAR_WINDOW_X;
+				sXSoldRadar += gsRadarX;
 				sYSoldRadar += gsRadarY;
 
 
@@ -616,8 +648,9 @@
 
 	if( ( guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN ) && ( fShowMapInventoryPool == TRUE ) )
 	{
-		InvalidateRegion( RADAR_WINDOW_X, gsRadarY,
-										RADAR_WINDOW_X + RADAR_WINDOW_WIDTH,
+		// CHRISL:
+		InvalidateRegion( gsRadarX, gsRadarY,
+										gsRadarX + RADAR_WINDOW_WIDTH,
 										gsRadarY + RADAR_WINDOW_HEIGHT );
 	}
 
@@ -716,14 +749,16 @@
 			{
 
 				// left half of list
-				MSYS_DefineRegion( &gRadarRegionSquadList[ sCounter ], RADAR_WINDOW_X , ( INT16 )( SQUAD_WINDOW_TM_Y + ( sCounter * (  ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / ( NUMBER_OF_SQUADS / 2 ) ) ) ), RADAR_WINDOW_X + RADAR_WINDOW_WIDTH / 2 - 1, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( sCounter + 1 ) * ( ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / ( NUMBER_OF_SQUADS / 2 ) ) ) ) ,MSYS_PRIORITY_HIGHEST,
+				// CHRISL:
+				MSYS_DefineRegion( &gRadarRegionSquadList[ sCounter ], RADAR_WINDOW_TM_X , ( INT16 )( SQUAD_WINDOW_TM_Y + ( sCounter * (  ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / ( NUMBER_OF_SQUADS / 2 ) ) ) ), RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH / 2 - 1, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( sCounter + 1 ) * ( ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / ( NUMBER_OF_SQUADS / 2 ) ) ) ) ,MSYS_PRIORITY_HIGHEST,
 							0, TacticalSquadListMvtCallback, TacticalSquadListBtnCallBack );
 			}
 			else
 			{
 
 				// right half of list
-				MSYS_DefineRegion( &gRadarRegionSquadList[ sCounter ], RADAR_WINDOW_X + RADAR_WINDOW_WIDTH / 2, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( sCounter - ( NUMBER_OF_SQUADS / 2) ) * ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), RADAR_WINDOW_X + RADAR_WINDOW_WIDTH  - 1, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( ( sCounter + 1 ) - ( NUMBER_OF_SQUADS / 2) )* ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), MSYS_PRIORITY_HIGHEST,
+				// CHRISL:
+				MSYS_DefineRegion( &gRadarRegionSquadList[ sCounter ], RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH / 2, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( sCounter - ( NUMBER_OF_SQUADS / 2) ) * ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH  - 1, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( ( sCounter + 1 ) - ( NUMBER_OF_SQUADS / 2) )* ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), MSYS_PRIORITY_HIGHEST,
 						0, TacticalSquadListMvtCallback, TacticalSquadListBtnCallBack );
 			}
 
@@ -782,10 +817,12 @@
 	INT16 sX, sY;
 
 	// clear region
-	RestoreExternBackgroundRect( RADAR_WINDOW_X, gsRadarY, RADAR_WINDOW_WIDTH , SQUAD_REGION_HEIGHT );
+	// CHRISL:
+	RestoreExternBackgroundRect( gsRadarX, gsRadarY, RADAR_WINDOW_WIDTH , SQUAD_REGION_HEIGHT );
 
 	// fill area
-	ColorFillVideoSurfaceArea( FRAME_BUFFER, RADAR_WINDOW_X, RADAR_WINDOW_TM_Y, RADAR_WINDOW_X + RADAR_WINDOW_WIDTH, RADAR_WINDOW_TM_Y + SQUAD_REGION_HEIGHT , Get16BPPColor( FROMRGB(0,0,0) ) );
+	// CHRISL:
+	ColorFillVideoSurfaceArea( FRAME_BUFFER, RADAR_WINDOW_TM_X, RADAR_WINDOW_TM_Y, RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH, RADAR_WINDOW_TM_Y + SQUAD_REGION_HEIGHT , Get16BPPColor( FROMRGB(0,0,0) ) );
 
 	// set font
 	SetFont( SQUAD_FONT );
@@ -795,11 +832,13 @@
 		// run through list of squads and place appropriatly
 			if( sCounter < NUMBER_OF_SQUADS / 2 )
 			{
-				FindFontCenterCoordinates( RADAR_WINDOW_X , ( INT16 )( SQUAD_WINDOW_TM_Y + ( sCounter * ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), RADAR_WINDOW_WIDTH / 2 - 1, ( INT16 )( (  ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ) ,pSquadMenuStrings[ sCounter ] , SQUAD_FONT, &sX, &sY);
+				// CHRISL:
+				FindFontCenterCoordinates( RADAR_WINDOW_TM_X , ( INT16 )( SQUAD_WINDOW_TM_Y + ( sCounter * ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), RADAR_WINDOW_WIDTH / 2 - 1, ( INT16 )( (  ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ) ,pSquadMenuStrings[ sCounter ] , SQUAD_FONT, &sX, &sY);
 			}
 			else
 			{
-				FindFontCenterCoordinates(RADAR_WINDOW_X + RADAR_WINDOW_WIDTH / 2, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( sCounter - ( NUMBER_OF_SQUADS / 2) ) * ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), RADAR_WINDOW_WIDTH / 2 - 1, ( INT16 )(   ( ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), pSquadMenuStrings[ sCounter ] , SQUAD_FONT, &sX, &sY);
+				// CHRISL:
+				FindFontCenterCoordinates(RADAR_WINDOW_TM_X + RADAR_WINDOW_WIDTH / 2, ( INT16 )( SQUAD_WINDOW_TM_Y + ( ( sCounter - ( NUMBER_OF_SQUADS / 2) ) * ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), RADAR_WINDOW_WIDTH / 2 - 1, ( INT16 )(   ( ( 2 * ( SQUAD_REGION_HEIGHT - SUBTRACTOR_FOR_SQUAD_LIST ) / NUMBER_OF_SQUADS ) ) ), pSquadMenuStrings[ sCounter ] , SQUAD_FONT, &sX, &sY);
 			}
 
 			// highlight line?
@@ -830,11 +869,11 @@
 
 			if( sCounter < NUMBER_OF_SQUADS / 2 )
 			{
-				sX = RADAR_WINDOW_X + 2; 
+				sX = RADAR_WINDOW_TM_X + 2; 
 			}
 			else
 			{
-				sX = RADAR_WINDOW_X + ( RADAR_WINDOW_WIDTH / 2 ) - 2;
+				sX = RADAR_WINDOW_TM_X + ( RADAR_WINDOW_WIDTH / 2 ) - 2;
 			}
 			mprintf( sX, sY , pSquadMenuStrings[ sCounter ]);
 	}
@@ -884,4 +923,4 @@
 	}
 
 	return;
-}
\ No newline at end of file
+}
Index: TileEngine/Radar Screen.h
===================================================================
--- TileEngine/Radar Screen.h	(revision 1299)
+++ TileEngine/Radar Screen.h	(working copy)
@@ -2,6 +2,7 @@
 #define __RADAR_SCREEN_H
 
 #include "interface.h"
+#include "gamesettings.h"
 
 // RADAR MOUSE REGION STUFF
 void RadarRegionMoveCallback( MOUSE_REGION * pRegion, INT32 iReason );
@@ -9,15 +10,19 @@
 
 BOOLEAN LoadRadarScreenBitmap( CHAR8 * aFilename );
 
+// CHRISL: Changed radar coord defines to standard variables and moved definition to radar screen.cpp
 // RADAR WINDOW DEFINES
-#define	RADAR_WINDOW_X				(SCREEN_WIDTH - 97)				//543
-#define RADAR_WINDOW_TM_Y				INTERFACE_START_Y + 13
-#define RADAR_WINDOW_SM_Y				INV_INTERFACE_START_Y + 13
-#define RADAR_WINDOW_WIDTH		88
-#define RADAR_WINDOW_HEIGHT		44
-#define RADAR_WINDOW_STRAT_Y		(SCREEN_HEIGHT - 107)	//373
+extern INT16	RADAR_WINDOW_TM_X;
+extern INT16	RADAR_WINDOW_SM_X;
+extern INT16	RADAR_WINDOW_TM_Y;
+extern INT16	RADAR_WINDOW_SM_Y;
+extern INT16	RADAR_WINDOW_WIDTH;
+extern INT16	RADAR_WINDOW_HEIGHT;
+extern INT16	RADAR_WINDOW_STRAT_X;
+extern INT16	RADAR_WINDOW_STRAT_Y;
 
 BOOLEAN InitRadarScreen( );
+void InitRadarScreenCoords( );
 void RenderRadarScreen( );
 void MoveRadarScreen( );
 
@@ -39,4 +44,4 @@
 // do we render the radar screen?..or the squad list?
 extern BOOLEAN   fRenderRadarScreen;
 
-#endif
\ No newline at end of file
+#endif
Index: TileEngine/renderworld.cpp
===================================================================
--- TileEngine/renderworld.cpp	(revision 1299)
+++ TileEngine/renderworld.cpp	(working copy)
@@ -3969,6 +3969,8 @@
 	INT16 sRadarBRX, sRadarBRY;
 	INT16 sRadarCX, sRadarCY;
 	INT16 sHeight, sWidth, sX, sY;
+	// CHRISL:
+	INT16			gsRadarX;
 	INT16			gsRadarY;
 	BOOLEAN			fAllowScrollingHorizontal = FALSE;
 	BOOLEAN			fAllowScrollingVertical = FALSE;
@@ -4024,21 +4026,24 @@
 
 	if( guiCurrentScreen == MAP_SCREEN )
 	{
+		gsRadarX = RADAR_WINDOW_STRAT_X;
 		gsRadarY = RADAR_WINDOW_STRAT_Y;
 	}
 	else if ( gsCurInterfacePanel == SM_PANEL )
 	{
-		gsRadarY = RADAR_WINDOW_TM_Y;
+		gsRadarX = RADAR_WINDOW_SM_X;
+		gsRadarY = RADAR_WINDOW_SM_Y;
 	}
 	else
 	{
+		gsRadarX = RADAR_WINDOW_TM_X;
 		gsRadarY = RADAR_WINDOW_TM_Y;
 	}
 
 
 	sWidth		= ( RADAR_WINDOW_WIDTH );
 	sHeight		= ( RADAR_WINDOW_HEIGHT );
-	sX				= RADAR_WINDOW_X;
+	sX				= gsRadarX;
 	sY				= gsRadarY;
 
 
Index: TileEngine/Tile Animation.h
===================================================================
--- TileEngine/Tile Animation.h	(revision 1299)
+++ TileEngine/Tile Animation.h	(working copy)
@@ -36,6 +36,8 @@
 #define ANI_TOPMOST_LEVEL				7
 
 
+// WDS Change
+struct LEVELNODE;
 typedef struct TAG_anitile
 {
 	struct TAG_anitile			 	  *pNext;
Index: Utils/_DutchText.cpp
===================================================================
--- Utils/_DutchText.cpp	(revision 1299)
+++ Utils/_DutchText.cpp	(working copy)
@@ -2860,6 +2860,7 @@
 	L"Med. Kits",
 	L"Kits",
 	L"Face Items",
+	L"LBE Gear",
 	L"Misc.",
 };
 
Index: Utils/_EnglishText.cpp
===================================================================
--- Utils/_EnglishText.cpp	(revision 1299)
+++ Utils/_EnglishText.cpp	(working copy)
@@ -2861,6 +2861,7 @@
 	L"Med. Kits",
 	L"Kits",
 	L"Face Items",
+	L"LBE Gear",
 	L"Misc.",
 };
 
@@ -3605,6 +3606,9 @@
 	L"Great",
 	L"Excellent",
 	L"Awesome",
+	L"Inventory System",
+	L"Old",
+	L"New",
 };
 
 STR16 pDeliveryLocationStrings[] =
Index: Utils/_FrenchText.cpp
===================================================================
--- Utils/_FrenchText.cpp	(revision 1299)
+++ Utils/_FrenchText.cpp	(working copy)
@@ -2849,6 +2849,7 @@
 	L"Med. Kits",
 	L"Kits",
 	L"Face Items",
+	L"LBE Gear",
 	L"Misc.",
 };
 
Index: Utils/_GermanText.cpp
===================================================================
--- Utils/_GermanText.cpp	(revision 1299)
+++ Utils/_GermanText.cpp	(working copy)
@@ -2719,6 +2719,7 @@
 	L"Verbandsk.",
 	L"Taschen",
 	L"Gesicht G.",
+	L"LBE Gear",
 	L"Sonstiges",
 };
 
Index: Utils/_ItalianText.cpp
===================================================================
--- Utils/_ItalianText.cpp	(revision 1299)
+++ Utils/_ItalianText.cpp	(working copy)
@@ -2843,6 +2843,7 @@
 	L"Med. Kits",
 	L"Kits",
 	L"Face Items",
+	L"LBE Gear",
 	L"Misc.",
 };
 
Index: Utils/_PolishText.cpp
===================================================================
--- Utils/_PolishText.cpp	(revision 1299)
+++ Utils/_PolishText.cpp	(working copy)
@@ -2842,6 +2842,7 @@
 	L"Med. Kits",
 	L"Kits",
 	L"Face Items",
+	L"LBE Gear",
 	L"Misc.",
 };
 
Index: Utils/_RussianText.cpp
===================================================================
--- Utils/_RussianText.cpp	(revision 1299)
+++ Utils/_RussianText.cpp	(working copy)
@@ -2857,6 +2857,7 @@
 	L"Med. Kits",
 	L"Kits",
 	L"Face Items",
+	L"LBE Gear",
 	L"Misc.",
 };
 
Index: Utils/message.cpp
===================================================================
--- Utils/message.cpp	(revision 1299)
+++ Utils/message.cpp	(working copy)
@@ -23,6 +23,7 @@
 	#include "Dialogue Control.h"
 	#include <stdio.h>
 	#include "Game Clock.h"
+	#include "GameSettings.h"
 #endif
 
 typedef struct 
@@ -360,7 +361,7 @@
 	INT32 iMaxAge = 0;
 	BOOLEAN fDitchLastMessage = FALSE;
 
-	INT32 iMsgYStart = SCREEN_HEIGHT - 150;
+	INT32 iMsgYStart = (!gGameOptions.ubInventorySystem) ? SCREEN_HEIGHT - 150 : SCREEN_HEIGHT - 210;
 
 	// UPDATE TIMER
 	suiTimer=GetJA2Clock();
@@ -1089,6 +1090,9 @@
 
 	//SetFontDestBuffer( FRAME_BUFFER, 17, 360 + 6, 407, 360 + 101, FALSE );
 
+	// CHRISL: Change both X paramters so they dynamically generate from right edge of screen
+	//SetFontDestBuffer( FRAME_BUFFER, (SCREEN_WIDTH - 509), (SCREEN_HEIGHT - 114), (SCREEN_WIDTH - 233), (SCREEN_HEIGHT - 114) + 101, FALSE );
+	// CHRISL: Use this setup if we want message box on the left side
 	SetFontDestBuffer( FRAME_BUFFER, 17, (SCREEN_HEIGHT - 114), 407, (SCREEN_HEIGHT - 114) + 101, FALSE );
 
 	SetFont( MAP_SCREEN_MESSAGE_FONT );		// no longer supports variable fonts
@@ -1120,6 +1124,9 @@
 		SetFontForeground( ( UINT8 )( gMapScreenMessageList[ ubCurrentStringIndex ]->usColor ) );
 
 		// print this line
+		// CHRISL: Change X parameter to dynamically generate from right edge of screen
+		//mprintf_coded( (SCREEN_WIDTH - 506), sY, gMapScreenMessageList[ ubCurrentStringIndex ]->pString16 );
+		// CHRISL: Use this line if we want to display from the left edge
 		mprintf_coded( 20, sY, gMapScreenMessageList[ ubCurrentStringIndex ]->pString16 );
 
 		sY += usSpacing;
@@ -1884,3 +1891,4 @@
 
 
 
+
Index: Utils/Text.h
===================================================================
--- Utils/Text.h	(revision 1299)
+++ Utils/Text.h	(working copy)
@@ -835,6 +835,7 @@
 	BOBBYR_FILTER_MISC_MEDKIT,
 	BOBBYR_FILTER_MISC_KIT,
 	BOBBYR_FILTER_MISC_FACE,
+	BOBBYR_FILTER_MISC_LBEGEAR,
 	BOBBYR_FILTER_MISC_MISC,
 };
 
@@ -1406,6 +1407,10 @@
 	GIO_BR_GREAT_TEXT,
 	GIO_BR_EXCELLENT_TEXT,
 	GIO_BR_AWESOME_TEXT,
+
+	GIO_INV_TEXT,
+	GIO_INV_OLD_TEXT,
+	GIO_INV_NEW_TEXT,
 };
 extern STR16	gzGIOScreenText[];
 
Index: Utils/XML_Items.cpp
===================================================================
--- Utils/XML_Items.cpp	(revision 1299)
+++ Utils/XML_Items.cpp	(working copy)
@@ -103,6 +103,7 @@
 				strcmp(name, "ubGraphicNum") == 0 ||
 				strcmp(name, "ubWeight") == 0 ||
 				strcmp(name, "ubPerPocket") == 0 ||
+				strcmp(name, "ItemSize") == 0 ||
 				strcmp(name, "usPrice") == 0 ||
 				strcmp(name, "ubCoolness") == 0 ||
 				strcmp(name, "bReliability") == 0 ||
@@ -162,6 +163,7 @@
 				strcmp(name, "DayVisionRangeBonus") == 0 ||
 				strcmp(name, "CaveVisionRangeBonus") == 0 ||
 				strcmp(name, "BrightLightVisionRangeBonus") == 0 ||
+				strcmp(name, "ItemSizeBonus") == 0 ||
 				strcmp(name, "LeatherJacket") == 0 ||
 				strcmp(name, "NeedsBatteries") == 0 ||
 				strcmp(name, "Batteries") == 0 ||
@@ -432,6 +434,11 @@
 			pData->curElement = ELEMENT;
 			pData->curItem.ubPerPocket = (UINT8) atol(pData->szCharData);
 		}
+		else if(strcmp(name, "ItemSize") == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curItem.ItemSize = (UINT8) atol(pData->szCharData);
+		}
 		else if(strcmp(name, "usPrice") == 0)
 		{
 			pData->curElement = ELEMENT;
@@ -849,6 +856,11 @@
 			pData->curElement = ELEMENT;
 			pData->curItem.brightlightvisionrangebonus    = (INT16) atol(pData->szCharData);
 		}
+		if(strcmp(name, "ItemSizeBonus")	 == 0)
+		{
+			pData->curElement = ELEMENT;
+			pData->curItem.itemsizebonus    = (INT16) atol(pData->szCharData);
+		}
 		else if(strcmp(name, "LeatherJacket")	 == 0)
 		{
 			pData->curElement = ELEMENT;
@@ -1373,6 +1385,7 @@
 			FilePrintf(hFile,"\t\t<ubGraphicNum>%d</ubGraphicNum>\r\n",						Item[cnt].ubGraphicNum);
 			FilePrintf(hFile,"\t\t<ubWeight>%d</ubWeight>\r\n",						Item[cnt].ubWeight);
 			FilePrintf(hFile,"\t\t<ubPerPocket>%d</ubPerPocket>\r\n",									Item[cnt].ubPerPocket);
+			FilePrintf(hFile,"\t\t<ItemSize>%d</ItemSize>\r\n",									Item[cnt].ItemSize);
 			FilePrintf(hFile,"\t\t<usPrice>%d</usPrice>\r\n",							Item[cnt].usPrice);
 			FilePrintf(hFile,"\t\t<ubCoolness>%d</ubCoolness>\r\n",								Item[cnt].ubCoolness);
 			FilePrintf(hFile,"\t\t<bReliability>%d</bReliability>\r\n",								Item[cnt].bReliability);
@@ -1483,6 +1496,7 @@
 			FilePrintf(hFile,"\t\t<DayVisionRangeBonus>%d</DayVisionRangeBonus>\r\n",						Item[cnt].dayvisionrangebonus  );
 			FilePrintf(hFile,"\t\t<CaveVisionRangeBonus>%d</CaveVisionRangeBonus>\r\n",						Item[cnt].cavevisionrangebonus  );
 			FilePrintf(hFile,"\t\t<BrightLightVisionRangeBonus>%d</BrightLightVisionRangeBonus>\r\n",						Item[cnt].brightlightvisionrangebonus  );
+			FilePrintf(hFile,"\t\t<ItemSizeBonus>%d</ItemSizeBonus>\r\n",						Item[cnt].itemsizebonus  );
 			FilePrintf(hFile,"\t\t<PercentTunnelVision>%d</PercentTunnelVision>\r\n",						Item[cnt].percenttunnelvision );
 			FilePrintf(hFile,"\t\t<ThermalOptics>%d</ThermalOptics>\r\n",						Item[cnt].thermaloptics );
 			FilePrintf(hFile,"\t\t<GasMask>%d</GasMask>\r\n",						Item[cnt].gasmask );
@@ -1516,4 +1530,4 @@
 	FileClose( hFile );
 
 	return( TRUE );
-}
\ No newline at end of file
+}
